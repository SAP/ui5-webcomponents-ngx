// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Snapshot test Fiori Bar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/Bar.js';
import Bar from '@ui5/webcomponents-fiori/dist/Bar.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['design'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-bar',
  template: '<ng-content></ng-content>',
  inputs: ['design'],
})
class BarComponent {
  /**
     Defines the component's design.
    */
  design!: 'Header' | 'Subheader' | 'Footer' | 'FloatingFooter';

  private elementRef: ElementRef<Bar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Bar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: Bar['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: Bar['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: Bar['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: Bar['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: Bar['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: Bar['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: Bar['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: Bar['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: Bar['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: Bar['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: Bar['focus'];

  /**
     
    */
  fireEvent!: Bar['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: Bar['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: Bar['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: Bar['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: Bar['getStaticAreaItemDomRef'];
}
export { BarComponent };
"
`;

exports[`Snapshot test Fiori Barcode Scanner Dialog should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/BarcodeScannerDialog.js';
import {
  default as BarcodeScannerDialog,
  BarcodeScannerDialogScanErrorEventDetail,
  BarcodeScannerDialogScanSuccessEventDetail,
} from '@ui5/webcomponents-fiori/dist/BarcodeScannerDialog.js';
import { ProxyMethods, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';

@ProxyOutputs(['scan-success: ui5ScanSuccess', 'scan-error: ui5ScanError'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
  'show',
  'close',
])
@Component({
  standalone: true,
  selector: 'ui5-barcode-scanner-dialog',
  template: '<ng-content></ng-content>',
  outputs: ['ui5ScanSuccess', 'ui5ScanError'],
})
class BarcodeScannerDialogComponent {
  /**
     Fires when the scan is completed successfuuly.
    */
  ui5ScanSuccess!: EventEmitter<BarcodeScannerDialogScanSuccessEventDetail>;
  /**
     Fires when the scan fails with error.
    */
  ui5ScanError!: EventEmitter<BarcodeScannerDialogScanErrorEventDetail>;

  private elementRef: ElementRef<BarcodeScannerDialog> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): BarcodeScannerDialog {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: BarcodeScannerDialog['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: BarcodeScannerDialog['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: BarcodeScannerDialog['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: BarcodeScannerDialog['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: BarcodeScannerDialog['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: BarcodeScannerDialog['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: BarcodeScannerDialog['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: BarcodeScannerDialog['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: BarcodeScannerDialog['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: BarcodeScannerDialog['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: BarcodeScannerDialog['focus'];

  /**
     
    */
  fireEvent!: BarcodeScannerDialog['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: BarcodeScannerDialog['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: BarcodeScannerDialog['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: BarcodeScannerDialog['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: BarcodeScannerDialog['getStaticAreaItemDomRef'];

  /**
     Shows a dialog with the camera videostream. Starts a scan session.
    */
  show!: BarcodeScannerDialog['show'];

  /**
     Closes the dialog and the scan session.
    */
  close!: BarcodeScannerDialog['close'];
}
export { BarcodeScannerDialogComponent };
"
`;

exports[`Snapshot test Fiori Dynamic Side Content should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/DynamicSideContent.js';
import {
  default as DynamicSideContent,
  DynamicSideContentLayoutChangeEventDetail,
} from '@ui5/webcomponents-fiori/dist/DynamicSideContent.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'hideMainContent',
  'hideSideContent',
  'sideContentPosition',
  'sideContentVisibility',
  'sideContentFallDown',
  'equalSplit',
])
@ProxyOutputs(['layout-change: ui5LayoutChange'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
  'toggleContents',
])
@Component({
  standalone: true,
  selector: 'ui5-dynamic-side-content',
  template: '<ng-content></ng-content>',
  inputs: [
    'hideMainContent',
    'hideSideContent',
    'sideContentPosition',
    'sideContentVisibility',
    'sideContentFallDown',
    'equalSplit',
  ],
  outputs: ['ui5LayoutChange'],
})
class DynamicSideContentComponent {
  /**
     Defines the visibility of the main content.
    */
  hideMainContent!: boolean;

  /**
     Defines the visibility of the side content.
    */
  hideSideContent!: boolean;

  /**
     Defines whether the side content is positioned before the main content (left side
in LTR mode), or after the the main content (right side in LTR mode).

<br><br>
<b>The available values are:</b>

<ul>
<li><code>Start</code></li>
<li><code>End</code></li>
</ul>
    */
  sideContentPosition!: 'End' | 'Start';

  /**
     Defines on which breakpoints the side content is visible.

<br><br>
<b>The available values are:</b>

<ul>
<li><code>AlwaysShow</code></li>
<li><code>ShowAboveL</code></li>
<li><code>ShowAboveM</code></li>
<li><code>ShowAboveS</code></li>
<li><code>NeverShow</code></li>
</ul>
    */
  sideContentVisibility!:
    | 'AlwaysShow'
    | 'ShowAboveL'
    | 'ShowAboveM'
    | 'ShowAboveS'
    | 'NeverShow';

  /**
     Defines on which breakpoints the side content falls down below the main content.

<br><br>
<b>The available values are:</b>

<ul>
<li><code>BelowXL</code></li>
<li><code>BelowL</code></li>
<li><code>BelowM</code></li>
<li><code>OnMinimumWidth</code></li>
</ul>
    */
  sideContentFallDown!: 'BelowXL' | 'BelowL' | 'BelowM' | 'OnMinimumWidth';

  /**
     Defines whether the component is in equal split mode. In this mode, the side and
the main content take 50:50 percent of the container on all screen sizes
except for phone, where the main and side contents are switching visibility
using the toggle method.
    */
  equalSplit!: boolean;

  /**
     Fires when the current breakpoint has been changed.
    */
  ui5LayoutChange!: EventEmitter<DynamicSideContentLayoutChangeEventDetail>;

  private elementRef: ElementRef<DynamicSideContent> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): DynamicSideContent {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: DynamicSideContent['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: DynamicSideContent['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: DynamicSideContent['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: DynamicSideContent['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: DynamicSideContent['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: DynamicSideContent['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: DynamicSideContent['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: DynamicSideContent['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: DynamicSideContent['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: DynamicSideContent['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: DynamicSideContent['focus'];

  /**
     
    */
  fireEvent!: DynamicSideContent['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: DynamicSideContent['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: DynamicSideContent['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: DynamicSideContent['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: DynamicSideContent['getStaticAreaItemDomRef'];

  /**
     Toggles visibility of main and side contents on S screen size (mobile device).
    */
  toggleContents!: DynamicSideContent['toggleContents'];
}
export { DynamicSideContentComponent };
"
`;

exports[`Snapshot test Fiori Filter Item Option should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/FilterItemOption.js';
import FilterItemOption from '@ui5/webcomponents-fiori/dist/FilterItemOption.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['text', 'selected'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-filter-item-option',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'selected'],
})
class FilterItemOptionComponent {
  /**
     Defines the text of the component.
    */
  text!: string;

  /**
     Defines if the component is selected.
    */
  selected!: boolean;

  private elementRef: ElementRef<FilterItemOption> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): FilterItemOption {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: FilterItemOption['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: FilterItemOption['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: FilterItemOption['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: FilterItemOption['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: FilterItemOption['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: FilterItemOption['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: FilterItemOption['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: FilterItemOption['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: FilterItemOption['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: FilterItemOption['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: FilterItemOption['focus'];

  /**
     
    */
  fireEvent!: FilterItemOption['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: FilterItemOption['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: FilterItemOption['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: FilterItemOption['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: FilterItemOption['getStaticAreaItemDomRef'];
}
export { FilterItemOptionComponent };
"
`;

exports[`Snapshot test Fiori Filter Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/FilterItem.js';
import FilterItem from '@ui5/webcomponents-fiori/dist/FilterItem.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['text', 'additionalText'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-filter-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'additionalText'],
})
class FilterItemComponent {
  /**
     Defines the text of the component.
    */
  text!: string;

  /**
     Defines the additional text of the component.
    */
  additionalText!: string;

  private elementRef: ElementRef<FilterItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): FilterItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: FilterItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: FilterItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: FilterItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: FilterItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: FilterItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: FilterItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: FilterItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: FilterItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: FilterItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: FilterItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: FilterItem['focus'];

  /**
     
    */
  fireEvent!: FilterItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: FilterItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: FilterItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: FilterItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: FilterItem['getStaticAreaItemDomRef'];
}
export { FilterItemComponent };
"
`;

exports[`Snapshot test Fiori Flexible Column Layout should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/FlexibleColumnLayout.js';
import {
  default as FlexibleColumnLayout,
  FlexibleColumnLayoutAccessibilityRoles,
  FlexibleColumnLayoutAccessibilityTexts,
  FlexibleColumnLayoutLayoutChangeEventDetail,
} from '@ui5/webcomponents-fiori/dist/FlexibleColumnLayout.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'layout',
  'hideArrows',
  'accessibilityTexts',
  'accessibilityRoles',
])
@ProxyOutputs(['layout-change: ui5LayoutChange'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-flexible-column-layout',
  template: '<ng-content></ng-content>',
  inputs: ['layout', 'hideArrows', 'accessibilityTexts', 'accessibilityRoles'],
  outputs: ['ui5LayoutChange'],
})
class FlexibleColumnLayoutComponent {
  /**
     Defines the columns layout and their proportion.
<br><br>
<b>Note:</b> The layout also depends on the screen size - one column for screens smaller than 599px,
two columns between 599px and 1023px and three columns for sizes bigger than 1023px.
<br><br>
<b>For example:</b> layout=<code>TwoColumnsStartExpanded</code> means the layout will display up to two columns
in 67%/33% proportion.
    */
  layout!:
    | 'OneColumn'
    | 'TwoColumnsStartExpanded'
    | 'TwoColumnsMidExpanded'
    | 'ThreeColumnsMidExpanded'
    | 'ThreeColumnsEndExpanded'
    | 'ThreeColumnsStartExpandedEndHidden'
    | 'ThreeColumnsMidExpandedEndHidden'
    | 'MidColumnFullScreen'
    | 'EndColumnFullScreen';

  /**
     Defines the visibility of the arrows,
used for expanding and shrinking the columns.
    */
  hideArrows!: boolean;

  /**
     An object of strings that defines several additional accessibility texts for even further customization.

It supports the following fields:
 - <code>startColumnAccessibleName</code>: the accessibility name for the <code>startColumn</code> region
 - <code>midColumnAccessibleName</code>: the accessibility name for the <code>midColumn</code> region
 - <code>endColumnAccessibleName</code>: the accessibility name for the <code>endColumn</code> region
 - <code>startArrowLeftText</code>: the text that the first arrow (between the <code>begin</code> and <code>mid</code> columns) will have when pointing to the left
 - <code>startArrowRightText</code>: the text that the first arrow (between the <code>begin</code> and <code>mid</code> columns) will have when pointing to the right
 - <code>endArrowLeftText</code>: the text that the second arrow (between the <code>mid</code> and <code>end</code> columns) will have when pointing to the left
 - <code>endArrowRightText</code>: the text that the second arrow (between the <code>mid</code> and <code>end</code> columns) will have when pointing to the right
 - <code>startArrowContainerAccessibleName</code>: the text that the first arrow container (between the <code>begin</code> and <code>mid</code> columns) will have as <code>aria-label</code>
 - <code>endArrowContainerAccessibleName</code>: the text that the second arrow container (between the <code>mid</code> and <code>end</code> columns) will have as <code>aria-label</code>
    */
  accessibilityTexts!: FlexibleColumnLayoutAccessibilityTexts;

  /**
     An object of strings that defines additional accessibility roles for further customization.

It supports the following fields:
 - <code>startColumnRole</code>: the accessibility role for the <code>startColumn</code>
 - <code>startArrowContainerRole</code>: the accessibility role for the first arrow container (between the <code>begin</code> and <code>mid</code> columns)
 - <code>midColumnRole</code>: the accessibility role for the <code>midColumn</code>
 - <code>endArrowContainerRole</code>: the accessibility role for the second arrow container (between the <code>mid</code> and <code>end</code> columns)
 - <code>endColumnRole</code>: the accessibility role for the <code>endColumn</code>
    */
  accessibilityRoles!: FlexibleColumnLayoutAccessibilityRoles;

  /**
     Fired when the layout changes via user interaction by clicking the arrows
or by changing the component size due to resizing.
    */
  ui5LayoutChange!: EventEmitter<FlexibleColumnLayoutLayoutChangeEventDetail>;

  private elementRef: ElementRef<FlexibleColumnLayout> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): FlexibleColumnLayout {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: FlexibleColumnLayout['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: FlexibleColumnLayout['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: FlexibleColumnLayout['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: FlexibleColumnLayout['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: FlexibleColumnLayout['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: FlexibleColumnLayout['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: FlexibleColumnLayout['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: FlexibleColumnLayout['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: FlexibleColumnLayout['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: FlexibleColumnLayout['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: FlexibleColumnLayout['focus'];

  /**
     
    */
  fireEvent!: FlexibleColumnLayout['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: FlexibleColumnLayout['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: FlexibleColumnLayout['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: FlexibleColumnLayout['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: FlexibleColumnLayout['getStaticAreaItemDomRef'];
}
export { FlexibleColumnLayoutComponent };
"
`;

exports[`Snapshot test Fiori Illustrated Message should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/IllustratedMessage.js';
import IllustratedMessage from '@ui5/webcomponents-fiori/dist/IllustratedMessage.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'name',
  'size',
  'subtitleText',
  'titleText',
  'accessibleNameRef',
  'titleLevel',
])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-illustrated-message',
  template: '<ng-content></ng-content>',
  inputs: [
    'name',
    'size',
    'subtitleText',
    'titleText',
    'accessibleNameRef',
    'titleLevel',
  ],
})
class IllustratedMessageComponent {
  /**
     Defines the illustration name that will be displayed in the component.
<br>
Example:
<br>
<code>name='BeforeSearch'</code>, <code>name='UnableToUpload'</code>, etc..
<br>
<br>
<b>Note:</b> To use the TNT illustrations,
you need to set the <code>tnt</code> or <code>Tnt</code> prefix in front of the icon's name.
<br>
Example:
<br>
<code>name='tnt/Avatar'</code> or <code>name='TntAvatar'</code>.
<br>
<br>
<b>Note:</b> By default the <code>BeforeSearch</code> illustration is loaded.
When using an illustration type, other than the default, it should be loaded in addition:
<br>
<code>import \\"@ui5/webcomponents-fiori/dist/illustrations/NoData.js\\";</code>
<br>
<br>
For TNT illustrations:
<br>
<code>import \\"@ui5/webcomponents-fiori/dist/illustrations/tnt/SessionExpired.js\\";</code>
    */
  name!: string;

  /**
     Determines which illustration breakpoint variant is used.
<br><br>

As <code>IllustratedMessage</code> adapts itself around the <code>Illustration</code>, the other
elements of the component are displayed differently on the different breakpoints/illustration sizes.
    */
  size!: 'Auto' | 'Base' | 'Spot' | 'Dialog' | 'Scene';

  /**
     Defines the subtitle of the component.
<br><br>
<b>Note:</b> Using this property, the default subtitle text of illustration will be overwritten.
<br><br>
<b>Note:</b> Using <code>subtitle</code> slot, the default of this property will be overwritten.
    */
  subtitleText!: string;

  /**
     Defines the title of the component.
<br><br>
<b>Note:</b> Using this property, the default title text of illustration will be overwritten.
    */
  titleText!: string;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Defines the semantic level of the title.

<b>Note:</b> Used for accessibility purposes only.
    */
  titleLevel!: 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6';

  private elementRef: ElementRef<IllustratedMessage> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): IllustratedMessage {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: IllustratedMessage['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: IllustratedMessage['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: IllustratedMessage['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: IllustratedMessage['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: IllustratedMessage['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: IllustratedMessage['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: IllustratedMessage['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: IllustratedMessage['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: IllustratedMessage['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: IllustratedMessage['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: IllustratedMessage['focus'];

  /**
     
    */
  fireEvent!: IllustratedMessage['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: IllustratedMessage['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: IllustratedMessage['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: IllustratedMessage['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: IllustratedMessage['getStaticAreaItemDomRef'];
}
export { IllustratedMessageComponent };
"
`;

exports[`Snapshot test Fiori Index Ts should match the snapshot 1`] = `"export { Ui5FioriModule } from './ui5-fiori.module';"`;

exports[`Snapshot test Fiori Media Gallery Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/MediaGalleryItem.js';
import MediaGalleryItem from '@ui5/webcomponents-fiori/dist/MediaGalleryItem.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['selected', 'disabled', 'layout'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-media-gallery-item',
  template: '<ng-content></ng-content>',
  inputs: ['selected', 'disabled', 'layout'],
})
class MediaGalleryItemComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  /**
     Defines whether the component is in disabled state.
    */
  disabled!: boolean;

  /**
     Determines the layout of the item container.
<br><br>
Available options are:
<ul>
<li><code>Square</code></li>
<li><code>Wide</code></li>
</ul>
    */
  layout!: 'Square' | 'Wide';

  private elementRef: ElementRef<MediaGalleryItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MediaGalleryItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: MediaGalleryItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: MediaGalleryItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: MediaGalleryItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: MediaGalleryItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: MediaGalleryItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: MediaGalleryItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: MediaGalleryItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: MediaGalleryItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: MediaGalleryItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: MediaGalleryItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: MediaGalleryItem['focus'];

  /**
     
    */
  fireEvent!: MediaGalleryItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: MediaGalleryItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: MediaGalleryItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: MediaGalleryItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: MediaGalleryItem['getStaticAreaItemDomRef'];
}
export { MediaGalleryItemComponent };
"
`;

exports[`Snapshot test Fiori Media Gallery should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/MediaGallery.js';
import {
  default as MediaGallery,
  MediaGallerySelectionChangeEventDetail,
} from '@ui5/webcomponents-fiori/dist/MediaGallery.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'showAllThumbnails',
  'interactiveDisplayArea',
  'layout',
  'menuHorizontalAlign',
  'menuVerticalAlign',
])
@ProxyOutputs([
  'selection-change: ui5SelectionChange',
  'overflow-click: ui5OverflowClick',
  'display-area-click: ui5DisplayAreaClick',
])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-media-gallery',
  template: '<ng-content></ng-content>',
  inputs: [
    'showAllThumbnails',
    'interactiveDisplayArea',
    'layout',
    'menuHorizontalAlign',
    'menuVerticalAlign',
  ],
  outputs: ['ui5SelectionChange', 'ui5OverflowClick', 'ui5DisplayAreaClick'],
})
class MediaGalleryComponent {
  /**
     If set to <code>true</code>, all thumbnails are rendered in a scrollable container.
If <code>false</code>, only up to five thumbnails are rendered, followed by
an overflow button that shows the count of the remaining thumbnails.
    */
  showAllThumbnails!: boolean;

  /**
     If enabled, a <code>display-area-click</code> event is fired
when the user clicks or taps on the display area.
<br>
The display area is the central area that contains
the enlarged content of the currently selected item.
    */
  interactiveDisplayArea!: boolean;

  /**
     Determines the layout of the component.
    */
  layout!: 'Auto' | 'Vertical' | 'Horizontal';

  /**
     Determines the horizontal alignment of the thumbnails menu
vs. the central display area.
    */
  menuHorizontalAlign!: 'Left' | 'Right';

  /**
     Determines the vertical alignment of the thumbnails menu
vs. the central display area.
    */
  menuVerticalAlign!: 'Top' | 'Bottom';

  /**
     Fired when selection is changed by user interaction.
    */
  ui5SelectionChange!: EventEmitter<MediaGallerySelectionChangeEventDetail>;
  /**
     Fired when the thumbnails overflow button is clicked.
    */
  ui5OverflowClick!: EventEmitter<void>;
  /**
     Fired when the display area is clicked.<br>
The display area is the central area that contains
the enlarged content of the currently selected item.
    */
  ui5DisplayAreaClick!: EventEmitter<void>;

  private elementRef: ElementRef<MediaGallery> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MediaGallery {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: MediaGallery['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: MediaGallery['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: MediaGallery['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: MediaGallery['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: MediaGallery['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: MediaGallery['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: MediaGallery['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: MediaGallery['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: MediaGallery['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: MediaGallery['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: MediaGallery['focus'];

  /**
     
    */
  fireEvent!: MediaGallery['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: MediaGallery['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: MediaGallery['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: MediaGallery['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: MediaGallery['getStaticAreaItemDomRef'];
}
export { MediaGalleryComponent };
"
`;

exports[`Snapshot test Fiori Ng Package Json should match the snapshot 1`] = `"{\\"lib\\":{\\"entryFile\\":\\"./index.ts\\"}}"`;

exports[`Snapshot test Fiori Notification Action should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/NotificationAction.js';
import {
  default as NotificationAction,
  NotificationActionClickEventDetail,
} from '@ui5/webcomponents-fiori/dist/NotificationAction.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['text', 'disabled', 'design', 'icon'])
@ProxyOutputs(['click: ui5Click'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-notification-action',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'disabled', 'design', 'icon'],
  outputs: ['ui5Click'],
})
class NotificationActionComponent {
  /**
     Defines the text of the <code>ui5-notification-action</code>.
    */
  text!: string;

  /**
     Defines if the action is disabled.
<br><br>
<b>Note:</b> a disabled action can't be pressed or focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Defines the action design.
    */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';

  /**
     Defines the <code>icon</code> source URI.
<br><br>
<b>Note:</b>
SAP-icons font provides numerous built-in icons. To find all the available icons, see the
<ui5-link target=\\"_blank\\" href=\\"https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html\\">Icon Explorer</ui5-link>.
    */
  icon!: string;

  /**
     Fired, when the action is pressed.
    */
  ui5Click!: EventEmitter<NotificationActionClickEventDetail>;

  private elementRef: ElementRef<NotificationAction> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): NotificationAction {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: NotificationAction['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: NotificationAction['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: NotificationAction['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: NotificationAction['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: NotificationAction['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: NotificationAction['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: NotificationAction['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: NotificationAction['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: NotificationAction['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: NotificationAction['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: NotificationAction['focus'];

  /**
     
    */
  fireEvent!: NotificationAction['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: NotificationAction['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: NotificationAction['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: NotificationAction['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: NotificationAction['getStaticAreaItemDomRef'];
}
export { NotificationActionComponent };
"
`;

exports[`Snapshot test Fiori Notification List Group Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/NotificationListGroupItem.js';
import NotificationListGroupItem from '@ui5/webcomponents-fiori/dist/NotificationListGroupItem.js';
import { NotificationListItemBaseCloseEventDetail } from '@ui5/webcomponents-fiori/dist/NotificationListItemBase.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'selected',
  'titleText',
  'priority',
  'showClose',
  'read',
  'busy',
  'busyDelay',
  'collapsed',
  'showCounter',
])
@ProxyOutputs(['close: ui5Close', 'toggle: ui5Toggle'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-li-notification-group',
  template: '<ng-content></ng-content>',
  inputs: [
    'selected',
    'titleText',
    'priority',
    'showClose',
    'read',
    'busy',
    'busyDelay',
    'collapsed',
    'showCounter',
  ],
  outputs: ['ui5Close', 'ui5Toggle'],
})
class NotificationListGroupItemComponent {
  /**
     Defines the selected state of the <code>ListItem</code>.
    */
  selected!: boolean;

  /**
     Defines the <code>titleText</code> of the item.
    */
  titleText!: string;

  /**
     Defines the <code>priority</code> of the item.
    */
  priority!: 'High' | 'Medium' | 'Low' | 'None';

  /**
     Defines if the <code>close</code> button would be displayed.
    */
  showClose!: boolean;

  /**
     Defines if the <code>notification</code> is new or has been already read.
<br><br>
<b>Note:</b> if set to <code>false</code> the <code>titleText</code> has bold font,
if set to true - it has a normal font.
    */
  read!: boolean;

  /**
     Defines if a busy indicator would be displayed over the item.
    */
  busy!: boolean;

  /**
     Defines the delay in milliseconds, after which the busy indicator will show up for this component.
    */
  busyDelay!: number;

  /**
     Defines if the group is collapsed or expanded.
    */
  collapsed!: boolean;

  /**
     Defines if the items <code>counter</code> would be displayed.
    */
  showCounter!: boolean;

  /**
     Fired when the <code>Close</code> button is pressed.
    */
  ui5Close!: EventEmitter<NotificationListItemBaseCloseEventDetail>;
  /**
     Fired when the <code>ui5-li-notification-group</code> is expanded/collapsed by user interaction.
    */
  ui5Toggle!: EventEmitter<void>;

  private elementRef: ElementRef<NotificationListGroupItem> =
    inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): NotificationListGroupItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: NotificationListGroupItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: NotificationListGroupItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: NotificationListGroupItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: NotificationListGroupItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: NotificationListGroupItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: NotificationListGroupItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: NotificationListGroupItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: NotificationListGroupItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: NotificationListGroupItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: NotificationListGroupItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: NotificationListGroupItem['focus'];

  /**
     
    */
  fireEvent!: NotificationListGroupItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: NotificationListGroupItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: NotificationListGroupItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: NotificationListGroupItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: NotificationListGroupItem['getStaticAreaItemDomRef'];
}
export { NotificationListGroupItemComponent };
"
`;

exports[`Snapshot test Fiori Notification List Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/NotificationListItem.js';
import NotificationListItem from '@ui5/webcomponents-fiori/dist/NotificationListItem.js';
import { NotificationListItemBaseCloseEventDetail } from '@ui5/webcomponents-fiori/dist/NotificationListItemBase.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'selected',
  'titleText',
  'priority',
  'showClose',
  'read',
  'busy',
  'busyDelay',
  'wrappingType',
])
@ProxyOutputs(['close: ui5Close'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-li-notification',
  template: '<ng-content></ng-content>',
  inputs: [
    'selected',
    'titleText',
    'priority',
    'showClose',
    'read',
    'busy',
    'busyDelay',
    'wrappingType',
  ],
  outputs: ['ui5Close'],
})
class NotificationListItemComponent {
  /**
     Defines the selected state of the <code>ListItem</code>.
    */
  selected!: boolean;

  /**
     Defines the <code>titleText</code> of the item.
    */
  titleText!: string;

  /**
     Defines the <code>priority</code> of the item.
    */
  priority!: 'High' | 'Medium' | 'Low' | 'None';

  /**
     Defines if the <code>close</code> button would be displayed.
    */
  showClose!: boolean;

  /**
     Defines if the <code>notification</code> is new or has been already read.
<br><br>
<b>Note:</b> if set to <code>false</code> the <code>titleText</code> has bold font,
if set to true - it has a normal font.
    */
  read!: boolean;

  /**
     Defines if a busy indicator would be displayed over the item.
    */
  busy!: boolean;

  /**
     Defines the delay in milliseconds, after which the busy indicator will show up for this component.
    */
  busyDelay!: number;

  /**
     Defines if the <code>titleText</code> and <code>description</code> should wrap,
they truncate by default.

<br><br>
<b>Note:</b> by default the <code>titleText</code> and <code>description</code>,
and a <code>ShowMore/Less</code> button would be displayed.
    */
  wrappingType!: 'None' | 'Normal';

  /**
     Fired when the <code>Close</code> button is pressed.
    */
  ui5Close!: EventEmitter<NotificationListItemBaseCloseEventDetail>;

  private elementRef: ElementRef<NotificationListItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): NotificationListItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: NotificationListItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: NotificationListItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: NotificationListItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: NotificationListItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: NotificationListItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: NotificationListItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: NotificationListItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: NotificationListItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: NotificationListItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: NotificationListItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: NotificationListItem['focus'];

  /**
     
    */
  fireEvent!: NotificationListItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: NotificationListItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: NotificationListItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: NotificationListItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: NotificationListItem['getStaticAreaItemDomRef'];
}
export { NotificationListItemComponent };
"
`;

exports[`Snapshot test Fiori Page should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/Page.js';
import Page from '@ui5/webcomponents-fiori/dist/Page.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'backgroundDesign',
  'disableScrolling',
  'floatingFooter',
  'hideFooter',
])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-page',
  template: '<ng-content></ng-content>',
  inputs: [
    'backgroundDesign',
    'disableScrolling',
    'floatingFooter',
    'hideFooter',
  ],
})
class PageComponent {
  /**
     Defines the background color of the <code>ui5-page</code>.
<br><br>
<b>Note:</b> When a ui5-list is placed inside the page, we recommend using List to ensure better color contrast.
<br><br>
    */
  backgroundDesign!: 'List' | 'Solid' | 'Transparent';

  /**
     Disables vertical scrolling of page content.
If set to true, there will be no vertical scrolling at all.
    */
  disableScrolling!: boolean;

  /**
     Defines if the footer should float over the content.
<br><br>
<b>Note:</b> When set to true the footer floats over the content with a slight offset from the bottom, otherwise it is fixed at the very bottom of the page.
    */
  floatingFooter!: boolean;

  /**
     Defines the footer visibility.
    */
  hideFooter!: boolean;

  private elementRef: ElementRef<Page> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Page {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: Page['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: Page['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: Page['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: Page['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: Page['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: Page['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: Page['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: Page['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: Page['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: Page['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: Page['focus'];

  /**
     
    */
  fireEvent!: Page['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: Page['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: Page['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: Page['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: Page['getStaticAreaItemDomRef'];
}
export { PageComponent };
"
`;

exports[`Snapshot test Fiori Product Switch Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/ProductSwitchItem.js';
import ProductSwitchItem from '@ui5/webcomponents-fiori/dist/ProductSwitchItem.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['titleText', 'subtitleText', 'icon', 'target', 'targetSrc'])
@ProxyOutputs(['click: ui5Click'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-product-switch-item',
  template: '<ng-content></ng-content>',
  inputs: ['titleText', 'subtitleText', 'icon', 'target', 'targetSrc'],
  outputs: ['ui5Click'],
})
class ProductSwitchItemComponent {
  /**
     Defines the title of the component.
    */
  titleText!: string;

  /**
     Defines the subtitle of the component.
    */
  subtitleText!: string;

  /**
     Defines the icon to be displayed as a graphical element within the component.
<br><br>
Example:
<br>
<pre>ui5-product-switch-item icon=\\"palette\\"</pre>

See all the available icons in the <ui5-link target=\\"_blank\\" href=\\"https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html\\">Icon Explorer</ui5-link>.
    */
  icon!: string;

  /**
     Defines a target where the <code>targetSrc</code> content must be open.
<br><br>
Available options are:
<ul>
<li><code>_self</code></li>
<li><code>_top</code></li>
<li><code>_blank</code></li>
<li><code>_parent</code></li>
<li><code>_search</code></li>
</ul>
    */
  target!: string;

  /**
     Defines the component target URI. Supports standard hyperlink behavior.
    */
  targetSrc!: string;

  /**
     Fired when the <code>ui5-product-switch-item</code> is activated either with a
click/tap or by using the Enter or Space key.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<ProductSwitchItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ProductSwitchItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: ProductSwitchItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: ProductSwitchItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: ProductSwitchItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: ProductSwitchItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: ProductSwitchItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: ProductSwitchItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: ProductSwitchItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: ProductSwitchItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: ProductSwitchItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: ProductSwitchItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: ProductSwitchItem['focus'];

  /**
     
    */
  fireEvent!: ProductSwitchItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: ProductSwitchItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: ProductSwitchItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: ProductSwitchItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: ProductSwitchItem['getStaticAreaItemDomRef'];
}
export { ProductSwitchItemComponent };
"
`;

exports[`Snapshot test Fiori Product Switch should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/ProductSwitch.js';
import ProductSwitch from '@ui5/webcomponents-fiori/dist/ProductSwitch.js';
import { ProxyMethods } from '@ui5/webcomponents-ngx/utils';

@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-product-switch',
  template: '<ng-content></ng-content>',
})
class ProductSwitchComponent {
  private elementRef: ElementRef<ProductSwitch> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ProductSwitch {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: ProductSwitch['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: ProductSwitch['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: ProductSwitch['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: ProductSwitch['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: ProductSwitch['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: ProductSwitch['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: ProductSwitch['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: ProductSwitch['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: ProductSwitch['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: ProductSwitch['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: ProductSwitch['focus'];

  /**
     
    */
  fireEvent!: ProductSwitch['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: ProductSwitch['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: ProductSwitch['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: ProductSwitch['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: ProductSwitch['getStaticAreaItemDomRef'];
}
export { ProductSwitchComponent };
"
`;

exports[`Snapshot test Fiori Shell Bar Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/ShellBarItem.js';
import {
  default as ShellBarItem,
  ShellBarItemClickEventDetail,
} from '@ui5/webcomponents-fiori/dist/ShellBarItem.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['icon', 'text', 'count'])
@ProxyOutputs(['click: ui5Click'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-shellbar-item',
  template: '<ng-content></ng-content>',
  inputs: ['icon', 'text', 'count'],
  outputs: ['ui5Click'],
})
class ShellBarItemComponent {
  /**
     Defines the name of the item's icon.
    */
  icon!: string;

  /**
     Defines the item text.
  <br><br>
  <b>Note:</b> The text is only displayed inside the overflow popover list view.
    */
  text!: string;

  /**
     Defines the count displayed in the top-right corner.
    */
  count!: string;

  /**
     Fired, when the item is pressed.
    */
  ui5Click!: EventEmitter<ShellBarItemClickEventDetail>;

  private elementRef: ElementRef<ShellBarItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ShellBarItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: ShellBarItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: ShellBarItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: ShellBarItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: ShellBarItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: ShellBarItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: ShellBarItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: ShellBarItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: ShellBarItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: ShellBarItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: ShellBarItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: ShellBarItem['focus'];

  /**
     
    */
  fireEvent!: ShellBarItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: ShellBarItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: ShellBarItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: ShellBarItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: ShellBarItem['getStaticAreaItemDomRef'];
}
export { ShellBarItemComponent };
"
`;

exports[`Snapshot test Fiori Shell Bar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/ShellBar.js';
import {
  default as ShellBar,
  ShellBarAccessibilityAttributes,
  ShellBarAccessibilityRoles,
  ShellBarAccessibilityTexts,
  ShellBarCoPilotClickEventDetail,
  ShellBarLogoClickEventDetail,
  ShellBarMenuItemClickEventDetail,
  ShellBarNotificationsClickEventDetail,
  ShellBarProductSwitchClickEventDetail,
  ShellBarProfileClickEventDetail,
} from '@ui5/webcomponents-fiori/dist/ShellBar.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'primaryTitle',
  'secondaryTitle',
  'notificationsCount',
  'showNotifications',
  'showProductSwitch',
  'showCoPilot',
  'showSearchField',
  'accessibilityRoles',
  'accessibilityTexts',
  'accessibilityAttributes',
])
@ProxyOutputs([
  'notifications-click: ui5NotificationsClick',
  'profile-click: ui5ProfileClick',
  'product-switch-click: ui5ProductSwitchClick',
  'logo-click: ui5LogoClick',
  'co-pilot-click: ui5CoPilotClick',
  'menu-item-click: ui5MenuItemClick',
])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
  'closeOverflow',
])
@Component({
  standalone: true,
  selector: 'ui5-shellbar',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryTitle',
    'secondaryTitle',
    'notificationsCount',
    'showNotifications',
    'showProductSwitch',
    'showCoPilot',
    'showSearchField',
    'accessibilityRoles',
    'accessibilityTexts',
    'accessibilityAttributes',
  ],
  outputs: [
    'ui5NotificationsClick',
    'ui5ProfileClick',
    'ui5ProductSwitchClick',
    'ui5LogoClick',
    'ui5CoPilotClick',
    'ui5MenuItemClick',
  ],
})
class ShellBarComponent {
  /**
     Defines the <code>primaryTitle</code>.
<br><br>
<b>Note:</b> The <code>primaryTitle</code> would be hidden on S screen size (less than approx. 700px).
    */
  primaryTitle!: string;

  /**
     Defines the <code>secondaryTitle</code>.
<br><br>
<b>Note:</b> The <code>secondaryTitle</code> would be hidden on S and M screen sizes (less than approx. 1300px).
    */
  secondaryTitle!: string;

  /**
     Defines the <code>notificationsCount</code>,
displayed in the notification icon top-right corner.
    */
  notificationsCount!: string;

  /**
     Defines, if the notification icon would be displayed.
    */
  showNotifications!: boolean;

  /**
     Defines, if the product switch icon would be displayed.
    */
  showProductSwitch!: boolean;

  /**
     Defines, if the product CoPilot icon would be displayed.
<br><b>Note:</b> By default the co-pilot is displayed as static SVG.
If you need an animated co-pilot, you can import the <code>\\"@ui5/webcomponents-fiori/dist/features/CoPilotAnimation.js\\"</code> module as add-on feature.
    */
  showCoPilot!: boolean;

  /**
     Defines, if the Search Field would be displayed when there is a valid <code>searchField</code> slot.
<br><b>Note:</b> By default the Search Field is not displayed.
    */
  showSearchField!: boolean;

  /**
     An object of strings that defines additional accessibility roles for further customization.

It supports the following fields:
 - <code>logoRole</code>: the accessibility role for the <code>logo</code>
    */
  accessibilityRoles!: ShellBarAccessibilityRoles;

  /**
     An object of strings that defines several additional accessibility texts
for even further customization.

It supports the following fields:
- <code>profileButtonTitle</code>: defines the tooltip for the profile button
- <code>logoTitle</code>: defines the tooltip for the logo
    */
  accessibilityTexts!: ShellBarAccessibilityTexts;

  /**
     An object of strings that defines several additional accessibility attribute values
for customization depending on the use case.

It supports the following fields:

<ul>
		<li><code>expanded</code>: Indicates whether the anchor element, or another grouping element it controls, is currently expanded or collapsed. Accepts the following string values:
		<ul>
			<li><code>true</code></li>
			<li><code>false</code></li>
		</ul>
		</li>
		<li><code>hasPopup</code>: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the anchor element. Accepts the following string values:
			<ul>
			<li><code>Dialog</code></li>
			<li><code>Grid</code></li>
			<li><code>ListBox</code></li>
			<li><code>Menu</code></li>
			<li><code>Tree</code></li>
			</ul>
		</li>
</ul>
    */
  accessibilityAttributes!: ShellBarAccessibilityAttributes;

  /**
     Fired, when the notification icon is activated.
    */
  ui5NotificationsClick!: EventEmitter<ShellBarNotificationsClickEventDetail>;
  /**
     Fired, when the profile slot is present.
    */
  ui5ProfileClick!: EventEmitter<ShellBarProfileClickEventDetail>;
  /**
     Fired, when the product switch icon is activated.
<b>Note:</b> You can prevent closing of overflow popover by calling <code>event.preventDefault()</code>.
    */
  ui5ProductSwitchClick!: EventEmitter<ShellBarProductSwitchClickEventDetail>;
  /**
     Fired, when the logo is activated.
    */
  ui5LogoClick!: EventEmitter<ShellBarLogoClickEventDetail>;
  /**
     Fired, when the co pilot is activated.
    */
  ui5CoPilotClick!: EventEmitter<ShellBarCoPilotClickEventDetail>;
  /**
     Fired, when a menu item is activated
<b>Note:</b> You can prevent closing of overflow popover by calling <code>event.preventDefault()</code>.
    */
  ui5MenuItemClick!: EventEmitter<ShellBarMenuItemClickEventDetail>;

  private elementRef: ElementRef<ShellBar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ShellBar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: ShellBar['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: ShellBar['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: ShellBar['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: ShellBar['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: ShellBar['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: ShellBar['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: ShellBar['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: ShellBar['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: ShellBar['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: ShellBar['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: ShellBar['focus'];

  /**
     
    */
  fireEvent!: ShellBar['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: ShellBar['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: ShellBar['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: ShellBar['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: ShellBar['getStaticAreaItemDomRef'];

  /**
     Closes the overflow area.
Useful to manually close the overflow after having suppressed automatic closing with preventDefault() of ShellbarItem's press event
    */
  closeOverflow!: ShellBar['closeOverflow'];
}
export { ShellBarComponent };
"
`;

exports[`Snapshot test Fiori Side Navigation Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/SideNavigationItem.js';
import SideNavigationItem from '@ui5/webcomponents-fiori/dist/SideNavigationItem.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'text',
  'icon',
  'selected',
  'href',
  'target',
  'disabled',
  'expanded',
  'wholeItemToggleable',
])
@ProxyOutputs(['click: ui5Click'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-side-navigation-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'text',
    'icon',
    'selected',
    'href',
    'target',
    'disabled',
    'expanded',
    'wholeItemToggleable',
  ],
  outputs: ['ui5Click'],
})
class SideNavigationItemComponent {
  /**
     Defines the text of the item.
    */
  text!: string;

  /**
     Defines the icon of the item.
<br><br>

The SAP-icons font provides numerous options.
<br>
See all the available icons in the <ui5-link target=\\"_blank\\" href=\\"https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html\\">Icon Explorer</ui5-link>.
    */
  icon!: string;

  /**
     Defines whether the item is selected
    */
  selected!: boolean;

  /**
     Defines the link target URI. Supports standard hyperlink behavior.
If a JavaScript action should be triggered,
this should not be set, but instead an event handler
for the <code>click</code> event should be registered.
    */
  href!: string;

  /**
     Defines the component target.
<br><br>
<b>Notes:</b>

<ul>
<li><code>_self</code></li>
<li><code>_top</code></li>
<li><code>_blank</code></li>
<li><code>_parent</code></li>
<li><code>_search</code></li>
</ul>

<b>This property must only be used when the <code>href</code> property is set.</b>
    */
  target!: string;

  /**
     Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Defines if the item is expanded
    */
  expanded!: boolean;

  /**
     Defines whether clicking the whole item or only pressing the icon will show/hide the sub items (if present).
If set to true, clicking the whole item will toggle the sub items, and it won't fire the <code>click</code> event.
By default, only clicking the arrow icon will toggle the sub items.
    */
  wholeItemToggleable!: boolean;

  /**
     Fired when the component is activated either with a
click/tap or by using the Enter or Space key.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<SideNavigationItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SideNavigationItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: SideNavigationItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: SideNavigationItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: SideNavigationItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: SideNavigationItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: SideNavigationItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: SideNavigationItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: SideNavigationItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: SideNavigationItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: SideNavigationItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: SideNavigationItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: SideNavigationItem['focus'];

  /**
     
    */
  fireEvent!: SideNavigationItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: SideNavigationItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: SideNavigationItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: SideNavigationItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: SideNavigationItem['getStaticAreaItemDomRef'];
}
export { SideNavigationItemComponent };
"
`;

exports[`Snapshot test Fiori Side Navigation Sub Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/SideNavigationSubItem.js';
import SideNavigationSubItem from '@ui5/webcomponents-fiori/dist/SideNavigationSubItem.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['text', 'icon', 'selected', 'href', 'target', 'disabled'])
@ProxyOutputs(['click: ui5Click'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-side-navigation-sub-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'icon', 'selected', 'href', 'target', 'disabled'],
  outputs: ['ui5Click'],
})
class SideNavigationSubItemComponent {
  /**
     Defines the text of the item.
    */
  text!: string;

  /**
     Defines the icon of the item.
<br><br>

The SAP-icons font provides numerous options.
<br>
See all the available icons in the <ui5-link target=\\"_blank\\" href=\\"https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html\\">Icon Explorer</ui5-link>.
    */
  icon!: string;

  /**
     Defines whether the item is selected
    */
  selected!: boolean;

  /**
     Defines the link target URI. Supports standard hyperlink behavior.
If a JavaScript action should be triggered,
this should not be set, but instead an event handler
for the <code>click</code> event should be registered.
    */
  href!: string;

  /**
     Defines the component target.
<br><br>
<b>Notes:</b>

<ul>
<li><code>_self</code></li>
<li><code>_top</code></li>
<li><code>_blank</code></li>
<li><code>_parent</code></li>
<li><code>_search</code></li>
</ul>

<b>This property must only be used when the <code>href</code> property is set.</b>
    */
  target!: string;

  /**
     Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Fired when the component is activated either with a
click/tap or by using the Enter or Space key.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<SideNavigationSubItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SideNavigationSubItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: SideNavigationSubItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: SideNavigationSubItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: SideNavigationSubItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: SideNavigationSubItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: SideNavigationSubItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: SideNavigationSubItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: SideNavigationSubItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: SideNavigationSubItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: SideNavigationSubItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: SideNavigationSubItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: SideNavigationSubItem['focus'];

  /**
     
    */
  fireEvent!: SideNavigationSubItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: SideNavigationSubItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: SideNavigationSubItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: SideNavigationSubItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: SideNavigationSubItem['getStaticAreaItemDomRef'];
}
export { SideNavigationSubItemComponent };
"
`;

exports[`Snapshot test Fiori Side Navigation should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/SideNavigation.js';
import {
  default as SideNavigation,
  SideNavigationSelectionChangeEventDetail,
} from '@ui5/webcomponents-fiori/dist/SideNavigation.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['collapsed'])
@ProxyOutputs(['selection-change: ui5SelectionChange'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-side-navigation',
  template: '<ng-content></ng-content>',
  inputs: ['collapsed'],
  outputs: ['ui5SelectionChange'],
})
class SideNavigationComponent {
  /**
     Defines whether the <code>ui5-side-navigation</code> is expanded or collapsed.
    */
  collapsed!: boolean;

  /**
     Fired when the selection has changed via user interaction
    */
  ui5SelectionChange!: EventEmitter<SideNavigationSelectionChangeEventDetail>;

  private elementRef: ElementRef<SideNavigation> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SideNavigation {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: SideNavigation['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: SideNavigation['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: SideNavigation['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: SideNavigation['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: SideNavigation['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: SideNavigation['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: SideNavigation['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: SideNavigation['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: SideNavigation['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: SideNavigation['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: SideNavigation['focus'];

  /**
     
    */
  fireEvent!: SideNavigation['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: SideNavigation['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: SideNavigation['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: SideNavigation['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: SideNavigation['getStaticAreaItemDomRef'];
}
export { SideNavigationComponent };
"
`;

exports[`Snapshot test Fiori Sort Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/SortItem.js';
import SortItem from '@ui5/webcomponents-fiori/dist/SortItem.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['text', 'selected'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-sort-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'selected'],
})
class SortItemComponent {
  /**
     Defines the text of the component.
    */
  text!: string;

  /**
     Defines if the component is selected.
    */
  selected!: boolean;

  private elementRef: ElementRef<SortItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SortItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: SortItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: SortItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: SortItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: SortItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: SortItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: SortItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: SortItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: SortItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: SortItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: SortItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: SortItem['focus'];

  /**
     
    */
  fireEvent!: SortItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: SortItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: SortItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: SortItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: SortItem['getStaticAreaItemDomRef'];
}
export { SortItemComponent };
"
`;

exports[`Snapshot test Fiori Theming should match the snapshot 1`] = `
"import { Injectable } from '@angular/core';
import { WebcomponentsThemingProvider } from '@ui5/webcomponents-ngx/theming';

@Injectable({ providedIn: 'root' })
class Ui5WebcomponentsFioriThemingService extends WebcomponentsThemingProvider {
  name = 'ui-5-webcomponents-fiori-theming-service';
  constructor() {
    super(
      () =>
        import(
          '@ui5/webcomponents-fiori/dist/generated/json-imports/Themes.js'
        ),
    );
  }
}

export { Ui5WebcomponentsFioriThemingService };
"
`;

exports[`Snapshot test Fiori Timeline Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/TimelineItem.js';
import TimelineItem from '@ui5/webcomponents-fiori/dist/TimelineItem.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['icon', 'name', 'nameClickable', 'titleText', 'subtitleText'])
@ProxyOutputs(['name-click: ui5NameClick'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-timeline-item',
  template: '<ng-content></ng-content>',
  inputs: ['icon', 'name', 'nameClickable', 'titleText', 'subtitleText'],
  outputs: ['ui5NameClick'],
})
class TimelineItemComponent {
  /**
     Defines the icon to be displayed as graphical element within the <code>ui5-timeline-item</code>.
SAP-icons font provides numerous options.
<br><br>

See all the available icons in the <ui5-link target=\\"_blank\\" href=\\"https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html\\">Icon Explorer</ui5-link>.
    */
  icon!: string;

  /**
     Defines the name of the item, displayed before the <code>title-text</code>.
    */
  name!: string;

  /**
     Defines if the <code>name</code> is clickable.
    */
  nameClickable!: boolean;

  /**
     Defines the title text of the component.
    */
  titleText!: string;

  /**
     Defines the subtitle text of the component.
    */
  subtitleText!: string;

  /**
     Fired when the item name is pressed either with a
click/tap or by using the Enter or Space key.
<br><br>
<b>Note:</b> The event will not be fired if the <code>name-clickable</code>
attribute is not set.
    */
  ui5NameClick!: EventEmitter<void>;

  private elementRef: ElementRef<TimelineItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TimelineItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: TimelineItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: TimelineItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: TimelineItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: TimelineItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: TimelineItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: TimelineItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: TimelineItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: TimelineItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: TimelineItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: TimelineItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: TimelineItem['focus'];

  /**
     
    */
  fireEvent!: TimelineItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: TimelineItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: TimelineItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: TimelineItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: TimelineItem['getStaticAreaItemDomRef'];
}
export { TimelineItemComponent };
"
`;

exports[`Snapshot test Fiori Timeline should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/Timeline.js';
import Timeline from '@ui5/webcomponents-fiori/dist/Timeline.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['layout', 'accessibleName'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-timeline',
  template: '<ng-content></ng-content>',
  inputs: ['layout', 'accessibleName'],
})
class TimelineComponent {
  /**
     Defines the items orientation.

<br><br>
<b>Note:</b>
Available options are:
<ul>
<li><code>Vertical</code></li>
<li><code>Horizontal</code></li>
</ul>
    */
  layout!: 'Vertical' | 'Horizontal';

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  private elementRef: ElementRef<Timeline> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Timeline {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: Timeline['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: Timeline['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: Timeline['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: Timeline['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: Timeline['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: Timeline['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: Timeline['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: Timeline['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: Timeline['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: Timeline['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: Timeline['focus'];

  /**
     
    */
  fireEvent!: Timeline['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: Timeline['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: Timeline['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: Timeline['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: Timeline['getStaticAreaItemDomRef'];
}
export { TimelineComponent };
"
`;

exports[`Snapshot test Fiori Ui 5 Fiori Module Ts should match the snapshot 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { Ui5WebcomponentsFioriThemingService } from \\"@ui5/webcomponents-ngx/fiori/theming\\";
import \\"@ui5/webcomponents-fiori/dist/Assets.js\\";
import { BarComponent } from \\"@ui5/webcomponents-ngx/fiori/bar\\";
import { BarcodeScannerDialogComponent } from \\"@ui5/webcomponents-ngx/fiori/barcode-scanner-dialog\\";
import { DynamicSideContentComponent } from \\"@ui5/webcomponents-ngx/fiori/dynamic-side-content\\";
import { FilterItemComponent } from \\"@ui5/webcomponents-ngx/fiori/filter-item\\";
import { FilterItemOptionComponent } from \\"@ui5/webcomponents-ngx/fiori/filter-item-option\\";
import { FlexibleColumnLayoutComponent } from \\"@ui5/webcomponents-ngx/fiori/flexible-column-layout\\";
import { IllustratedMessageComponent } from \\"@ui5/webcomponents-ngx/fiori/illustrated-message\\";
import { MediaGalleryComponent } from \\"@ui5/webcomponents-ngx/fiori/media-gallery\\";
import { MediaGalleryItemComponent } from \\"@ui5/webcomponents-ngx/fiori/media-gallery-item\\";
import { NotificationActionComponent } from \\"@ui5/webcomponents-ngx/fiori/notification-action\\";
import { NotificationListGroupItemComponent } from \\"@ui5/webcomponents-ngx/fiori/notification-list-group-item\\";
import { NotificationListItemComponent } from \\"@ui5/webcomponents-ngx/fiori/notification-list-item\\";
import { PageComponent } from \\"@ui5/webcomponents-ngx/fiori/page\\";
import { ProductSwitchComponent } from \\"@ui5/webcomponents-ngx/fiori/product-switch\\";
import { ProductSwitchItemComponent } from \\"@ui5/webcomponents-ngx/fiori/product-switch-item\\";
import { ShellBarComponent } from \\"@ui5/webcomponents-ngx/fiori/shell-bar\\";
import { ShellBarItemComponent } from \\"@ui5/webcomponents-ngx/fiori/shell-bar-item\\";
import { SideNavigationComponent } from \\"@ui5/webcomponents-ngx/fiori/side-navigation\\";
import { SideNavigationItemComponent } from \\"@ui5/webcomponents-ngx/fiori/side-navigation-item\\";
import { SideNavigationSubItemComponent } from \\"@ui5/webcomponents-ngx/fiori/side-navigation-sub-item\\";
import { SortItemComponent } from \\"@ui5/webcomponents-ngx/fiori/sort-item\\";
import { TimelineComponent } from \\"@ui5/webcomponents-ngx/fiori/timeline\\";
import { TimelineItemComponent } from \\"@ui5/webcomponents-ngx/fiori/timeline-item\\";
import { UploadCollectionComponent } from \\"@ui5/webcomponents-ngx/fiori/upload-collection\\";
import { UploadCollectionItemComponent } from \\"@ui5/webcomponents-ngx/fiori/upload-collection-item\\";
import { ViewSettingsDialogComponent } from \\"@ui5/webcomponents-ngx/fiori/view-settings-dialog\\";
import { WizardComponent } from \\"@ui5/webcomponents-ngx/fiori/wizard\\";
import { WizardStepComponent } from \\"@ui5/webcomponents-ngx/fiori/wizard-step\\";

const imports = [
  BarComponent,
  BarcodeScannerDialogComponent,
  DynamicSideContentComponent,
  FilterItemComponent,
  FilterItemOptionComponent,
  FlexibleColumnLayoutComponent,
  IllustratedMessageComponent,
  MediaGalleryComponent,
  MediaGalleryItemComponent,
  NotificationActionComponent,
  NotificationListGroupItemComponent,
  NotificationListItemComponent,
  PageComponent,
  ProductSwitchComponent,
  ProductSwitchItemComponent,
  ShellBarComponent,
  ShellBarItemComponent,
  SideNavigationComponent,
  SideNavigationItemComponent,
  SideNavigationSubItemComponent,
  SortItemComponent,
  TimelineComponent,
  TimelineItemComponent,
  UploadCollectionComponent,
  UploadCollectionItemComponent,
  ViewSettingsDialogComponent,
  WizardComponent,
  WizardStepComponent,
];
const exports = [...imports];

@NgModule({
  imports: [...imports],
  exports: [...exports],
})
class Ui5FioriModule {
  constructor(
    ui5WebcomponentsFioriThemingService: Ui5WebcomponentsFioriThemingService,
  ) {}
}
export { Ui5FioriModule };
"
`;

exports[`Snapshot test Fiori Upload Collection Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/UploadCollectionItem.js';
import UploadCollectionItem from '@ui5/webcomponents-fiori/dist/UploadCollectionItem.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
import { AccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
@ProxyInputs([
  'selected',
  'type',
  'accessibilityAttributes',
  'navigated',
  'file',
  'fileName',
  'fileNameClickable',
  'disableDeleteButton',
  'hideDeleteButton',
  'hideRetryButton',
  'hideTerminateButton',
  'progress',
  'uploadState',
])
@ProxyOutputs([
  'detail-click: ui5DetailClick',
  'file-name-click: ui5FileNameClick',
  'rename: ui5Rename',
  'terminate: ui5Terminate',
  'retry: ui5Retry',
])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-upload-collection-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'selected',
    'type',
    'accessibilityAttributes',
    'navigated',
    'file',
    'fileName',
    'fileNameClickable',
    'disableDeleteButton',
    'hideDeleteButton',
    'hideRetryButton',
    'hideTerminateButton',
    'progress',
    'uploadState',
  ],
  outputs: [
    'ui5DetailClick',
    'ui5FileNameClick',
    'ui5Rename',
    'ui5Terminate',
    'ui5Retry',
  ],
})
class UploadCollectionItemComponent {
  /**
     Defines the selected state of the <code>ListItem</code>.
    */
  selected!: boolean;

  /**
     Defines the visual indication and behavior of the list items.
Available options are <code>Active</code> (by default), <code>Inactive</code>, <code>Detail</code> and <code>Navigation</code>.
<br><br>
<b>Note:</b> When set to <code>Active</code> or <code>Navigation</code>, the item will provide visual response upon press and hover,
while with type <code>Inactive</code> and <code>Detail</code> - will not.
    */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';

  /**
     An object of strings that defines several additional accessibility attribute values
for customization depending on the use case.

 It supports the following fields:

<ul>
		<li><code>ariaSetsize</code>: Defines the number of items in the current set of listitems or treeitems when not all items in the set are present in the DOM.
		The value of each <code>aria-setsize</code> is an integer reflecting number of items in the complete set.
		<b>Note: </b> If the size of the entire set is unknown, set <code>aria-setsize=\\"-1\\"</code>.
		</li>
		<li><code>ariaPosinset</code>: Defines an element's number or position in the current set of listitems or treeitems when not all items are present in the DOM.
		The value of each <code>aria-posinset</code> is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
		</li>
</ul>
    */
  accessibilityAttributes!: AccessibilityAttributes;

  /**
     The navigated state of the list item.
If set to <code>true</code>, a navigation indicator is displayed at the end of the list item.
    */
  navigated!: boolean;

  /**
     Holds an instance of <code>File</code> associated with this item.
    */
  file!: File | null | undefined;

  /**
     The name of the file.
    */
  fileName!: string;

  /**
     If set to <code>true</code> the file name will be clickable and it will fire <code>file-name-click</code> event upon click.
    */
  fileNameClickable!: boolean;

  /**
     Disables the delete button.
    */
  disableDeleteButton!: boolean;

  /**
     By default, the delete button will always be shown, regardless of the <code>ui5-upload-collection</code>'s property <code>mode</code>.
Setting this property to <code>true</code> will hide the delete button.
    */
  hideDeleteButton!: boolean;

  /**
     Hides the retry button when <code>uploadState</code> property is <code>Error</code>.
    */
  hideRetryButton!: boolean;

  /**
     Hides the terminate button when <code>uploadState</code> property is <code>Uploading</code>.
    */
  hideTerminateButton!: boolean;

  /**
     The upload progress in percentage.
<br><br>
<b>Note:</b> Expected values are in the interval [0, 100].
    */
  progress!: number;

  /**
     If set to <code>Uploading</code> or <code>Error</code>, a progress indicator showing the <code>progress</code> is displayed.
Also if set to <code>Error</code>, a refresh button is shown. When this icon is pressed <code>retry</code> event is fired.
If set to <code>Uploading</code>, a terminate button is shown. When this icon is pressed <code>terminate</code> event is fired.
    */
  uploadState!: 'Complete' | 'Error' | 'Ready' | 'Uploading';

  /**
     Fired when the user clicks on the detail button when type is <code>Detail</code>.
    */
  ui5DetailClick!: EventEmitter<void>;
  /**
     Fired when the file name is clicked.
<br><br>
<b>Note:</b> This event is only available when <code>fileNameClickable</code> property is <code>true</code>.
    */
  ui5FileNameClick!: EventEmitter<void>;
  /**
     Fired when the <code>fileName</code> property gets changed.
<br><br>
<b>Note:</b> An edit button is displayed on each item,
when the <code>ui5-upload-collection-item</code> <code>type</code> property is set to <code>Detail</code>.
    */
  ui5Rename!: EventEmitter<void>;
  /**
     Fired when the terminate button is pressed.
<br><br>
<b>Note:</b> Terminate button is displayed when <code>uploadState</code> property is set to <code>Uploading</code>.
    */
  ui5Terminate!: EventEmitter<void>;
  /**
     Fired when the retry button is pressed.
<br><br>
<b>Note:</b> Retry button is displayed when <code>uploadState</code> property is set to <code>Error</code>.
    */
  ui5Retry!: EventEmitter<void>;

  private elementRef: ElementRef<UploadCollectionItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): UploadCollectionItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: UploadCollectionItem['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: UploadCollectionItem['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: UploadCollectionItem['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: UploadCollectionItem['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: UploadCollectionItem['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: UploadCollectionItem['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: UploadCollectionItem['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: UploadCollectionItem['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: UploadCollectionItem['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: UploadCollectionItem['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: UploadCollectionItem['focus'];

  /**
     
    */
  fireEvent!: UploadCollectionItem['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: UploadCollectionItem['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: UploadCollectionItem['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: UploadCollectionItem['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: UploadCollectionItem['getStaticAreaItemDomRef'];
}
export { UploadCollectionItemComponent };
"
`;

exports[`Snapshot test Fiori Upload Collection should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/UploadCollection.js';
import {
  default as UploadCollection,
  UploadCollectionItemDeleteEventDetail,
  UploadCollectionSelectionChangeEventDetail,
} from '@ui5/webcomponents-fiori/dist/UploadCollection.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'mode',
  'noDataDescription',
  'noDataText',
  'hideDragOverlay',
  'accessibleName',
])
@ProxyOutputs([
  'drop: ui5Drop',
  'item-delete: ui5ItemDelete',
  'selection-change: ui5SelectionChange',
])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-upload-collection',
  template: '<ng-content></ng-content>',
  inputs: [
    'mode',
    'noDataDescription',
    'noDataText',
    'hideDragOverlay',
    'accessibleName',
  ],
  outputs: ['ui5Drop', 'ui5ItemDelete', 'ui5SelectionChange'],
})
class UploadCollectionComponent {
  /**
     Defines the mode of the <code>ui5-upload-collection</code>.

<br><b>Note:</b>
Mode \\"Delete\\" has no effect. The delete button is controlled by the <code>hideDeleteButton</code> property of UploadCollectionItem
    */
  mode!:
    | 'None'
    | 'SingleSelect'
    | 'SingleSelectBegin'
    | 'SingleSelectEnd'
    | 'SingleSelectAuto'
    | 'MultiSelect'
    | 'Delete';

  /**
     Allows you to set your own text for the 'No data' description.
    */
  noDataDescription!: string;

  /**
     Allows you to set your own text for the 'No data' text.
    */
  noDataText!: string;

  /**
     By default there will be drag and drop overlay shown over the <code>ui5-upload-collection</code> when files
are dragged. If you don't intend to use drag and drop, set this property.
<br><br>
<b>Note:</b> It is up to the application developer to add handler for <code>drop</code> event and handle it.
<code>ui5-upload-collection</code> only displays an overlay.
    */
  hideDragOverlay!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Fired when an element is dropped inside the drag and drop overlay.
<br><br>
<b>Note:</b> The <code>drop</code> event is fired only when elements are dropped within the drag and drop overlay and ignored for the other parts of the <code>ui5-upload-collection</code>.
    */
  ui5Drop!: EventEmitter<Event>;
  /**
     Fired when the delete button of any item is pressed.
    */
  ui5ItemDelete!: EventEmitter<UploadCollectionItemDeleteEventDetail>;
  /**
     Fired when selection is changed by user interaction
in <code>SingleSelect</code> and <code>MultiSelect</code> modes.
    */
  ui5SelectionChange!: EventEmitter<UploadCollectionSelectionChangeEventDetail>;

  private elementRef: ElementRef<UploadCollection> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): UploadCollection {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: UploadCollection['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: UploadCollection['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: UploadCollection['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: UploadCollection['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: UploadCollection['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: UploadCollection['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: UploadCollection['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: UploadCollection['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: UploadCollection['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: UploadCollection['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: UploadCollection['focus'];

  /**
     
    */
  fireEvent!: UploadCollection['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: UploadCollection['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: UploadCollection['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: UploadCollection['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: UploadCollection['getStaticAreaItemDomRef'];
}
export { UploadCollectionComponent };
"
`;

exports[`Snapshot test Fiori View Settings Dialog should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/ViewSettingsDialog.js';
import {
  default as ViewSettingsDialog,
  ViewSettingsDialogCancelEventDetail,
  ViewSettingsDialogConfirmEventDetail,
} from '@ui5/webcomponents-fiori/dist/ViewSettingsDialog.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['sortDescending'])
@ProxyOutputs([
  'confirm: ui5Confirm',
  'cancel: ui5Cancel',
  'before-open: ui5BeforeOpen',
])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
  'show',
  'setConfirmedSettings',
])
@Component({
  standalone: true,
  selector: 'ui5-view-settings-dialog',
  template: '<ng-content></ng-content>',
  inputs: ['sortDescending'],
  outputs: ['ui5Confirm', 'ui5Cancel', 'ui5BeforeOpen'],
})
class ViewSettingsDialogComponent {
  /**
     Defines the initial sort order.
    */
  sortDescending!: boolean;

  /**
     Fired when confirmation button is activated.
    */
  ui5Confirm!: EventEmitter<ViewSettingsDialogConfirmEventDetail>;
  /**
     Fired when cancel button is activated.
    */
  ui5Cancel!: EventEmitter<ViewSettingsDialogCancelEventDetail>;
  /**
     Fired before the component is opened. <b>This event does not bubble.</b>
    */
  ui5BeforeOpen!: EventEmitter<void>;

  private elementRef: ElementRef<ViewSettingsDialog> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ViewSettingsDialog {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: ViewSettingsDialog['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: ViewSettingsDialog['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: ViewSettingsDialog['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: ViewSettingsDialog['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: ViewSettingsDialog['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: ViewSettingsDialog['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: ViewSettingsDialog['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: ViewSettingsDialog['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: ViewSettingsDialog['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: ViewSettingsDialog['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: ViewSettingsDialog['focus'];

  /**
     
    */
  fireEvent!: ViewSettingsDialog['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: ViewSettingsDialog['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: ViewSettingsDialog['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: ViewSettingsDialog['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: ViewSettingsDialog['getStaticAreaItemDomRef'];

  /**
     Shows the dialog.
    */
  show!: ViewSettingsDialog['show'];

  /**
     Sets a JavaScript object, as settings to the <code>ui5-view-settings-dialog</code>.
This method can be used after the dialog is initially open, as the dialog needs
to set its initial settings.<br>
The <code>ui5-view-settings-dialog</code> throws an event called \\"before-open\\",
which can be used as a trigger point.<br>
The object should have the following format:<br>
<pre>
{
sortOrder: \\"Ascending\\",
sortBy: \\"Name\\",
filters: [
	{\\"Filter 1\\": [\\"Some filter 1\\", \\"Some filter 2\\"]},
	{\\"Filter 2\\": [\\"Some filter 4\\"]},
]
}
</pre>
    */
  setConfirmedSettings!: ViewSettingsDialog['setConfirmedSettings'];
}
export { ViewSettingsDialogComponent };
"
`;

exports[`Snapshot test Fiori Wizard Step should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/WizardStep.js';
import WizardStep from '@ui5/webcomponents-fiori/dist/WizardStep.js';
import { ProxyInputs, ProxyMethods } from '@ui5/webcomponents-ngx/utils';
@ProxyInputs([
  'titleText',
  'subtitleText',
  'icon',
  'disabled',
  'selected',
  'branching',
])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-wizard-step',
  template: '<ng-content></ng-content>',
  inputs: [
    'titleText',
    'subtitleText',
    'icon',
    'disabled',
    'selected',
    'branching',
  ],
})
class WizardStepComponent {
  /**
     Defines the <code>titleText</code> of the step.
<br><br>

<b>Note:</b> The text is displayed in the <code>ui5-wizard</code> navigation header.
    */
  titleText!: string;

  /**
     Defines the <code>subtitleText</code> of the step.
<br><br>

<b>Note:</b> the text is displayed in the <code>ui5-wizard</code> navigation header.
    */
  subtitleText!: string;

  /**
     Defines the <code>icon</code> of the step.
<br><br>

<b>Note:</b> The icon is displayed in the <code>ui5-wizard</code> navigation header.
<br><br>

The SAP-icons font provides numerous options.
See all the available icons in the <ui5-link target=\\"_blank\\" href=\\"https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html\\">Icon Explorer</ui5-link>.
    */
  icon!: string;

  /**
     Defines if the step is <code>disabled</code>. When disabled the step is displayed,
but the user can't select the step by clicking or navigate to it with scrolling.
<br><br>

<b>Note:</b> Step can't be <code>selected</code> and <code>disabled</code> at the same time.
In this case the <code>selected</code> property would take precedence.
    */
  disabled!: boolean;

  /**
     Defines the step's <code>selected</code> state - the step that is currently active.
<br><br>

<b>Note:</b> Step can't be <code>selected</code> and <code>disabled</code> at the same time.
In this case the <code>selected</code> property would take precedence.
    */
  selected!: boolean;

  /**
     When <code>branching</code> is enabled a dashed line would be displayed after the step,
meant to indicate that the next step is not yet known and depends on user choice in the current step.
<br><br>

<b>Note:</b> It is recommended to use <code>branching</code> on the last known step
and later add new steps when it becomes clear how the wizard flow should continue.
    */
  branching!: boolean;

  private elementRef: ElementRef<WizardStep> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): WizardStep {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: WizardStep['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: WizardStep['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: WizardStep['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: WizardStep['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: WizardStep['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: WizardStep['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: WizardStep['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: WizardStep['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: WizardStep['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: WizardStep['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: WizardStep['focus'];

  /**
     
    */
  fireEvent!: WizardStep['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: WizardStep['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: WizardStep['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: WizardStep['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: WizardStep['getStaticAreaItemDomRef'];
}
export { WizardStepComponent };
"
`;

exports[`Snapshot test Fiori Wizard should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents-fiori/dist/Wizard.js';
import {
  default as Wizard,
  WizardStepChangeEventDetail,
} from '@ui5/webcomponents-fiori/dist/Wizard.js';
import {
  ProxyInputs,
  ProxyMethods,
  ProxyOutputs,
} from '@ui5/webcomponents-ngx/utils';
@ProxyInputs(['contentLayout'])
@ProxyOutputs(['step-change: ui5StepChange'])
@ProxyMethods([
  'onBeforeRendering',
  'onAfterRendering',
  'onEnterDOM',
  'onExitDOM',
  'attachInvalidate',
  'detachInvalidate',
  'onInvalidation',
  'getDomRef',
  'getFocusDomRef',
  'getFocusDomRefAsync',
  'focus',
  'fireEvent',
  'getSlottedNodes',
  'attachComponentStateFinalized',
  'detachComponentStateFinalized',
  'getStaticAreaItemDomRef',
])
@Component({
  standalone: true,
  selector: 'ui5-wizard',
  template: '<ng-content></ng-content>',
  inputs: ['contentLayout'],
  outputs: ['ui5StepChange'],
})
class WizardComponent {
  /**
     Defines how the content of the <code>ui5-wizard</code> would be visualized.
    */
  contentLayout!: 'MultipleSteps' | 'SingleStep';

  /**
     Fired when the step is changed by user interaction - either with scrolling,
or by clicking on the steps within the component header.
    */
  ui5StepChange!: EventEmitter<WizardStepChangeEventDetail>;

  private elementRef: ElementRef<Wizard> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Wizard {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }

  /**
     Called every time before the component renders.
    */
  onBeforeRendering!: Wizard['onBeforeRendering'];

  /**
     Called every time after the component renders.
    */
  onAfterRendering!: Wizard['onAfterRendering'];

  /**
     Called on connectedCallback - added to the DOM.
    */
  onEnterDOM!: Wizard['onEnterDOM'];

  /**
     Called on disconnectedCallback - removed from the DOM.
    */
  onExitDOM!: Wizard['onExitDOM'];

  /**
     Attach a callback that will be executed whenever the component is invalidated
    */
  attachInvalidate!: Wizard['attachInvalidate'];

  /**
     Detach the callback that is executed whenever the component is invalidated
    */
  detachInvalidate!: Wizard['detachInvalidate'];

  /**
     A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)
    */
  onInvalidation!: Wizard['onInvalidation'];

  /**
     Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template
*Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option
Use this method instead of \\"this.shadowRoot\\" to read the Shadow DOM, if ever necessary
    */
  getDomRef!: Wizard['getDomRef'];

  /**
     Returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRef!: Wizard['getFocusDomRef'];

  /**
     Waits for dom ref and then returns the DOM Element marked with \\"data-sap-focus-ref\\" inside the template.
This is the element that will receive the focus by default.
    */
  getFocusDomRefAsync!: Wizard['getFocusDomRefAsync'];

  /**
     Set the focus to the element, returned by \\"getFocusDomRef()\\" (marked by \\"data-sap-focus-ref\\")
    */
  focus!: Wizard['focus'];

  /**
     
    */
  fireEvent!: Wizard['fireEvent'];

  /**
     Returns the actual children, associated with a slot.
Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.
    */
  getSlottedNodes!: Wizard['getSlottedNodes'];

  /**
     Attach a callback that will be executed whenever the component's state is finalized
    */
  attachComponentStateFinalized!: Wizard['attachComponentStateFinalized'];

  /**
     Detach the callback that is executed whenever the component's state is finalized
    */
  detachComponentStateFinalized!: Wizard['detachComponentStateFinalized'];

  /**
     
    */
  getStaticAreaItemDomRef!: Wizard['getStaticAreaItemDomRef'];
}
export { WizardComponent };
"
`;
