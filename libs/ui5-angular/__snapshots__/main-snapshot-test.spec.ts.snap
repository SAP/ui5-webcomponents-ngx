// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Snapshot test Main Avatar Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/AvatarGroup.js';
import {
  default as AvatarGroup,
  AvatarGroupAccessibilityAttributes,
  AvatarGroupClickEventDetail,
} from '@ui5/webcomponents/dist/AvatarGroup.js';
@ProxyInputs(['type', 'accessibilityAttributes'])
@ProxyOutputs(['click: ui5Click', 'overflow: ui5Overflow'])
@Component({
  standalone: true,
  selector: 'ui5-avatar-group',
  template: '<ng-content></ng-content>',
  inputs: ['type', 'accessibilityAttributes'],
  outputs: ['ui5Click', 'ui5Overflow'],
})
class AvatarGroupComponent {
  /**
     Defines the mode of the \`AvatarGroup\`.
    */
  type!: 'Group' | 'Individual';

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following field is supported:

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.
    */
  accessibilityAttributes!: AvatarGroupAccessibilityAttributes;

  /**
     Fired when the component is activated either with a
click/tap or by using the Enter or Space key.
    */
  ui5Click!: EventEmitter<AvatarGroupClickEventDetail>;
  /**
     Fired when the count of visible \`ui5-avatar\` elements in the
component has changed
    */
  ui5Overflow!: EventEmitter<void>;

  private elementRef: ElementRef<AvatarGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): AvatarGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { AvatarGroupComponent };
"
`;

exports[`Snapshot test Main Avatar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Avatar.js';
import {
  default as Avatar,
  AvatarAccessibilityAttributes,
} from '@ui5/webcomponents/dist/Avatar.js';
@ProxyInputs([
  'disabled',
  'interactive',
  'icon',
  'fallbackIcon',
  'initials',
  'shape',
  'size',
  'colorScheme',
  'accessibleName',
  'accessibilityAttributes',
])
@Component({
  standalone: true,
  selector: 'ui5-avatar',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'interactive',
    'icon',
    'fallbackIcon',
    'initials',
    'shape',
    'size',
    'colorScheme',
    'accessibleName',
    'accessibilityAttributes',
  ],
})
class AvatarComponent {
  /**
     Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Defines if the avatar is interactive (focusable and pressable).

**Note:** This property won't have effect if the \`disabled\`
property is set to \`true\`.
    */
  interactive!: boolean;

  /**
     Defines the name of the UI5 Icon, that will be displayed.

**Note:** If \`image\` slot is provided, the property will be ignored.

**Note:** You should import the desired icon first, then use its name as \\"icon\\".

\`import \\"@ui5/webcomponents-icons/dist/{icon_name}.js\\"\`

\`<ui5-avatar icon=\\"employee\\">\`

**Note:** If no icon or an empty one is provided, by default the \\"employee\\" icon should be displayed.

See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines the name of the fallback icon, which should be displayed in the following cases:

	- If the initials are not valid (more than 3 letters, unsupported languages or empty initials).
	- If there are three initials and they do not fit in the shape (e.g. WWW for some of the sizes).
	- If the image src is wrong.

**Note:** If not set, a default fallback icon \\"employee\\" is displayed.

**Note:** You should import the desired icon first, then use its name as \\"fallback-icon\\".

\`import \\"@ui5/webcomponents-icons/dist/{icon_name}.js\\"\`

\`<ui5-avatar fallback-icon=\\"alert\\">\`

See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  fallbackIcon!: string;

  /**
     Defines the displayed initials.

Up to three Latin letters can be displayed as initials.
    */
  initials!: string;

  /**
     Defines the shape of the component.
    */
  shape!: 'Circle' | 'Square';

  /**
     Defines predefined size of the component.
    */
  size!: 'XS' | 'S' | 'M' | 'L' | 'XL';

  /**
     Defines the background color of the desired image.
    */
  colorScheme!:
    | 'Accent1'
    | 'Accent2'
    | 'Accent3'
    | 'Accent4'
    | 'Accent5'
    | 'Accent6'
    | 'Accent7'
    | 'Accent8'
    | 'Accent9'
    | 'Accent10'
    | 'Placeholder';

  /**
     Defines the text alternative of the component.
If not provided a default text alternative will be set, if present.
    */
  accessibleName!: string;

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following field is supported:

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.
    */
  accessibilityAttributes!: AvatarAccessibilityAttributes;

  private elementRef: ElementRef<Avatar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Avatar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { AvatarComponent };
"
`;

exports[`Snapshot test Main Bar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Bar.js';
import Bar from '@ui5/webcomponents/dist/Bar.js';
@ProxyInputs(['design'])
@Component({
  standalone: true,
  selector: 'ui5-bar',
  template: '<ng-content></ng-content>',
  inputs: ['design'],
})
class BarComponent {
  /**
     Defines the component's design.
    */
  design!: 'Header' | 'Subheader' | 'Footer' | 'FloatingFooter';

  private elementRef: ElementRef<Bar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Bar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { BarComponent };
"
`;

exports[`Snapshot test Main Breadcrumbs Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/BreadcrumbsItem.js';
import BreadcrumbsItem from '@ui5/webcomponents/dist/BreadcrumbsItem.js';
@ProxyInputs(['href', 'target', 'accessibleName'])
@Component({
  standalone: true,
  selector: 'ui5-breadcrumbs-item',
  template: '<ng-content></ng-content>',
  inputs: ['href', 'target', 'accessibleName'],
})
class BreadcrumbsItemComponent {
  /**
     Defines the link href.

**Note:** Standard hyperlink behavior is supported.
    */
  href!: string;

  /**
     Defines the link target.

Available options are:

- \`_self\`
- \`_top\`
- \`_blank\`
- \`_parent\`
- \`_search\`

**Note:** This property must only be used when the \`href\` property is set.
    */
  target!: string | undefined;

  /**
     Defines the accessible ARIA name of the item.
    */
  accessibleName!: string;

  private elementRef: ElementRef<BreadcrumbsItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): BreadcrumbsItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { BreadcrumbsItemComponent };
"
`;

exports[`Snapshot test Main Breadcrumbs should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Breadcrumbs.js';
import {
  default as Breadcrumbs,
  BreadcrumbsItemClickEventDetail,
} from '@ui5/webcomponents/dist/Breadcrumbs.js';
@ProxyInputs(['design', 'separators'])
@ProxyOutputs(['item-click: ui5ItemClick'])
@Component({
  standalone: true,
  selector: 'ui5-breadcrumbs',
  template: '<ng-content></ng-content>',
  inputs: ['design', 'separators'],
  outputs: ['ui5ItemClick'],
})
class BreadcrumbsComponent {
  /**
     Defines the visual appearance of the last BreadcrumbsItem.

The Breadcrumbs supports two visual appearances for the last BreadcrumbsItem:
- \\"Standard\\" - displaying the last item as \\"current page\\" (bold and without separator)
- \\"NoCurrentPage\\" - displaying the last item as a regular BreadcrumbsItem, followed by separator
    */
  design!: 'Standard' | 'NoCurrentPage';

  /**
     Determines the visual style of the separator between the breadcrumb items.
    */
  separators!:
    | 'Slash'
    | 'BackSlash'
    | 'DoubleBackSlash'
    | 'DoubleGreaterThan'
    | 'DoubleSlash'
    | 'GreaterThan';

  /**
     Fires when a \`BreadcrumbsItem\` is clicked.

**Note:** You can prevent browser location change by calling \`event.preventDefault()\`.
    */
  ui5ItemClick!: EventEmitter<BreadcrumbsItemClickEventDetail>;

  private elementRef: ElementRef<Breadcrumbs> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Breadcrumbs {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { BreadcrumbsComponent };
"
`;

exports[`Snapshot test Main Busy Indicator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/BusyIndicator.js';
import BusyIndicator from '@ui5/webcomponents/dist/BusyIndicator.js';
@ProxyInputs(['text', 'size', 'active', 'delay', 'textPlacement'])
@Component({
  standalone: true,
  selector: 'ui5-busy-indicator',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'size', 'active', 'delay', 'textPlacement'],
})
class BusyIndicatorComponent {
  /**
     Defines text to be displayed below the component. It can be used to inform the user of the current operation.
    */
  text!: string;

  /**
     Defines the size of the component.
    */
  size!: 'S' | 'M' | 'L';

  /**
     Defines if the busy indicator is visible on the screen. By default it is not.
    */
  active!: boolean;

  /**
     Defines the delay in milliseconds, after which the busy indicator will be visible on the screen.
    */
  delay!: number;

  /**
     Defines the placement of the text.
    */
  textPlacement!: 'Top' | 'Bottom';

  private elementRef: ElementRef<BusyIndicator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): BusyIndicator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { BusyIndicatorComponent };
"
`;

exports[`Snapshot test Main Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Button.js';
import {
  default as Button,
  ButtonAccessibilityAttributes,
} from '@ui5/webcomponents/dist/Button.js';
@ProxyInputs([
  'design',
  'disabled',
  'icon',
  'endIcon',
  'submits',
  'tooltip',
  'accessibleName',
  'accessibleNameRef',
  'accessibilityAttributes',
  'type',
  'accessibleRole',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'design',
    'disabled',
    'icon',
    'endIcon',
    'submits',
    'tooltip',
    'accessibleName',
    'accessibleNameRef',
    'accessibilityAttributes',
    'type',
    'accessibleRole',
  ],
  outputs: ['ui5Click'],
})
class ButtonComponent {
  /**
     Defines the component design.
    */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';

  /**
     Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Defines the icon, displayed as graphical element within the component.
The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines the icon, displayed as graphical element within the component after the button text.

**Note:** It is highly recommended to use \`endIcon\` property only together with \`icon\` and/or \`text\` properties.
Usage of \`endIcon\` only should be avoided.

The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  endIcon!: string;

  /**
     When set to \`true\`, the component will
automatically submit the nearest HTML form element on \`press\`.

**Note:** This property is only applicable within the context of an HTML Form element.\`
    */
  submits!: boolean;

  /**
     Defines the tooltip of the component.

**Note:** A tooltip attribute should be provided for icon-only buttons, in order to represent their exact meaning/function.
    */
  tooltip!: string;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **expanded**: Indicates whether the button, or another grouping element it controls, is currently expanded or collapsed.
Accepts the following string values: \`true\` or \`false\`

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.

- **controls**: Identifies the element (or elements) whose contents or presence are controlled by the button element.
Accepts a lowercase string value.
    */
  accessibilityAttributes!: ButtonAccessibilityAttributes;

  /**
     Defines whether the button has special form-related functionality.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  type!: 'Button' | 'Submit' | 'Reset';

  /**
     Describes the accessibility role of the button.

**Note:** Use <code>ButtonAccessibleRole.Link</code> role only with a press handler, which performs a navigation. In all other scenarios the default button semantics are recommended.
    */
  accessibleRole!: 'Button' | 'Link';

  /**
     Fired when the component is activated either with a
mouse/tap or by using the Enter or Space key.

**Note:** The event will not be fired if the \`disabled\`
property is set to \`true\`.
    */
  ui5Click!: EventEmitter<Event>;

  private elementRef: ElementRef<Button> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Button {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ButtonComponent };
"
`;

exports[`Snapshot test Main Calendar Date Range should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CalendarDateRange.js';
import CalendarDateRange from '@ui5/webcomponents/dist/CalendarDateRange.js';
@ProxyInputs(['startValue', 'endValue'])
@Component({
  standalone: true,
  selector: 'ui5-date-range',
  template: '<ng-content></ng-content>',
  inputs: ['startValue', 'endValue'],
})
class CalendarDateRangeComponent {
  /**
     Start of date range formatted according to the \`formatPattern\` property
of the \`ui5-calendar\` that hosts the component.
    */
  startValue!: string;

  /**
     End of date range formatted according to the \`formatPattern\` property
of the \`ui5-calendar\` that hosts the component.
    */
  endValue!: string;

  private elementRef: ElementRef<CalendarDateRange> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CalendarDateRange {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarDateRangeComponent };
"
`;

exports[`Snapshot test Main Calendar Date should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CalendarDate.js';
import CalendarDate from '@ui5/webcomponents/dist/CalendarDate.js';
@ProxyInputs(['value'])
@Component({
  standalone: true,
  selector: 'ui5-date',
  template: '<ng-content></ng-content>',
  inputs: ['value'],
})
class CalendarDateComponent {
  /**
     The date formatted according to the \`formatPattern\` property
of the \`ui5-calendar\` that hosts the component.
    */
  value!: string;

  private elementRef: ElementRef<CalendarDate> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CalendarDate {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarDateComponent };
"
`;

exports[`Snapshot test Main Calendar Legend Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CalendarLegendItem.js';
import CalendarLegendItem from '@ui5/webcomponents/dist/CalendarLegendItem.js';
@ProxyInputs(['text', 'type'])
@Component({
  standalone: true,
  selector: 'ui5-calendar-legend-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'type'],
})
class CalendarLegendItemComponent {
  /**
     Defines the text content of the Calendar Legend Item.
    */
  text!: string;

  /**
     Defines the type of the Calendar Legend Item.
    */
  type!:
    | 'None'
    | 'Working'
    | 'NonWorking'
    | 'Type01'
    | 'Type02'
    | 'Type03'
    | 'Type04'
    | 'Type05'
    | 'Type06'
    | 'Type07'
    | 'Type08'
    | 'Type09'
    | 'Type10'
    | 'Type11'
    | 'Type12'
    | 'Type13'
    | 'Type14'
    | 'Type15'
    | 'Type16'
    | 'Type17'
    | 'Type18'
    | 'Type19'
    | 'Type20';

  private elementRef: ElementRef<CalendarLegendItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CalendarLegendItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarLegendItemComponent };
"
`;

exports[`Snapshot test Main Calendar Legend should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CalendarLegend.js';
import CalendarLegend from '@ui5/webcomponents/dist/CalendarLegend.js';
@ProxyInputs([
  'hideToday',
  'hideSelectedDay',
  'hideNonWorkingDay',
  'hideWorkingDay',
])
@Component({
  standalone: true,
  selector: 'ui5-calendar-legend',
  template: '<ng-content></ng-content>',
  inputs: [
    'hideToday',
    'hideSelectedDay',
    'hideNonWorkingDay',
    'hideWorkingDay',
  ],
})
class CalendarLegendComponent {
  /**
     Hides the Today item in the legend.
    */
  hideToday!: boolean;

  /**
     Hides the Selected day item in the legend.
    */
  hideSelectedDay!: boolean;

  /**
     Hides the Non-Working day item in the legend.
    */
  hideNonWorkingDay!: boolean;

  /**
     Hides the Working day item in the legend.
    */
  hideWorkingDay!: boolean;

  private elementRef: ElementRef<CalendarLegend> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CalendarLegend {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarLegendComponent };
"
`;

exports[`Snapshot test Main Calendar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Calendar.js';
import {
  default as Calendar,
  CalendarSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/Calendar.js';
@ProxyInputs([
  'primaryCalendarType',
  'secondaryCalendarType',
  'formatPattern',
  'minDate',
  'maxDate',
  'selectionMode',
  'hideWeekNumbers',
])
@ProxyOutputs(['selection-change: ui5SelectionChange'])
@Component({
  standalone: true,
  selector: 'ui5-calendar',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryCalendarType',
    'secondaryCalendarType',
    'formatPattern',
    'minDate',
    'maxDate',
    'selectionMode',
    'hideWeekNumbers',
  ],
  outputs: ['ui5SelectionChange'],
})
class CalendarComponent {
  /**
     Sets a calendar type used for display.
If not set, the calendar type of the global configuration is used.
    */
  primaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;

  /**
     Defines the secondary calendar type.
If not set, the calendar will only show the primary calendar type.
    */
  secondaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;

  /**
     Determines the format, displayed in the input field.
    */
  formatPattern!: string;

  /**
     Determines the minimum date available for selection.

**Note:** If the formatPattern property is not set, the minDate value must be provided in the ISO date format (YYYY-MM-dd).
    */
  minDate!: string;

  /**
     Determines the maximum date available for selection.

**Note:** If the formatPattern property is not set, the maxDate value must be provided in the ISO date format (YYYY-MM-dd).
    */
  maxDate!: string;

  /**
     Defines the type of selection used in the calendar component.
Accepted property values are:

- \`CalendarSelectionMode.Single\` - enables a single date selection.(default value)
- \`CalendarSelectionMode.Range\` - enables selection of a date range.
- \`CalendarSelectionMode.Multiple\` - enables selection of multiple dates.
    */
  selectionMode!: 'Single' | 'Multiple' | 'Range';

  /**
     Defines the visibility of the week numbers column.

**Note:** For calendars other than Gregorian,
the week numbers are not displayed regardless of what is set.
    */
  hideWeekNumbers!: boolean;

  /**
     Fired when the selected dates change.

**Note:** If you call \`preventDefault()\` for this event, the component will not
create instances of \`ui5-date\` for the newly selected dates. In that case you should do this manually.
    */
  ui5SelectionChange!: EventEmitter<CalendarSelectionChangeEventDetail>;

  private elementRef: ElementRef<Calendar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Calendar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarComponent };
"
`;

exports[`Snapshot test Main Card Header should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CardHeader.js';
import CardHeader from '@ui5/webcomponents/dist/CardHeader.js';
@ProxyInputs(['titleText', 'subtitleText', 'additionalText', 'interactive'])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-card-header',
  template: '<ng-content></ng-content>',
  inputs: ['titleText', 'subtitleText', 'additionalText', 'interactive'],
  outputs: ['ui5Click'],
})
class CardHeaderComponent {
  /**
     Defines the title text.
    */
  titleText!: string;

  /**
     Defines the subtitle text.
    */
  subtitleText!: string;

  /**
     Defines the additional text.
    */
  additionalText!: string;

  /**
     Defines if the component would be interactive,
e.g gets hover effect, gets focus outline and \`click\` event is fired, when pressed.
    */
  interactive!: boolean;

  /**
     Fired when the component is activated by mouse/tap or by using the Enter or Space key.

**Note:** The event would be fired only if the \`interactive\` property is set to true.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<CardHeader> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CardHeader {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CardHeaderComponent };
"
`;

exports[`Snapshot test Main Card should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Card.js';
import Card from '@ui5/webcomponents/dist/Card.js';
@ProxyInputs(['accessibleName', 'accessibleNameRef'])
@Component({
  standalone: true,
  selector: 'ui5-card',
  template: '<ng-content></ng-content>',
  inputs: ['accessibleName', 'accessibleNameRef'],
})
class CardComponent {
  /**
     Defines the accessible name of the component, which is used as the name of the card region and should be unique per card.

**Note:** \`accessibleName\` should be always set, unless \`accessibleNameRef\` is set.
    */
  accessibleName!: string;

  /**
     Defines the IDs of the elements that label the component.
    */
  accessibleNameRef!: string;

  private elementRef: ElementRef<Card> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Card {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CardComponent };
"
`;

exports[`Snapshot test Main Carousel should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Carousel.js';
import {
  default as Carousel,
  CarouselNavigateEventDetail,
} from '@ui5/webcomponents/dist/Carousel.js';
@ProxyInputs([
  'accessibleName',
  'accessibleNameRef',
  'cyclic',
  'itemsPerPage',
  'hideNavigationArrows',
  'hidePageIndicator',
  'pageIndicatorType',
  'backgroundDesign',
  'pageIndicatorBackgroundDesign',
  'pageIndicatorBorderDesign',
  'arrowsPlacement',
])
@ProxyOutputs(['navigate: ui5Navigate'])
@Component({
  standalone: true,
  selector: 'ui5-carousel',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleName',
    'accessibleNameRef',
    'cyclic',
    'itemsPerPage',
    'hideNavigationArrows',
    'hidePageIndicator',
    'pageIndicatorType',
    'backgroundDesign',
    'pageIndicatorBackgroundDesign',
    'pageIndicatorBorderDesign',
    'arrowsPlacement',
  ],
  outputs: ['ui5Navigate'],
})
class CarouselComponent {
  /**
     Defines the accessible name of the component.
    */
  accessibleName!: string;

  /**
     Defines the IDs of the elements that label the input.
    */
  accessibleNameRef!: string;

  /**
     Defines whether the carousel should loop, i.e show the first page after the last page is reached and vice versa.
    */
  cyclic!: boolean;

  /**
     Defines the number of items per page depending on the carousel width.

- 'S' for screens smaller than 600 pixels.
- 'M' for screens greater than or equal to 600 pixels and smaller than 1024 pixels.
- 'L' for screens greater than or equal to 1024 pixels and smaller than 1440 pixels.
- 'XL' for screens greater than or equal to 1440 pixels.

One item per page is shown by default.
    */
  itemsPerPage!: string;

  /**
     Defines the visibility of the navigation arrows.
If set to true the navigation arrows will be hidden.

**Note:** The navigation arrows are never displayed on touch devices.
In this case, the user can swipe to navigate through the items.
    */
  hideNavigationArrows!: boolean;

  /**
     Defines the visibility of the page indicator.
If set to true the page indicator will be hidden.
    */
  hidePageIndicator!: boolean;

  /**
     Defines the style of the page indicator.
Available options are:

- \`Default\` - The page indicator will be visualized as dots if there are fewer than 9 pages. If there are more pages, the page indicator will switch to displaying the current page and the total number of pages. (e.g. X of Y)
- \`Numeric\` - The page indicator will display the current page and the total number of pages. (e.g. X of Y)
    */
  pageIndicatorType!: 'Default' | 'Numeric';

  /**
     Defines the carousel's background design.
    */
  backgroundDesign!: 'Solid' | 'Transparent' | 'Translucent';

  /**
     Defines the page indicator background design.
    */
  pageIndicatorBackgroundDesign!: 'Solid' | 'Transparent' | 'Translucent';

  /**
     Defines the page indicator border design.
    */
  pageIndicatorBorderDesign!: 'Solid' | 'None';

  /**
     Defines the position of arrows.

Available options are:

- \`Content\` - the arrows are placed on the sides of the current page.
- \`Navigation\` - the arrows are placed on the sides of the page indicator.
    */
  arrowsPlacement!: 'Content' | 'Navigation';

  /**
     Fired whenever the page changes due to user interaction,
when the user clicks on the navigation arrows or while resizing,
based on the \`items-per-page\` property.
    */
  ui5Navigate!: EventEmitter<CarouselNavigateEventDetail>;

  private elementRef: ElementRef<Carousel> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Carousel {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CarouselComponent };
"
`;

exports[`Snapshot test Main Check Box should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CheckBox.js';
import CheckBox from '@ui5/webcomponents/dist/CheckBox.js';
@ProxyInputs([
  'accessibleNameRef',
  'accessibleName',
  'disabled',
  'readonly',
  'displayOnly',
  'required',
  'indeterminate',
  'checked',
  'text',
  'valueState',
  'wrappingType',
  'name',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-checkbox',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleNameRef',
    'accessibleName',
    'disabled',
    'readonly',
    'displayOnly',
    'required',
    'indeterminate',
    'checked',
    'text',
    'valueState',
    'wrappingType',
    'name',
  ],
  outputs: ['ui5Change'],
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange(cvaValue)' },
})
class CheckBoxComponent {
  /**
     Receives id(or many ids) of the elements that label the component
    */
  accessibleNameRef!: string;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Defines whether the component is disabled.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Determines whether the \`ui5-checkbox\` is in display only state.

When set to \`true\`, the \`ui5-checkbox\` is not interactive, not editable, not focusable
and not in the tab chain. This setting is used for forms in review mode.

**Note:** When the property \`disabled\` is set to \`true\` this property has no effect.
    */
  displayOnly!: boolean;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Defines whether the component is displayed as partially checked.

**Note:** The indeterminate state can be set only programmatically and can’t be achieved by user
interaction and the resulting visual state depends on the values of the \`indeterminate\`
and \`checked\` properties:

-  If the component is checked and indeterminate, it will be displayed as partially checked
-  If the component is checked and it is not indeterminate, it will be displayed as checked
-  If the component is not checked, it will be displayed as not checked regardless value of the indeterminate attribute
    */
  indeterminate!: boolean;

  /**
     Defines if the component is checked.

**Note:** The property can be changed with user interaction,
either by cliking/tapping on the component, or by
pressing the Enter or Space key.
    */
  checked!: boolean;

  /**
     Defines the text of the component.
    */
  text!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component text wraps when there is not enough space.

**Note:** for option \\"Normal\\" the text will wrap and the words will not be broken based on hyphenation.
    */
  wrappingType!: 'None' | 'Normal';

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Fired when the component checked state changes.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<CheckBox> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): CheckBox {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.checked = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.checked;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { CheckBoxComponent };
"
`;

exports[`Snapshot test Main Color Palette Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ColorPaletteItem.js';
import ColorPaletteItem from '@ui5/webcomponents/dist/ColorPaletteItem.js';
@ProxyInputs(['value', 'selected'])
@Component({
  standalone: true,
  selector: 'ui5-color-palette-item',
  template: '<ng-content></ng-content>',
  inputs: ['value', 'selected'],
})
class ColorPaletteItemComponent {
  /**
     Defines the colour of the component.

**Note:** The value should be a valid CSS color.
    */
  value!: string | undefined;

  /**
     Defines if the component is selected.

**Note:** Only one item must be selected per <code>ui5-color-palette</code>.
If more than one item is defined as selected, the last one would be considered as the selected one.
    */
  selected!: boolean;

  private elementRef: ElementRef<ColorPaletteItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ColorPaletteItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ColorPaletteItemComponent };
"
`;

exports[`Snapshot test Main Color Palette Popover should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ColorPalettePopover.js';
import {
  default as ColorPalettePopover,
  ColorPalettePopoverItemClickEventDetail,
} from '@ui5/webcomponents/dist/ColorPalettePopover.js';
@ProxyInputs([
  'showRecentColors',
  'showMoreColors',
  'showDefaultColor',
  'defaultColor',
  'open',
  'opener',
])
@ProxyOutputs(['item-click: ui5ItemClick', 'close: ui5Close'])
@Component({
  standalone: true,
  selector: 'ui5-color-palette-popover',
  template: '<ng-content></ng-content>',
  inputs: [
    'showRecentColors',
    'showMoreColors',
    'showDefaultColor',
    'defaultColor',
    'open',
    'opener',
  ],
  outputs: ['ui5ItemClick', 'ui5Close'],
})
class ColorPalettePopoverComponent {
  /**
     Defines whether the user can see the last used colors in the bottom of the component
    */
  showRecentColors!: boolean;

  /**
     Defines whether the user can choose a custom color from a component.

**Note:** In order to use this property you need to import the following module: \`\\"@ui5/webcomponents/dist/features/ColorPaletteMoreColors.js\\"\`
    */
  showMoreColors!: boolean;

  /**
     Defines whether the user can choose the default color from a button.
    */
  showDefaultColor!: boolean;

  /**
     Defines the default color of the component.

**Note:** The default color should be a part of the ColorPalette colors\`
    */
  defaultColor!: string | undefined;

  /**
     Defines the open | closed state of the popover.
    */
  open!: boolean;

  /**
     Defines the ID or DOM Reference of the element that the popover is shown at.
When using this attribute in a declarative way, you must only use the \`id\` (as a string) of the element at which you want to show the popover.
You can only set the \`opener\` attribute to a DOM Reference when using JavaScript.
    */
  opener!: HTMLElement | string | undefined;

  /**
     Fired when the user selects a color.
    */
  ui5ItemClick!: EventEmitter<ColorPalettePopoverItemClickEventDetail>;
  /**
     Fired when the \`ui5-color-palette-popover\` is closed due to user interaction.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<ColorPalettePopover> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ColorPalettePopover {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ColorPalettePopoverComponent };
"
`;

exports[`Snapshot test Main Color Palette should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ColorPalette.js';
import {
  default as ColorPalette,
  ColorPaletteItemClickEventDetail,
} from '@ui5/webcomponents/dist/ColorPalette.js';

@ProxyOutputs(['item-click: ui5ItemClick'])
@Component({
  standalone: true,
  selector: 'ui5-color-palette',
  template: '<ng-content></ng-content>',
  outputs: ['ui5ItemClick'],
})
class ColorPaletteComponent {
  /**
     Fired when the user selects a color.
    */
  ui5ItemClick!: EventEmitter<ColorPaletteItemClickEventDetail>;

  private elementRef: ElementRef<ColorPalette> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ColorPalette {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ColorPaletteComponent };
"
`;

exports[`Snapshot test Main Color Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ColorPicker.js';
import ColorPicker from '@ui5/webcomponents/dist/ColorPicker.js';
@ProxyInputs(['value', 'name'])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-color-picker',
  template: '<ng-content></ng-content>',
  inputs: ['value', 'name'],
  outputs: ['ui5Change'],
})
class ColorPickerComponent {
  /**
     Defines the currently selected color of the component.

**Note**: use HEX, RGB, RGBA, HSV formats or a CSS color name when modifying this property.
    */
  value!: string;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Fired when the the selected color is changed
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<ColorPicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ColorPicker {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ColorPickerComponent };
"
`;

exports[`Snapshot test Main Combo Box Item Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ComboBoxItemGroup.js';
import ComboBoxItemGroup from '@ui5/webcomponents/dist/ComboBoxItemGroup.js';
@ProxyInputs(['text'])
@Component({
  standalone: true,
  selector: 'ui5-cb-item-group',
  template: '<ng-content></ng-content>',
  inputs: ['text'],
})
class ComboBoxItemGroupComponent {
  /**
     Defines the text of the component.
    */
  text!: string;

  private elementRef: ElementRef<ComboBoxItemGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ComboBoxItemGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ComboBoxItemGroupComponent };
"
`;

exports[`Snapshot test Main Combo Box Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ComboBoxItem.js';
import ComboBoxItem from '@ui5/webcomponents/dist/ComboBoxItem.js';
@ProxyInputs(['text', 'additionalText'])
@Component({
  standalone: true,
  selector: 'ui5-cb-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'additionalText'],
})
class ComboBoxItemComponent {
  /**
     Defines the text of the component.
    */
  text!: string;

  /**
     Defines the additional text of the component.
    */
  additionalText!: string;

  private elementRef: ElementRef<ComboBoxItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ComboBoxItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ComboBoxItemComponent };
"
`;

exports[`Snapshot test Main Combo Box should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ComboBox.js';
import {
  default as ComboBox,
  ComboBoxSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/ComboBox.js';
@ProxyInputs([
  'value',
  'name',
  'noTypeahead',
  'placeholder',
  'disabled',
  'valueState',
  'readonly',
  'required',
  'loading',
  'filter',
  'showClearIcon',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'selection-change: ui5SelectionChange',
])
@Component({
  standalone: true,
  selector: 'ui5-combobox',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'name',
    'noTypeahead',
    'placeholder',
    'disabled',
    'valueState',
    'readonly',
    'required',
    'loading',
    'filter',
    'showClearIcon',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5SelectionChange'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class ComboBoxComponent {
  /**
     Defines the value of the component.
    */
  value!: string;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines whether the value will be autocompleted to match an item
    */
  noTypeahead!: boolean;

  /**
     Defines a short hint intended to aid the user with data entry when the
component has no value.
    */
  placeholder!: string;

  /**
     Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Indicates whether a loading indicator should be shown in the picker.
    */
  loading!: boolean;

  /**
     Defines the filter type of the component.
    */
  filter!: 'StartsWithPerTerm' | 'StartsWith' | 'Contains' | 'None';

  /**
     Defines whether the clear icon of the combobox will be shown.
    */
  showClearIcon!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the component
    */
  accessibleNameRef!: string;

  /**
     Fired when the input operation has finished by pressing Enter, focusout or an item is selected.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when typing in input or clear icon is pressed.

**Note:** filterValue property is updated, input is changed.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when selection is changed by user interaction
    */
  ui5SelectionChange!: EventEmitter<ComboBoxSelectionChangeEventDetail>;

  private elementRef: ElementRef<ComboBox> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): ComboBox {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { ComboBoxComponent };
"
`;

exports[`Snapshot test Main Custom List Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CustomListItem.js';
import CustomListItem from '@ui5/webcomponents/dist/CustomListItem.js';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
@ProxyInputs([
  'selected',
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'movable',
  'accessibleName',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-li-custom',
  template: '<ng-content></ng-content>',
  inputs: [
    'selected',
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'movable',
    'accessibleName',
  ],
  outputs: ['ui5DetailClick'],
})
class CustomListItemComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  /**
     Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
    */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
    */
  accessibilityAttributes!: ListItemAccessibilityAttributes;

  /**
     The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
    */
  navigated!: boolean;

  /**
     Defines the text of the tooltip that would be displayed for the list item.
    */
  tooltip!: string;

  /**
     Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
    */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the item is movable.
    */
  movable!: boolean;

  /**
     Defines the text alternative of the component.

**Note**: If not provided a default text alternative will be set, if present.
    */
  accessibleName!: string;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<CustomListItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CustomListItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CustomListItemComponent };
"
`;

exports[`Snapshot test Main Date Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/DatePicker.js';
import {
  default as DatePicker,
  DatePickerChangeEventDetail,
  DatePickerInputEventDetail,
  DatePickerValueStateChangeEventDetail,
} from '@ui5/webcomponents/dist/DatePicker.js';
@ProxyInputs([
  'primaryCalendarType',
  'secondaryCalendarType',
  'formatPattern',
  'minDate',
  'maxDate',
  'value',
  'valueState',
  'required',
  'disabled',
  'readonly',
  'placeholder',
  'name',
  'hideWeekNumbers',
  'open',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'value-state-change: ui5ValueStateChange',
])
@Component({
  standalone: true,
  selector: 'ui5-date-picker',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryCalendarType',
    'secondaryCalendarType',
    'formatPattern',
    'minDate',
    'maxDate',
    'value',
    'valueState',
    'required',
    'disabled',
    'readonly',
    'placeholder',
    'name',
    'hideWeekNumbers',
    'open',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5ValueStateChange'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class DatePickerComponent {
  /**
     Sets a calendar type used for display.
If not set, the calendar type of the global configuration is used.
    */
  primaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;

  /**
     Defines the secondary calendar type.
If not set, the calendar will only show the primary calendar type.
    */
  secondaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;

  /**
     Determines the format, displayed in the input field.
    */
  formatPattern!: string;

  /**
     Determines the minimum date available for selection.

**Note:** If the formatPattern property is not set, the minDate value must be provided in the ISO date format (YYYY-MM-dd).
    */
  minDate!: string;

  /**
     Determines the maximum date available for selection.

**Note:** If the formatPattern property is not set, the maxDate value must be provided in the ISO date format (YYYY-MM-dd).
    */
  maxDate!: string;

  /**
     Defines a formatted date value.
    */
  value!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Determines whether the component is displayed as disabled.
    */
  disabled!: boolean;

  /**
     Determines whether the component is displayed as read-only.
    */
  readonly!: boolean;

  /**
     Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
    */
  placeholder!: string | undefined;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines the visibility of the week numbers column.

**Note:** For calendars other than Gregorian,
the week numbers are not displayed regardless of what is set.
    */
  hideWeekNumbers!: boolean;

  /**
     Defines the open or closed state of the popover.
    */
  open!: boolean;

  /**
     Defines the aria-label attribute for the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<DatePickerChangeEventDetail>;
  /**
     Fired when the value of the component is changed at each key stroke.
    */
  ui5Input!: EventEmitter<DatePickerInputEventDetail>;
  /**
     Fired before the value state of the component is updated internally.
The event is preventable, meaning that if it's default action is
prevented, the component will not update the value state.
    */
  ui5ValueStateChange!: EventEmitter<DatePickerValueStateChangeEventDetail>;

  private elementRef: ElementRef<DatePicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): DatePicker {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { DatePickerComponent };
"
`;

exports[`Snapshot test Main Date Range Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import {
  DatePickerChangeEventDetail,
  DatePickerInputEventDetail,
  DatePickerValueStateChangeEventDetail,
} from '@ui5/webcomponents/dist/DatePicker.js';
import '@ui5/webcomponents/dist/DateRangePicker.js';
import DateRangePicker from '@ui5/webcomponents/dist/DateRangePicker.js';
@ProxyInputs([
  'primaryCalendarType',
  'secondaryCalendarType',
  'formatPattern',
  'minDate',
  'maxDate',
  'value',
  'valueState',
  'required',
  'disabled',
  'readonly',
  'placeholder',
  'name',
  'hideWeekNumbers',
  'open',
  'accessibleName',
  'accessibleNameRef',
  'delimiter',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'value-state-change: ui5ValueStateChange',
])
@Component({
  standalone: true,
  selector: 'ui5-daterange-picker',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryCalendarType',
    'secondaryCalendarType',
    'formatPattern',
    'minDate',
    'maxDate',
    'value',
    'valueState',
    'required',
    'disabled',
    'readonly',
    'placeholder',
    'name',
    'hideWeekNumbers',
    'open',
    'accessibleName',
    'accessibleNameRef',
    'delimiter',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5ValueStateChange'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class DateRangePickerComponent {
  /**
     Sets a calendar type used for display.
If not set, the calendar type of the global configuration is used.
    */
  primaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;

  /**
     Defines the secondary calendar type.
If not set, the calendar will only show the primary calendar type.
    */
  secondaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;

  /**
     Determines the format, displayed in the input field.
    */
  formatPattern!: string;

  /**
     Determines the minimum date available for selection.

**Note:** If the formatPattern property is not set, the minDate value must be provided in the ISO date format (YYYY-MM-dd).
    */
  minDate!: string;

  /**
     Determines the maximum date available for selection.

**Note:** If the formatPattern property is not set, the maxDate value must be provided in the ISO date format (YYYY-MM-dd).
    */
  maxDate!: string;

  /**
     Defines a formatted date value.
    */
  value!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Determines whether the component is displayed as disabled.
    */
  disabled!: boolean;

  /**
     Determines whether the component is displayed as read-only.
    */
  readonly!: boolean;

  /**
     Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
    */
  placeholder!: string | undefined;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines the visibility of the week numbers column.

**Note:** For calendars other than Gregorian,
the week numbers are not displayed regardless of what is set.
    */
  hideWeekNumbers!: boolean;

  /**
     Defines the open or closed state of the popover.
    */
  open!: boolean;

  /**
     Defines the aria-label attribute for the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Determines the symbol which separates the dates.
If not supplied, the default time interval delimiter for the current locale will be used.
    */
  delimiter!: string;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<DatePickerChangeEventDetail>;
  /**
     Fired when the value of the component is changed at each key stroke.
    */
  ui5Input!: EventEmitter<DatePickerInputEventDetail>;
  /**
     Fired before the value state of the component is updated internally.
The event is preventable, meaning that if it's default action is
prevented, the component will not update the value state.
    */
  ui5ValueStateChange!: EventEmitter<DatePickerValueStateChangeEventDetail>;

  private elementRef: ElementRef<DateRangePicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): DateRangePicker {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { DateRangePickerComponent };
"
`;

exports[`Snapshot test Main Date Time Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import {
  DatePickerChangeEventDetail,
  DatePickerInputEventDetail,
  DatePickerValueStateChangeEventDetail,
} from '@ui5/webcomponents/dist/DatePicker.js';
import '@ui5/webcomponents/dist/DateTimePicker.js';
import DateTimePicker from '@ui5/webcomponents/dist/DateTimePicker.js';
@ProxyInputs([
  'primaryCalendarType',
  'secondaryCalendarType',
  'formatPattern',
  'minDate',
  'maxDate',
  'value',
  'valueState',
  'required',
  'disabled',
  'readonly',
  'placeholder',
  'name',
  'hideWeekNumbers',
  'open',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'value-state-change: ui5ValueStateChange',
])
@Component({
  standalone: true,
  selector: 'ui5-datetime-picker',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryCalendarType',
    'secondaryCalendarType',
    'formatPattern',
    'minDate',
    'maxDate',
    'value',
    'valueState',
    'required',
    'disabled',
    'readonly',
    'placeholder',
    'name',
    'hideWeekNumbers',
    'open',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5ValueStateChange'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class DateTimePickerComponent {
  /**
     Sets a calendar type used for display.
If not set, the calendar type of the global configuration is used.
    */
  primaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;

  /**
     Defines the secondary calendar type.
If not set, the calendar will only show the primary calendar type.
    */
  secondaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;

  /**
     Determines the format, displayed in the input field.
    */
  formatPattern!: string;

  /**
     Determines the minimum date available for selection.

**Note:** If the formatPattern property is not set, the minDate value must be provided in the ISO date format (YYYY-MM-dd).
    */
  minDate!: string;

  /**
     Determines the maximum date available for selection.

**Note:** If the formatPattern property is not set, the maxDate value must be provided in the ISO date format (YYYY-MM-dd).
    */
  maxDate!: string;

  /**
     Defines a formatted date value.
    */
  value!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Determines whether the component is displayed as disabled.
    */
  disabled!: boolean;

  /**
     Determines whether the component is displayed as read-only.
    */
  readonly!: boolean;

  /**
     Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
    */
  placeholder!: string | undefined;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines the visibility of the week numbers column.

**Note:** For calendars other than Gregorian,
the week numbers are not displayed regardless of what is set.
    */
  hideWeekNumbers!: boolean;

  /**
     Defines the open or closed state of the popover.
    */
  open!: boolean;

  /**
     Defines the aria-label attribute for the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<DatePickerChangeEventDetail>;
  /**
     Fired when the value of the component is changed at each key stroke.
    */
  ui5Input!: EventEmitter<DatePickerInputEventDetail>;
  /**
     Fired before the value state of the component is updated internally.
The event is preventable, meaning that if it's default action is
prevented, the component will not update the value state.
    */
  ui5ValueStateChange!: EventEmitter<DatePickerValueStateChangeEventDetail>;

  private elementRef: ElementRef<DateTimePicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): DateTimePicker {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { DateTimePickerComponent };
"
`;

exports[`Snapshot test Main Dialog should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Dialog.js';
import Dialog from '@ui5/webcomponents/dist/Dialog.js';
import { PopupBeforeCloseEventDetail } from '@ui5/webcomponents/dist/Popup.js';
@ProxyInputs([
  'initialFocus',
  'preventFocusRestore',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
  'preventInitialFocus',
  'open',
  'headerText',
  'stretch',
  'draggable',
  'resizable',
  'state',
])
@ProxyOutputs([
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-dialog',
  template: '<ng-content></ng-content>',
  inputs: [
    'initialFocus',
    'preventFocusRestore',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
    'preventInitialFocus',
    'open',
    'headerText',
    'stretch',
    'draggable',
    'resizable',
    'state',
  ],
  outputs: ['ui5BeforeOpen', 'ui5Open', 'ui5BeforeClose', 'ui5Close'],
})
class DialogComponent {
  /**
     Defines the ID of the HTML Element, which will get the initial focus.

**Note:** If an element with \`autofocus\` attribute is added inside the component,
\`initialFocus\` won't take effect.
    */
  initialFocus!: string;

  /**
     Defines if the focus should be returned to the previously focused element,
when the popup closes.
    */
  preventFocusRestore!: boolean;

  /**
     Defines the accessible name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Defines the IDs of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Allows setting a custom role.
    */
  accessibleRole!: 'None' | 'Dialog' | 'AlertDialog';

  /**
     Indicates whether initial focus should be prevented.
    */
  preventInitialFocus!: boolean;

  /**
     Indicates if the element is open
    */
  open!: boolean;

  /**
     Defines the header text.

**Note:** If \`header\` slot is provided, the \`headerText\` is ignored.
    */
  headerText!: string;

  /**
     Determines whether the component should be stretched to fullscreen.

**Note:** The component will be stretched to approximately
90% of the viewport.
    */
  stretch!: boolean;

  /**
     Determines whether the component is draggable.
If this property is set to true, the Dialog will be draggable by its header.

**Note:** The component can be draggable only in desktop mode.

**Note:** This property overrides the default HTML \\"draggable\\" attribute native behavior.
When \\"draggable\\" is set to true, the native browser \\"draggable\\"
behavior is prevented and only the Dialog custom logic (\\"draggable by its header\\") works.
    */
  draggable!: boolean;

  /**
     Configures the component to be resizable.
If this property is set to true, the Dialog will have a resize handle in its bottom right corner in LTR languages.
In RTL languages, the resize handle will be placed in the bottom left corner.

**Note:** The component can be resizable only in desktop mode.

**Note:** Upon resizing, externally defined height and width styling will be ignored.
    */
  resizable!: boolean;

  /**
     Defines the state of the \`Dialog\`.

**Note:** If \`\\"Negative\\"\` and \`\\"Critical\\"\` states is set, it will change the
accessibility role to \\"alertdialog\\", if the accessibleRole property is set to \`\\"Dialog\\"\`.
    */
  state!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Fired before the component is opened. This event can be cancelled, which will prevent the popup from opening. **This event does not bubble.**
    */
  ui5BeforeOpen!: EventEmitter<void>;
  /**
     Fired after the component is opened. **This event does not bubble.**
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the component is closed. This event can be cancelled, which will prevent the popup from closing. **This event does not bubble.**
    */
  ui5BeforeClose!: EventEmitter<PopupBeforeCloseEventDetail>;
  /**
     Fired after the component is closed. **This event does not bubble.**
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Dialog> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Dialog {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { DialogComponent };
"
`;

exports[`Snapshot test Main File Uploader should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/FileUploader.js';
import {
  default as FileUploader,
  FileUploaderChangeEventDetail,
} from '@ui5/webcomponents/dist/FileUploader.js';
@ProxyInputs([
  'accept',
  'hideInput',
  'disabled',
  'multiple',
  'name',
  'placeholder',
  'value',
  'valueState',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-file-uploader',
  template: '<ng-content></ng-content>',
  inputs: [
    'accept',
    'hideInput',
    'disabled',
    'multiple',
    'name',
    'placeholder',
    'value',
    'valueState',
  ],
  outputs: ['ui5Change'],
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange(cvaValue)' },
})
class FileUploaderComponent {
  /**
     Comma-separated list of file types that the component should accept.

**Note:** Please make sure you are adding the \`.\` in front on the file type, e.g. \`.png\` in case you want to accept png's only.
    */
  accept!: string;

  /**
     If set to \\"true\\", the input field of component will not be rendered. Only the default slot that is passed will be rendered.
    */
  hideInput!: boolean;

  /**
     Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Allows multiple files to be chosen.
    */
  multiple!: boolean;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines a short hint intended to aid the user with data entry when the component has no value.
    */
  placeholder!: string;

  /**
     Defines the name/names of the file/files to upload.
    */
  value!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Event is fired when the value of the file path has been changed.

**Note:** Keep in mind that because of the HTML input element of type file, the event is also fired in Chrome browser when the Cancel button of the uploads window is pressed.
    */
  ui5Change!: EventEmitter<FileUploaderChangeEventDetail>;

  private elementRef: ElementRef<FileUploader> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): FileUploader {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { FileUploaderComponent };
"
`;

exports[`Snapshot test Main Form Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/FormGroup.js';
import FormGroup from '@ui5/webcomponents/dist/FormGroup.js';
@ProxyInputs(['headerText', 'columnSpan'])
@Component({
  standalone: true,
  selector: 'ui5-form-group',
  template: '<ng-content></ng-content>',
  inputs: ['headerText', 'columnSpan'],
})
class FormGroupComponent {
  /**
     Defines header text of the component.
    */
  headerText!: string;

  /**
     Defines column span of the component,
e.g how many columns the group should span to.
    */
  columnSpan!: number | undefined;

  private elementRef: ElementRef<FormGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): FormGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { FormGroupComponent };
"
`;

exports[`Snapshot test Main Form Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/FormItem.js';
import FormItem from '@ui5/webcomponents/dist/FormItem.js';
@ProxyInputs(['columnSpan'])
@Component({
  standalone: true,
  selector: 'ui5-form-item',
  template: '<ng-content></ng-content>',
  inputs: ['columnSpan'],
})
class FormItemComponent {
  /**
     Defines the column span of the component,
e.g how many columns the component should span to.

**Note:** The column span should be a number between 1 and the available columns of the FormGroup (when items are placed in a group)
or the Form. The available columns can be affected by the FormGroup#columnSpan and/or the Form#layout.
A number bigger than the available columns won't take effect.
    */
  columnSpan!: number | undefined;

  private elementRef: ElementRef<FormItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): FormItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { FormItemComponent };
"
`;

exports[`Snapshot test Main Form should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Form.js';
import Form from '@ui5/webcomponents/dist/Form.js';
@ProxyInputs(['layout', 'labelSpan', 'headerText', 'itemSpacing'])
@Component({
  standalone: true,
  selector: 'ui5-form',
  template: '<ng-content></ng-content>',
  inputs: ['layout', 'labelSpan', 'headerText', 'itemSpacing'],
})
class FormComponent {
  /**
     Defines the number of columns to distribute the form content by breakpoint.

Supported values:
- \`S\` - 1 column by default (1 column is recommended)
- \`M\` - 1 column by default (up to 2 columns are recommended)
- \`L\` - 2 columns by default (up to 3 columns are recommended)
- \`XL\` - 2 columns by default (up to 6 columns  are recommended)
    */
  layout!: string;

  /**
     Defines the width proportion of the labels and fields of a FormItem by breakpoint.

By default, the labels take 4/12 (or 1/3) of the form item in M,L and XL sizes,
and 12/12 in S size, e.g in S the label is on top of its associated field.

The supported values are between 1 and 12. Greater the number, more space the label will use.

**Note:** If \\"12\\" is set, the label will be displayed on top of its assosiated field.
    */
  labelSpan!: string;

  /**
     Defines the header text of the component.

**Note:** The property gets overridden by the \`header\` slot.
    */
  headerText!: string;

  /**
     Defines the vertical spacing between form items.

**Note:** If the Form is meant to be switched between \\"non-edit\\" and \\"edit\\" modes,
we recommend using \\"Large\\" item spacing in \\"non-edit\\" mode, and \\"Normal\\" - for \\"edit\\" mode,
to avoid \\"jumping\\" effect, caused by the hight difference between texts in \\"non-edit\\" mode and the input fields in \\"edit\\" mode.
    */
  itemSpacing!: 'Normal' | 'Large';

  private elementRef: ElementRef<Form> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Form {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { FormComponent };
"
`;

exports[`Snapshot test Main Icon should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Icon.js';
import Icon from '@ui5/webcomponents/dist/Icon.js';
@ProxyInputs(['design', 'name', 'accessibleName', 'showTooltip', 'mode'])
@Component({
  standalone: true,
  selector: 'ui5-icon',
  template: '<ng-content></ng-content>',
  inputs: ['design', 'name', 'accessibleName', 'showTooltip', 'mode'],
})
class IconComponent {
  /**
     Defines the component semantic design.
    */
  design!:
    | 'Contrast'
    | 'Critical'
    | 'Default'
    | 'Information'
    | 'Negative'
    | 'Neutral'
    | 'NonInteractive'
    | 'Positive';

  /**
     Defines the unique identifier (icon name) of the component.

To browse all available icons, see the
[SAP Icons](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html),
[SAP Fiori Tools](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html#/overview/SAP-icons-TNT) and
[SAP Business Suite](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html)

Example:
\`name='add'\`, \`name='delete'\`, \`name='employee'\`.

**Note:** To use the SAP Fiori Tools icons,
you need to set the \`tnt\` prefix in front of the icon's name.

Example:
\`name='tnt/antenna'\`, \`name='tnt/actor'\`, \`name='tnt/api'\`.

**Note:** To use the SAP Business Suite icons,
you need to set the \`business-suite\` prefix in front of the icon's name.

Example:
\`name='business-suite/3d'\`, \`name='business-suite/1x2-grid-layout'\`, \`name='business-suite/4x4-grid-layout'\`.
    */
  name!: string;

  /**
     Defines the text alternative of the component.
If not provided a default text alternative will be set, if present.

**Note:** Every icon should have a text alternative in order to
calculate its accessible name.
    */
  accessibleName!: string;

  /**
     Defines whether the component should have a tooltip.

**Note:** The tooltip text should be provided via the \`accessible-name\` property.
    */
  showTooltip!: boolean;

  /**
     Defines the mode of the component.
    */
  mode!: 'Image' | 'Decorative' | 'Interactive';

  private elementRef: ElementRef<Icon> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Icon {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { IconComponent };
"
`;

exports[`Snapshot test Main Index Ts should match the snapshot 1`] = `"export { Ui5MainModule } from './ui5-main.module';"`;

exports[`Snapshot test Main Input should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Input.js';
import {
  default as Input,
  InputSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/Input.js';
@ProxyInputs([
  'disabled',
  'placeholder',
  'readonly',
  'required',
  'noTypeahead',
  'type',
  'value',
  'valueState',
  'name',
  'showSuggestions',
  'maxlength',
  'accessibleName',
  'accessibleNameRef',
  'showClearIcon',
  'open',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'selection-change: ui5SelectionChange',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-input',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'placeholder',
    'readonly',
    'required',
    'noTypeahead',
    'type',
    'value',
    'valueState',
    'name',
    'showSuggestions',
    'maxlength',
    'accessibleName',
    'accessibleNameRef',
    'showClearIcon',
    'open',
  ],
  outputs: [
    'ui5Change',
    'ui5Input',
    'ui5SelectionChange',
    'ui5Open',
    'ui5Close',
  ],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class InputComponent {
  /**
     Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines a short hint intended to aid the user with data entry when the
component has no value.
    */
  placeholder!: string;

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Defines whether the value will be autcompleted to match an item
    */
  noTypeahead!: boolean;

  /**
     Defines the HTML type of the component.

**Notes:**

- The particular effect of this property differs depending on the browser
and the current language settings, especially for type \`Number\`.
- The property is mostly intended to be used with touch devices
that use different soft keyboard layouts depending on the given input type.
    */
  type!: 'Text' | 'Email' | 'Number' | 'Password' | 'Tel' | 'URL' | 'Search';

  /**
     Defines the value of the component.

**Note:** The property is updated upon typing.
    */
  value!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines whether the component should show suggestions, if such are present.

**Note:** You need to import the \`InputSuggestions\` module
from \`\\"@ui5/webcomponents/dist/features/InputSuggestions.js\\"\` to enable this functionality.
    */
  showSuggestions!: boolean;

  /**
     Sets the maximum number of characters available in the input field.

**Note:** This property is not compatible with the ui5-input type InputType.Number. If the ui5-input type is set to Number, the maxlength value is ignored.
    */
  maxlength!: number | undefined;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the input.
    */
  accessibleNameRef!: string;

  /**
     Defines whether the clear icon of the input will be shown.
    */
  showClearIcon!: boolean;

  /**
     Defines whether the suggestions picker is open.
The picker will not open if the \`showSuggestions\` property is set to \`false\`, the input is disabled or the input is readonly.
The picker will close automatically and \`close\` event will be fired if the input is not in the viewport.
    */
  open!: boolean;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke,
and when a suggestion item has been selected.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when the user navigates to a suggestion item via the ARROW keys,
as a preview, before the final selection.
    */
  ui5SelectionChange!: EventEmitter<InputSelectionChangeEventDetail>;
  /**
     Fired when the suggestions picker is open.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired when the suggestions picker is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Input> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): Input {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { InputComponent };
"
`;

exports[`Snapshot test Main Label should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Label.js';
import Label from '@ui5/webcomponents/dist/Label.js';
@ProxyInputs(['for', 'showColon', 'required', 'wrappingType'])
@Component({
  standalone: true,
  selector: 'ui5-label',
  template: '<ng-content></ng-content>',
  inputs: ['for', 'showColon', 'required', 'wrappingType'],
})
class LabelComponent {
  /**
     Defines the labeled input by providing its ID.

**Note:** Can be used with both \`ui5-input\` and native input.
    */
  for!: string;

  /**
     Defines whether colon is added to the component text.

**Note:** Usually used in forms.
    */
  showColon!: boolean;

  /**
     Defines whether an asterisk character is added to the component text.

**Note:** Usually indicates that user input (bound with the \`for\` property) is required.
In that case the \`required\` property of
the corresponding input should also be set.
    */
  required!: boolean;

  /**
     Defines how the text of a component will be displayed when there is not enough space.

**Note:** for option \\"Normal\\" the text will wrap and the words will not be broken based on hyphenation.
    */
  wrappingType!: 'None' | 'Normal';

  private elementRef: ElementRef<Label> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Label {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { LabelComponent };
"
`;

exports[`Snapshot test Main Link should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Link.js';
import {
  default as Link,
  LinkAccessibilityAttributes,
  LinkClickEventDetail,
} from '@ui5/webcomponents/dist/Link.js';
@ProxyInputs([
  'disabled',
  'tooltip',
  'href',
  'target',
  'design',
  'wrappingType',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
  'accessibilityAttributes',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-link',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'tooltip',
    'href',
    'target',
    'design',
    'wrappingType',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
    'accessibilityAttributes',
  ],
  outputs: ['ui5Click'],
})
class LinkComponent {
  /**
     Defines whether the component is disabled.

**Note:** When disabled, the click event cannot be triggered by the user.
    */
  disabled!: boolean;

  /**
     Defines the tooltip of the component.
    */
  tooltip!: string;

  /**
     Defines the component href.

**Note:** Standard hyperlink behavior is supported.
    */
  href!: string;

  /**
     Defines the component target.

**Notes:**

- \`_self\`
- \`_top\`
- \`_blank\`
- \`_parent\`
- \`_search\`

**This property must only be used when the \`href\` property is set.**
    */
  target!: string;

  /**
     Defines the component design.

**Note:** Avaialble options are \`Default\`, \`Subtle\`, and \`Emphasized\`.
    */
  design!: 'Default' | 'Subtle' | 'Emphasized';

  /**
     Defines how the text of a component will be displayed when there is not enough space.

**Note:** By default the text will wrap. If \\"None\\" is set - the text will truncate.
    */
  wrappingType!: 'None' | 'Normal';

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the input
    */
  accessibleNameRef!: string;

  /**
     Defines the ARIA role of the component.

**Note:** Use the <code>LinkAccessibleRole.Button</code> role in cases when navigation is not expected to occur and the href property is not defined.
    */
  accessibleRole!: 'Link' | 'Button';

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **expanded**: Indicates whether the button, or another grouping element it controls, is currently expanded or collapsed.
Accepts the following string values: \`true\` or \`false\`.

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.
    */
  accessibilityAttributes!: LinkAccessibilityAttributes;

  /**
     Fired when the component is triggered either with a mouse/tap
or by using the Enter key.
    */
  ui5Click!: EventEmitter<LinkClickEventDetail>;

  private elementRef: ElementRef<Link> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Link {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { LinkComponent };
"
`;

exports[`Snapshot test Main List Item Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ListItemGroup.js';
import ListItemGroup from '@ui5/webcomponents/dist/ListItemGroup.js';
@ProxyInputs(['headerText', 'headerAccessibleName'])
@Component({
  standalone: true,
  selector: 'ui5-li-group',
  template: '<ng-content></ng-content>',
  inputs: ['headerText', 'headerAccessibleName'],
})
class ListItemGroupComponent {
  /**
     Defines the header text of the <code>ui5-li-group</code>.
    */
  headerText!: string;

  /**
     Defines the accessible name of the header.
    */
  headerAccessibleName!: string;

  private elementRef: ElementRef<ListItemGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ListItemGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ListItemGroupComponent };
"
`;

exports[`Snapshot test Main List should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/List.js';
import {
  default as List,
  ListItemClickEventDetail,
  ListItemCloseEventDetail,
  ListItemDeleteEventDetail,
  ListItemToggleEventDetail,
  ListMoveEventDetail,
  ListSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/List.js';
@ProxyInputs([
  'headerText',
  'footerText',
  'indent',
  'selectionMode',
  'noDataText',
  'separators',
  'growing',
  'growingButtonText',
  'loading',
  'loadingDelay',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
])
@ProxyOutputs([
  'item-click: ui5ItemClick',
  'item-close: ui5ItemClose',
  'item-toggle: ui5ItemToggle',
  'item-delete: ui5ItemDelete',
  'selection-change: ui5SelectionChange',
  'load-more: ui5LoadMore',
  'move-over: ui5MoveOver',
  'move: ui5Move',
])
@Component({
  standalone: true,
  selector: 'ui5-list',
  template: '<ng-content></ng-content>',
  inputs: [
    'headerText',
    'footerText',
    'indent',
    'selectionMode',
    'noDataText',
    'separators',
    'growing',
    'growingButtonText',
    'loading',
    'loadingDelay',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
  ],
  outputs: [
    'ui5ItemClick',
    'ui5ItemClose',
    'ui5ItemToggle',
    'ui5ItemDelete',
    'ui5SelectionChange',
    'ui5LoadMore',
    'ui5MoveOver',
    'ui5Move',
  ],
})
class ListComponent {
  /**
     Defines the component header text.

**Note:** If \`header\` is set this property is ignored.
    */
  headerText!: string;

  /**
     Defines the footer text.
    */
  footerText!: string;

  /**
     Determines whether the component is indented.
    */
  indent!: boolean;

  /**
     Defines the selection mode of the component.
    */
  selectionMode!:
    | 'None'
    | 'Single'
    | 'SingleStart'
    | 'SingleEnd'
    | 'SingleAuto'
    | 'Multiple'
    | 'Delete';

  /**
     Defines the text that is displayed when the component contains no items.
    */
  noDataText!: string;

  /**
     Defines the item separator style that is used.
    */
  separators!: 'All' | 'Inner' | 'None';

  /**
     Defines whether the component will have growing capability either by pressing a \`More\` button,
or via user scroll. In both cases \`load-more\` event is fired.

**Restrictions:** \`growing=\\"Scroll\\"\` is not supported for Internet Explorer,
on IE the component will fallback to \`growing=\\"Button\\"\`.
    */
  growing!: 'Button' | 'Scroll' | 'None';

  /**
     Defines the text that will be displayed inside the growing button.

**Note:** If not specified a built-in text will be displayed.

**Note:** This property takes effect if the \`growing\` property is set to the \`Button\`.
    */
  growingButtonText!: string;

  /**
     Defines if the component would display a loading indicator over the list.
    */
  loading!: boolean;

  /**
     Defines the delay in milliseconds, after which the loading indicator will show up for this component.
    */
  loadingDelay!: number;

  /**
     Defines the accessible name of the component.
    */
  accessibleName!: string;

  /**
     Defines the IDs of the elements that label the input.
    */
  accessibleNameRef!: string;

  /**
     Defines the accessible role of the component.
    */
  accessibleRole!: 'List' | 'Menu' | 'Tree' | 'ListBox';

  /**
     Fired when an item is activated, unless the item's \`type\` property
is set to \`Inactive\`.
    */
  ui5ItemClick!: EventEmitter<ListItemClickEventDetail>;
  /**
     Fired when the \`Close\` button of any item is clicked

**Note:** This event is only applicable to list items that can be closed (such as notification list items),
not to be confused with \`item-delete\`.
    */
  ui5ItemClose!: EventEmitter<ListItemCloseEventDetail>;
  /**
     Fired when the \`Toggle\` button of any item is clicked.

**Note:** This event is only applicable to list items that can be toggled (such as notification group list items).
    */
  ui5ItemToggle!: EventEmitter<ListItemToggleEventDetail>;
  /**
     Fired when the Delete button of any item is pressed.

**Note:** A Delete button is displayed on each item,
when the component \`selectionMode\` property is set to \`Delete\`.
    */
  ui5ItemDelete!: EventEmitter<ListItemDeleteEventDetail>;
  /**
     Fired when selection is changed by user interaction
in \`Single\`, \`SingleStart\`, \`SingleEnd\` and \`Multiple\` selection modes.
    */
  ui5SelectionChange!: EventEmitter<ListSelectionChangeEventDetail>;
  /**
     Fired when the user scrolls to the bottom of the list.

**Note:** The event is fired when the \`growing='Scroll'\` property is enabled.
    */
  ui5LoadMore!: EventEmitter<void>;
  /**
     Fired when a movable list item is moved over a potential drop target during a dragging operation.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5MoveOver!: EventEmitter<ListMoveEventDetail>;
  /**
     Fired when a movable list item is dropped onto a drop target.

**Note:** \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.
    */
  ui5Move!: EventEmitter<ListMoveEventDetail>;

  private elementRef: ElementRef<List> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): List {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ListComponent };
"
`;

exports[`Snapshot test Main Menu Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
import '@ui5/webcomponents/dist/MenuItem.js';
import MenuItem from '@ui5/webcomponents/dist/MenuItem.js';
@ProxyInputs([
  'selected',
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'text',
  'additionalText',
  'icon',
  'startsSection',
  'disabled',
  'loading',
  'loadingDelay',
  'accessibleName',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-menu-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'selected',
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'text',
    'additionalText',
    'icon',
    'startsSection',
    'disabled',
    'loading',
    'loadingDelay',
    'accessibleName',
  ],
  outputs: ['ui5DetailClick'],
})
class MenuItemComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  /**
     Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
    */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
    */
  accessibilityAttributes!: ListItemAccessibilityAttributes;

  /**
     The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
    */
  navigated!: boolean;

  /**
     Defines the text of the tooltip for the menu item.
    */
  tooltip!: string;

  /**
     Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
    */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines the text of the tree item.
    */
  text!: string;

  /**
     Defines the \`additionalText\`, displayed in the end of the menu item.

**Note:** The additional text will not be displayed if there are items added in \`items\` slot or there are
components added to \`endContent\` slot.

The priority of what will be displayed at the end of the menu item is as follows:
sub-menu arrow (if there are items added in \`items\` slot) -> components added in \`endContent\` -> text set to \`additionalText\`.
    */
  additionalText!: string;

  /**
     Defines the icon to be displayed as graphical element within the component.
The SAP-icons font provides numerous options.

**Example:**

See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines whether a visual separator should be rendered before the item.
    */
  startsSection!: boolean;

  /**
     Defines whether \`ui5-menu-item\` is in disabled state.

**Note:** A disabled \`ui5-menu-item\` is noninteractive.
    */
  disabled!: boolean;

  /**
     Defines the delay in milliseconds, after which the loading indicator will be displayed inside the corresponding ui5-menu popover.

**Note:** If set to \`true\` a \`ui5-busy-indicator\` component will be displayed into the related one to the current \`ui5-menu-item\` sub-menu popover.
    */
  loading!: boolean;

  /**
     Defines the delay in milliseconds, after which the loading indicator will be displayed inside the corresponding ui5-menu popover.
    */
  loadingDelay!: number;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<MenuItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MenuItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MenuItemComponent };
"
`;

exports[`Snapshot test Main Menu should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Menu.js';
import {
  default as Menu,
  MenuBeforeCloseEventDetail,
  MenuBeforeOpenEventDetail,
  MenuItemClickEventDetail,
} from '@ui5/webcomponents/dist/Menu.js';
@ProxyInputs(['headerText', 'open', 'loading', 'loadingDelay', 'opener'])
@ProxyOutputs([
  'item-click: ui5ItemClick',
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-menu',
  template: '<ng-content></ng-content>',
  inputs: ['headerText', 'open', 'loading', 'loadingDelay', 'opener'],
  outputs: [
    'ui5ItemClick',
    'ui5BeforeOpen',
    'ui5Open',
    'ui5BeforeClose',
    'ui5Close',
  ],
})
class MenuComponent {
  /**
     Defines the header text of the menu (displayed on mobile).
    */
  headerText!: string;

  /**
     Indicates if the menu is open
    */
  open!: boolean;

  /**
     Defines if a loading indicator would be displayed inside the corresponding ui5-menu popover.
    */
  loading!: boolean;

  /**
     Defines the delay in milliseconds, after which the loading indicator will be displayed inside the corresponding ui5-menu popover..
    */
  loadingDelay!: number;

  /**
     Defines the ID or DOM Reference of the element at which the menu is shown.
When using this attribute in a declarative way, you must only use the \`id\` (as a string) of the element at which you want to show the popover.
You can only set the \`opener\` attribute to a DOM Reference when using JavaScript.
    */
  opener!: HTMLElement | string;

  /**
     Fired when an item is being clicked.

**Note:** Since 1.17.0 the event is preventable, allowing the menu to remain open after an item is pressed.
    */
  ui5ItemClick!: EventEmitter<MenuItemClickEventDetail>;
  /**
     Fired before the menu is opened. This event can be cancelled, which will prevent the menu from opening. **This event does not bubble.**

**Note:** Since 1.14.0 the event is also fired before a sub-menu opens.
    */
  ui5BeforeOpen!: EventEmitter<MenuBeforeOpenEventDetail>;
  /**
     Fired after the menu is opened. **This event does not bubble.**
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the menu is closed. This event can be cancelled, which will prevent the menu from closing. **This event does not bubble.**
    */
  ui5BeforeClose!: EventEmitter<MenuBeforeCloseEventDetail>;
  /**
     Fired after the menu is closed. **This event does not bubble.**
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Menu> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Menu {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MenuComponent };
"
`;

exports[`Snapshot test Main Message Strip should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MessageStrip.js';
import MessageStrip from '@ui5/webcomponents/dist/MessageStrip.js';
@ProxyInputs(['design', 'colorScheme', 'hideIcon', 'hideCloseButton'])
@ProxyOutputs(['close: ui5Close'])
@Component({
  standalone: true,
  selector: 'ui5-message-strip',
  template: '<ng-content></ng-content>',
  inputs: ['design', 'colorScheme', 'hideIcon', 'hideCloseButton'],
  outputs: ['ui5Close'],
})
class MessageStripComponent {
  /**
     Defines the component type.
    */
  design!:
    | 'Information'
    | 'Positive'
    | 'Negative'
    | 'Critical'
    | 'ColorSet1'
    | 'ColorSet2';

  /**
     Defines the color scheme of the component.
There are 10 predefined schemes.
To use one you can set a number from \`\\"1\\"\` to \`\\"10\\"\`. The \`colorScheme\` \`\\"1\\"\` will be set by default.
    */
  colorScheme!: string;

  /**
     Defines whether the MessageStrip will show an icon in the beginning.
You can directly provide an icon with the \`icon\` slot. Otherwise, the default icon for the type will be used.

 * **Note:** If <code>MessageStripDesign.ColorSet1</code> or <code>MessageStripDesign.ColorSet2</code> value is set to the <code>design</code> property, default icon will not be presented.
    */
  hideIcon!: boolean;

  /**
     Defines whether the MessageStrip renders close button.
    */
  hideCloseButton!: boolean;

  /**
     Fired when the close button is pressed either with a
click/tap or by using the Enter or Space key.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<MessageStrip> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MessageStrip {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MessageStripComponent };
"
`;

exports[`Snapshot test Main Multi Combo Box Group Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MultiComboBoxGroupItem.js';
import MultiComboBoxGroupItem from '@ui5/webcomponents/dist/MultiComboBoxGroupItem.js';
@ProxyInputs(['text'])
@Component({
  standalone: true,
  selector: 'ui5-mcb-group-item',
  template: '<ng-content></ng-content>',
  inputs: ['text'],
})
class MultiComboBoxGroupItemComponent {
  /**
     Defines the text of the component.
    */
  text!: string;

  private elementRef: ElementRef<MultiComboBoxGroupItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MultiComboBoxGroupItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MultiComboBoxGroupItemComponent };
"
`;

exports[`Snapshot test Main Multi Combo Box Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MultiComboBoxItem.js';
import MultiComboBoxItem from '@ui5/webcomponents/dist/MultiComboBoxItem.js';
@ProxyInputs(['text', 'additionalText', 'selected'])
@Component({
  standalone: true,
  selector: 'ui5-mcb-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'additionalText', 'selected'],
})
class MultiComboBoxItemComponent {
  /**
     Defines the text of the component.
    */
  text!: string;

  /**
     Defines the additional text of the component.
    */
  additionalText!: string;

  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  private elementRef: ElementRef<MultiComboBoxItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MultiComboBoxItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MultiComboBoxItemComponent };
"
`;

exports[`Snapshot test Main Multi Combo Box should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MultiComboBox.js';
import {
  default as MultiComboBox,
  MultiComboBoxSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/MultiComboBox.js';
@ProxyInputs([
  'value',
  'name',
  'noTypeahead',
  'placeholder',
  'noValidation',
  'disabled',
  'valueState',
  'readonly',
  'required',
  'filter',
  'showClearIcon',
  'accessibleName',
  'accessibleNameRef',
  'showSelectAll',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'open-change: ui5OpenChange',
  'selection-change: ui5SelectionChange',
])
@Component({
  standalone: true,
  selector: 'ui5-multi-combobox',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'name',
    'noTypeahead',
    'placeholder',
    'noValidation',
    'disabled',
    'valueState',
    'readonly',
    'required',
    'filter',
    'showClearIcon',
    'accessibleName',
    'accessibleNameRef',
    'showSelectAll',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5OpenChange', 'ui5SelectionChange'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class MultiComboBoxComponent {
  /**
     Defines the value of the component.

**Note:** The property is updated upon typing.
    */
  value!: string;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
**Note:** When the component is used inside a form element,
the value is sent as the first element in the form data, even if it's empty.
    */
  name!: string;

  /**
     Defines whether the value will be autcompleted to match an item
    */
  noTypeahead!: boolean;

  /**
     Defines a short hint intended to aid the user with data entry when the
component has no value.
    */
  placeholder!: string;

  /**
     Defines if the user input will be prevented, if no matching item has been found
    */
  noValidation!: boolean;

  /**
     Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Defines the filter type of the component.
    */
  filter!: 'StartsWithPerTerm' | 'StartsWith' | 'Contains' | 'None';

  /**
     Defines whether the clear icon of the multi-combobox will be shown.
    */
  showClearIcon!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Determines if the select all checkbox is visible on top of suggestions.
    */
  showSelectAll!: boolean;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke or clear icon is pressed.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when the dropdown is opened or closed.
    */
  ui5OpenChange!: EventEmitter<void>;
  /**
     Fired when selection is changed by user interaction.
    */
  ui5SelectionChange!: EventEmitter<MultiComboBoxSelectionChangeEventDetail>;

  private elementRef: ElementRef<MultiComboBox> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): MultiComboBox {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { MultiComboBoxComponent };
"
`;

exports[`Snapshot test Main Multi Input should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { InputSelectionChangeEventDetail } from '@ui5/webcomponents/dist/Input.js';
import '@ui5/webcomponents/dist/MultiInput.js';
import {
  default as MultiInput,
  MultiInputTokenDeleteEventDetail,
} from '@ui5/webcomponents/dist/MultiInput.js';
@ProxyInputs([
  'disabled',
  'placeholder',
  'readonly',
  'required',
  'noTypeahead',
  'type',
  'value',
  'valueState',
  'name',
  'showSuggestions',
  'maxlength',
  'accessibleName',
  'accessibleNameRef',
  'showClearIcon',
  'open',
  'showValueHelpIcon',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'selection-change: ui5SelectionChange',
  'open: ui5Open',
  'close: ui5Close',
  'value-help-trigger: ui5ValueHelpTrigger',
  'token-delete: ui5TokenDelete',
])
@Component({
  standalone: true,
  selector: 'ui5-multi-input',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'placeholder',
    'readonly',
    'required',
    'noTypeahead',
    'type',
    'value',
    'valueState',
    'name',
    'showSuggestions',
    'maxlength',
    'accessibleName',
    'accessibleNameRef',
    'showClearIcon',
    'open',
    'showValueHelpIcon',
  ],
  outputs: [
    'ui5Change',
    'ui5Input',
    'ui5SelectionChange',
    'ui5Open',
    'ui5Close',
    'ui5ValueHelpTrigger',
    'ui5TokenDelete',
  ],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class MultiInputComponent {
  /**
     Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines a short hint intended to aid the user with data entry when the
component has no value.
    */
  placeholder!: string;

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Defines whether the value will be autcompleted to match an item
    */
  noTypeahead!: boolean;

  /**
     Defines the HTML type of the component.

**Notes:**

- The particular effect of this property differs depending on the browser
and the current language settings, especially for type \`Number\`.
- The property is mostly intended to be used with touch devices
that use different soft keyboard layouts depending on the given input type.
    */
  type!: 'Text' | 'Email' | 'Number' | 'Password' | 'Tel' | 'URL' | 'Search';

  /**
     Defines the value of the component.

**Note:** The property is updated upon typing.
    */
  value!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
**Note:** When the component is used inside a form element,
the value is sent as the first element in the form data, even if it's empty.
    */
  name!: string;

  /**
     Defines whether the component should show suggestions, if such are present.

**Note:** You need to import the \`InputSuggestions\` module
from \`\\"@ui5/webcomponents/dist/features/InputSuggestions.js\\"\` to enable this functionality.
    */
  showSuggestions!: boolean;

  /**
     Sets the maximum number of characters available in the input field.

**Note:** This property is not compatible with the ui5-input type InputType.Number. If the ui5-input type is set to Number, the maxlength value is ignored.
    */
  maxlength!: number | undefined;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the input.
    */
  accessibleNameRef!: string;

  /**
     Defines whether the clear icon of the input will be shown.
    */
  showClearIcon!: boolean;

  /**
     Defines whether the suggestions picker is open.
The picker will not open if the \`showSuggestions\` property is set to \`false\`, the input is disabled or the input is readonly.
The picker will close automatically and \`close\` event will be fired if the input is not in the viewport.
    */
  open!: boolean;

  /**
     Determines whether a value help icon will be visualized in the end of the input.
Pressing the icon will fire \`value-help-trigger\` event.
    */
  showValueHelpIcon!: boolean;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke,
and when a suggestion item has been selected.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when the user navigates to a suggestion item via the ARROW keys,
as a preview, before the final selection.
    */
  ui5SelectionChange!: EventEmitter<InputSelectionChangeEventDetail>;
  /**
     Fired when the suggestions picker is open.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired when the suggestions picker is closed.
    */
  ui5Close!: EventEmitter<void>;
  /**
     Fired when the value help icon is pressed
and F4 or ALT/OPTION + ARROW_UP/ARROW_DOWN keyboard keys are used.
    */
  ui5ValueHelpTrigger!: EventEmitter<void>;
  /**
     Fired when tokens are being deleted.
    */
  ui5TokenDelete!: EventEmitter<MultiInputTokenDeleteEventDetail>;

  private elementRef: ElementRef<MultiInput> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): MultiInput {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { MultiInputComponent };
"
`;

exports[`Snapshot test Main Ng Package Json should match the snapshot 1`] = `"{\\"lib\\":{\\"entryFile\\":\\"./index.ts\\"}}"`;

exports[`Snapshot test Main Option Custom should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/OptionCustom.js';
import OptionCustom from '@ui5/webcomponents/dist/OptionCustom.js';
@ProxyInputs(['selected', 'displayText', 'value', 'tooltip'])
@Component({
  standalone: true,
  selector: 'ui5-option-custom',
  template: '<ng-content></ng-content>',
  inputs: ['selected', 'displayText', 'value', 'tooltip'],
})
class OptionCustomComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  /**
     Defines the text, displayed inside the \`ui5-select\` input filed
when the option gets selected.
    */
  displayText!: string;

  /**
     Defines the value of the \`ui5-select\` inside an HTML Form element when this component is selected.
For more information on HTML Form support, see the \`name\` property of \`ui5-select\`.
    */
  value!: string;

  /**
     Defines the text of the tooltip that would be displayed for the list item.
    */
  tooltip!: string;

  private elementRef: ElementRef<OptionCustom> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): OptionCustom {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { OptionCustomComponent };
"
`;

exports[`Snapshot test Main Option should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Option.js';
import Option from '@ui5/webcomponents/dist/Option.js';
@ProxyInputs(['selected', 'value', 'icon', 'additionalText', 'tooltip'])
@Component({
  standalone: true,
  selector: 'ui5-option',
  template: '<ng-content></ng-content>',
  inputs: ['selected', 'value', 'icon', 'additionalText', 'tooltip'],
})
class OptionComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  /**
     Defines the value of the \`ui5-select\` inside an HTML Form element when this component is selected.
For more information on HTML Form support, see the \`name\` property of \`ui5-select\`.
    */
  value!: string;

  /**
     Defines the \`icon\` source URI.

**Note:**
SAP-icons font provides numerous built-in icons. To find all the available icons, see the
[Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines the \`additionalText\`, displayed in the end of the list item.
    */
  additionalText!: string;

  /**
     Defines the text of the tooltip that would be displayed for the list item.
    */
  tooltip!: string;

  private elementRef: ElementRef<Option> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Option {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { OptionComponent };
"
`;

exports[`Snapshot test Main Panel should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Panel.js';
import Panel from '@ui5/webcomponents/dist/Panel.js';
@ProxyInputs([
  'headerText',
  'fixed',
  'collapsed',
  'noAnimation',
  'accessibleRole',
  'headerLevel',
  'accessibleName',
  'stickyHeader',
])
@ProxyOutputs(['toggle: ui5Toggle'])
@Component({
  standalone: true,
  selector: 'ui5-panel',
  template: '<ng-content></ng-content>',
  inputs: [
    'headerText',
    'fixed',
    'collapsed',
    'noAnimation',
    'accessibleRole',
    'headerLevel',
    'accessibleName',
    'stickyHeader',
  ],
  outputs: ['ui5Toggle'],
})
class PanelComponent {
  /**
     This property is used to set the header text of the component.
The text is visible in both expanded and collapsed states.

**Note:** This property is overridden by the \`header\` slot.
    */
  headerText!: string;

  /**
     Determines whether the component is in a fixed state that is not
expandable/collapsible by user interaction.
    */
  fixed!: boolean;

  /**
     Indicates whether the component is collapsed and only the header is displayed.
    */
  collapsed!: boolean;

  /**
     Indicates whether the transition between the expanded and the collapsed state of the component is animated. By default the animation is enabled.
    */
  noAnimation!: boolean;

  /**
     Sets the accessible ARIA role of the component.
Depending on the usage, you can change the role from the default \`Form\`
to \`Region\` or \`Complementary\`.
    */
  accessibleRole!: 'Complementary' | 'Form' | 'Region';

  /**
     Defines the \\"aria-level\\" of component heading,
set by the \`headerText\`.
    */
  headerLevel!: 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6';

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Indicates whether the Panel header is sticky or not.
If stickyHeader is set to true, then whenever you scroll the content or
the application, the header of the panel will be always visible and
a solid color will be used for its design.
    */
  stickyHeader!: boolean;

  /**
     Fired when the component is expanded/collapsed by user interaction.
    */
  ui5Toggle!: EventEmitter<void>;

  private elementRef: ElementRef<Panel> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Panel {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { PanelComponent };
"
`;

exports[`Snapshot test Main Popover should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Popover.js';
import Popover from '@ui5/webcomponents/dist/Popover.js';
import { PopupBeforeCloseEventDetail } from '@ui5/webcomponents/dist/Popup.js';
@ProxyInputs([
  'initialFocus',
  'preventFocusRestore',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
  'preventInitialFocus',
  'open',
  'headerText',
  'placement',
  'horizontalAlign',
  'verticalAlign',
  'modal',
  'hideArrow',
  'allowTargetOverlap',
  'opener',
])
@ProxyOutputs([
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-popover',
  template: '<ng-content></ng-content>',
  inputs: [
    'initialFocus',
    'preventFocusRestore',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
    'preventInitialFocus',
    'open',
    'headerText',
    'placement',
    'horizontalAlign',
    'verticalAlign',
    'modal',
    'hideArrow',
    'allowTargetOverlap',
    'opener',
  ],
  outputs: ['ui5BeforeOpen', 'ui5Open', 'ui5BeforeClose', 'ui5Close'],
})
class PopoverComponent {
  /**
     Defines the ID of the HTML Element, which will get the initial focus.

**Note:** If an element with \`autofocus\` attribute is added inside the component,
\`initialFocus\` won't take effect.
    */
  initialFocus!: string;

  /**
     Defines if the focus should be returned to the previously focused element,
when the popup closes.
    */
  preventFocusRestore!: boolean;

  /**
     Defines the accessible name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Defines the IDs of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Allows setting a custom role.
    */
  accessibleRole!: 'None' | 'Dialog' | 'AlertDialog';

  /**
     Indicates whether initial focus should be prevented.
    */
  preventInitialFocus!: boolean;

  /**
     Indicates if the element is open
    */
  open!: boolean;

  /**
     Defines the header text.

**Note:** If \`header\` slot is provided, the \`headerText\` is ignored.
    */
  headerText!: string;

  /**
     Determines on which side the component is placed at.
    */
  placement!: 'Start' | 'End' | 'Top' | 'Bottom';

  /**
     Determines the horizontal alignment of the component.
    */
  horizontalAlign!: 'Center' | 'Start' | 'End' | 'Stretch';

  /**
     Determines the vertical alignment of the component.
    */
  verticalAlign!: 'Center' | 'Top' | 'Bottom' | 'Stretch';

  /**
     Defines whether the component should close when
clicking/tapping outside of the popover.
If enabled, it blocks any interaction with the background.
    */
  modal!: boolean;

  /**
     Determines whether the component arrow is hidden.
    */
  hideArrow!: boolean;

  /**
     Determines if there is no enough space, the component can be placed
over the target.
    */
  allowTargetOverlap!: boolean;

  /**
     Defines the ID or DOM Reference of the element at which the popover is shown.
When using this attribute in a declarative way, you must only use the \`id\` (as a string) of the element at which you want to show the popover.
You can only set the \`opener\` attribute to a DOM Reference when using JavaScript.
    */
  opener!: HTMLElement | string | undefined;

  /**
     Fired before the component is opened. This event can be cancelled, which will prevent the popup from opening. **This event does not bubble.**
    */
  ui5BeforeOpen!: EventEmitter<void>;
  /**
     Fired after the component is opened. **This event does not bubble.**
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the component is closed. This event can be cancelled, which will prevent the popup from closing. **This event does not bubble.**
    */
  ui5BeforeClose!: EventEmitter<PopupBeforeCloseEventDetail>;
  /**
     Fired after the component is closed. **This event does not bubble.**
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Popover> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Popover {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { PopoverComponent };
"
`;

exports[`Snapshot test Main Progress Indicator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ProgressIndicator.js';
import ProgressIndicator from '@ui5/webcomponents/dist/ProgressIndicator.js';
@ProxyInputs([
  'accessibleName',
  'hideValue',
  'value',
  'displayValue',
  'valueState',
])
@Component({
  standalone: true,
  selector: 'ui5-progress-indicator',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleName',
    'hideValue',
    'value',
    'displayValue',
    'valueState',
  ],
})
class ProgressIndicatorComponent {
  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Defines whether the component value is shown.
    */
  hideValue!: boolean;

  /**
     Specifies the numerical value in percent for the length of the component.

**Note:**
If a value greater than 100 is provided, the percentValue is set to 100. In other cases of invalid value, percentValue is set to its default of 0.
    */
  value!: number;

  /**
     Specifies the text value to be displayed in the bar.

**Note:**

- If there is no value provided or the value is empty, the default percentage value is shown.
- If \`hideValue\` property is \`true\` both the \`displayValue\` and \`value\` property values are not shown.
    */
  displayValue!: string | null | undefined;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  private elementRef: ElementRef<ProgressIndicator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ProgressIndicator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ProgressIndicatorComponent };
"
`;

exports[`Snapshot test Main Radio Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/RadioButton.js';
import RadioButton from '@ui5/webcomponents/dist/RadioButton.js';
@ProxyInputs([
  'disabled',
  'readonly',
  'required',
  'checked',
  'text',
  'valueState',
  'name',
  'value',
  'wrappingType',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-radio-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'readonly',
    'required',
    'checked',
    'text',
    'valueState',
    'name',
    'value',
    'wrappingType',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change'],
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange(cvaValue)' },
})
class RadioButtonComponent {
  /**
     Defines whether the component is disabled.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Defines whether the component is checked or not.

**Note:** The property value can be changed with user interaction,
either by clicking/tapping on the component,
or by using the Space or Enter key.
    */
  checked!: boolean;

  /**
     Defines the text of the component.
    */
  text!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

Radio buttons with the same \`name\` will form a radio button group.

**Note:** By this name the component will be identified upon submission in an HTML form.

**Note:** The selection can be changed with \`ARROW_UP/DOWN\` and \`ARROW_LEFT/RIGHT\` keys between radio buttons in same group.

**Note:** Only one radio button can be selected per group.
    */
  name!: string;

  /**
     Defines the form value of the component.
When a form with a radio button group is submitted, the group's value
will be the value of the currently selected radio button.
    */
  value!: string;

  /**
     Defines whether the component text wraps when there is not enough space.

**Note:** for option \\"Normal\\" the text will wrap and the words will not be broken based on hyphenation.
    */
  wrappingType!: 'None' | 'Normal';

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Defines the IDs of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Fired when the component checked state changes.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<RadioButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): RadioButton {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val: string) {
    this.element.checked = this.element.value === val;
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { RadioButtonComponent };
"
`;

exports[`Snapshot test Main Range Slider should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/RangeSlider.js';
import RangeSlider from '@ui5/webcomponents/dist/RangeSlider.js';
@ProxyInputs([
  'min',
  'max',
  'name',
  'step',
  'labelInterval',
  'showTickmarks',
  'showTooltip',
  'disabled',
  'accessibleName',
  'startValue',
  'endValue',
])
@ProxyOutputs(['change: ui5Change', 'input: ui5Input'])
@Component({
  standalone: true,
  selector: 'ui5-range-slider',
  template: '<ng-content></ng-content>',
  inputs: [
    'min',
    'max',
    'name',
    'step',
    'labelInterval',
    'showTickmarks',
    'showTooltip',
    'disabled',
    'accessibleName',
    'startValue',
    'endValue',
  ],
  outputs: ['ui5Change', 'ui5Input'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class RangeSliderComponent {
  /**
     Defines the minimum value of the slider.
    */
  min!: number;

  /**
     Defines the maximum value of the slider.
    */
  max!: number;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).

**Note:** If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.
    */
  step!: number;

  /**
     Displays a label with a value on every N-th step.

**Note:** The step and tickmarks properties must be enabled.
Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second
tickmark will be labelled, which means every 4th value number.
    */
  labelInterval!: number;

  /**
     Enables tickmarks visualization for each step.

**Note:** The step must be a positive number.
    */
  showTickmarks!: boolean;

  /**
     Enables handle tooltip displaying the current value.
    */
  showTooltip!: boolean;

  /**
     Defines whether the slider is in disabled state.
    */
  disabled!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Defines start point of a selection - position of a first handle on the slider.
    */
  startValue!: number;

  /**
     Defines end point of a selection - position of a second handle on the slider.
    */
  endValue!: number;

  /**
     Fired when the value changes and the user has finished interacting with the slider.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.
    */
  ui5Input!: EventEmitter<void>;

  private elementRef: ElementRef<RangeSlider> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): RangeSlider {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.startValue = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.startValue;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { RangeSliderComponent };
"
`;

exports[`Snapshot test Main Rating Indicator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/RatingIndicator.js';
import RatingIndicator from '@ui5/webcomponents/dist/RatingIndicator.js';
@ProxyInputs([
  'value',
  'max',
  'disabled',
  'readonly',
  'accessibleName',
  'accessibleNameRef',
  'required',
  'tooltip',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-rating-indicator',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'max',
    'disabled',
    'readonly',
    'accessibleName',
    'accessibleNameRef',
    'required',
    'tooltip',
  ],
  outputs: ['ui5Change'],
})
class RatingIndicatorComponent {
  /**
     The indicated value of the rating.

**Note:** If you set a number which is not round, it would be shown as follows:

- 1.0 - 1.2 -> 1
- 1.3 - 1.7 -> 1.5
- 1.8 - 1.9 -> 2
    */
  value!: number;

  /**
     The number of displayed rating symbols.
    */
  max!: number;

  /**
     Defines whether the component is disabled.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Defines the tooltip of the component.
    */
  tooltip!: string;

  /**
     The event is fired when the value changes.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<RatingIndicator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): RatingIndicator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { RatingIndicatorComponent };
"
`;

exports[`Snapshot test Main Responsive Popover should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { PopupBeforeCloseEventDetail } from '@ui5/webcomponents/dist/Popup.js';
import '@ui5/webcomponents/dist/ResponsivePopover.js';
import ResponsivePopover from '@ui5/webcomponents/dist/ResponsivePopover.js';
@ProxyInputs([
  'initialFocus',
  'preventFocusRestore',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
  'preventInitialFocus',
  'open',
  'headerText',
  'placement',
  'horizontalAlign',
  'verticalAlign',
  'modal',
  'hideArrow',
  'allowTargetOverlap',
  'opener',
])
@ProxyOutputs([
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-responsive-popover',
  template: '<ng-content></ng-content>',
  inputs: [
    'initialFocus',
    'preventFocusRestore',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
    'preventInitialFocus',
    'open',
    'headerText',
    'placement',
    'horizontalAlign',
    'verticalAlign',
    'modal',
    'hideArrow',
    'allowTargetOverlap',
    'opener',
  ],
  outputs: ['ui5BeforeOpen', 'ui5Open', 'ui5BeforeClose', 'ui5Close'],
})
class ResponsivePopoverComponent {
  /**
     Defines the ID of the HTML Element, which will get the initial focus.

**Note:** If an element with \`autofocus\` attribute is added inside the component,
\`initialFocus\` won't take effect.
    */
  initialFocus!: string;

  /**
     Defines if the focus should be returned to the previously focused element,
when the popup closes.
    */
  preventFocusRestore!: boolean;

  /**
     Defines the accessible name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Defines the IDs of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Allows setting a custom role.
    */
  accessibleRole!: 'None' | 'Dialog' | 'AlertDialog';

  /**
     Indicates whether initial focus should be prevented.
    */
  preventInitialFocus!: boolean;

  /**
     Indicates if the element is open
    */
  open!: boolean;

  /**
     Defines the header text.

**Note:** If \`header\` slot is provided, the \`headerText\` is ignored.
    */
  headerText!: string;

  /**
     Determines on which side the component is placed at.
    */
  placement!: 'Start' | 'End' | 'Top' | 'Bottom';

  /**
     Determines the horizontal alignment of the component.
    */
  horizontalAlign!: 'Center' | 'Start' | 'End' | 'Stretch';

  /**
     Determines the vertical alignment of the component.
    */
  verticalAlign!: 'Center' | 'Top' | 'Bottom' | 'Stretch';

  /**
     Defines whether the component should close when
clicking/tapping outside of the popover.
If enabled, it blocks any interaction with the background.
    */
  modal!: boolean;

  /**
     Determines whether the component arrow is hidden.
    */
  hideArrow!: boolean;

  /**
     Determines if there is no enough space, the component can be placed
over the target.
    */
  allowTargetOverlap!: boolean;

  /**
     Defines the ID or DOM Reference of the element at which the popover is shown.
When using this attribute in a declarative way, you must only use the \`id\` (as a string) of the element at which you want to show the popover.
You can only set the \`opener\` attribute to a DOM Reference when using JavaScript.
    */
  opener!: HTMLElement | string | undefined;

  /**
     Fired before the component is opened. This event can be cancelled, which will prevent the popup from opening. **This event does not bubble.**
    */
  ui5BeforeOpen!: EventEmitter<void>;
  /**
     Fired after the component is opened. **This event does not bubble.**
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the component is closed. This event can be cancelled, which will prevent the popup from closing. **This event does not bubble.**
    */
  ui5BeforeClose!: EventEmitter<PopupBeforeCloseEventDetail>;
  /**
     Fired after the component is closed. **This event does not bubble.**
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<ResponsivePopover> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ResponsivePopover {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ResponsivePopoverComponent };
"
`;

exports[`Snapshot test Main Segmented Button Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SegmentedButtonItem.js';
import SegmentedButtonItem from '@ui5/webcomponents/dist/SegmentedButtonItem.js';
@ProxyInputs([
  'disabled',
  'selected',
  'tooltip',
  'accessibleName',
  'accessibleNameRef',
  'icon',
])
@Component({
  standalone: true,
  selector: 'ui5-segmented-button-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'selected',
    'tooltip',
    'accessibleName',
    'accessibleNameRef',
    'icon',
  ],
})
class SegmentedButtonItemComponent {
  /**
     Defines whether the component is disabled.
A disabled component can't be selected or
focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Determines whether the component is displayed as selected.
    */
  selected!: boolean;

  /**
     Defines the tooltip of the component.

**Note:** A tooltip attribute should be provided for icon-only buttons, in order to represent their exact meaning/function.
    */
  tooltip!: string;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Defines the icon, displayed as graphical element within the component.
The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  private elementRef: ElementRef<SegmentedButtonItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SegmentedButtonItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SegmentedButtonItemComponent };
"
`;

exports[`Snapshot test Main Segmented Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SegmentedButton.js';
import {
  default as SegmentedButton,
  SegmentedButtonSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/SegmentedButton.js';
@ProxyInputs(['accessibleName', 'selectionMode'])
@ProxyOutputs(['selection-change: ui5SelectionChange'])
@Component({
  standalone: true,
  selector: 'ui5-segmented-button',
  template: '<ng-content></ng-content>',
  inputs: ['accessibleName', 'selectionMode'],
  outputs: ['ui5SelectionChange'],
})
class SegmentedButtonComponent {
  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Defines the component selection mode.
    */
  selectionMode!: 'Single' | 'Multiple';

  /**
     Fired when the selected item changes.
    */
  ui5SelectionChange!: EventEmitter<SegmentedButtonSelectionChangeEventDetail>;

  private elementRef: ElementRef<SegmentedButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SegmentedButton {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SegmentedButtonComponent };
"
`;

exports[`Snapshot test Main Select should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Select.js';
import {
  default as Select,
  SelectChangeEventDetail,
  SelectLiveChangeEventDetail,
} from '@ui5/webcomponents/dist/Select.js';
@ProxyInputs([
  'disabled',
  'name',
  'valueState',
  'required',
  'readonly',
  'accessibleName',
  'accessibleNameRef',
  'value',
])
@ProxyOutputs([
  'change: ui5Change',
  'live-change: ui5LiveChange',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-select',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'name',
    'valueState',
    'required',
    'readonly',
    'accessibleName',
    'accessibleNameRef',
    'value',
  ],
  outputs: ['ui5Change', 'ui5LiveChange', 'ui5Open', 'ui5Close'],
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange(cvaValue)' },
})
class SelectComponent {
  /**
     Defines whether the component is in disabled state.

**Note:** A disabled component is noninteractive.
    */
  disabled!: boolean;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the select.
    */
  accessibleNameRef!: string;

  /**
     Defines the value of the component:

- when get - returns the value of the component, e.g. the \`value\` property of the selected option or its text content.

- when set - selects the option with matching \`value\` property or text content.

**Note:** If the given value does not match any existing option,
the first option will get selected.
    */
  value!: string;

  /**
     Fired when the selected option changes.
    */
  ui5Change!: EventEmitter<SelectChangeEventDetail>;
  /**
     Fired when the user navigates through the options, but the selection is not finalized,
or when pressing the ESC key to revert the current selection.
    */
  ui5LiveChange!: EventEmitter<SelectLiveChangeEventDetail>;
  /**
     Fired after the component's dropdown menu opens.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the component's dropdown menu closes.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Select> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): Select {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { SelectComponent };
"
`;

exports[`Snapshot test Main Slider should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Slider.js';
import Slider from '@ui5/webcomponents/dist/Slider.js';
@ProxyInputs([
  'min',
  'max',
  'name',
  'step',
  'labelInterval',
  'showTickmarks',
  'showTooltip',
  'disabled',
  'accessibleName',
  'value',
])
@ProxyOutputs(['change: ui5Change', 'input: ui5Input'])
@Component({
  standalone: true,
  selector: 'ui5-slider',
  template: '<ng-content></ng-content>',
  inputs: [
    'min',
    'max',
    'name',
    'step',
    'labelInterval',
    'showTickmarks',
    'showTooltip',
    'disabled',
    'accessibleName',
    'value',
  ],
  outputs: ['ui5Change', 'ui5Input'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class SliderComponent {
  /**
     Defines the minimum value of the slider.
    */
  min!: number;

  /**
     Defines the maximum value of the slider.
    */
  max!: number;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).

**Note:** If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.
    */
  step!: number;

  /**
     Displays a label with a value on every N-th step.

**Note:** The step and tickmarks properties must be enabled.
Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second
tickmark will be labelled, which means every 4th value number.
    */
  labelInterval!: number;

  /**
     Enables tickmarks visualization for each step.

**Note:** The step must be a positive number.
    */
  showTickmarks!: boolean;

  /**
     Enables handle tooltip displaying the current value.
    */
  showTooltip!: boolean;

  /**
     Defines whether the slider is in disabled state.
    */
  disabled!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Current value of the slider
    */
  value!: number;

  /**
     Fired when the value changes and the user has finished interacting with the slider.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.
    */
  ui5Input!: EventEmitter<void>;

  private elementRef: ElementRef<Slider> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): Slider {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { SliderComponent };
"
`;

exports[`Snapshot test Main Special Calendar Date should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SpecialCalendarDate.js';
import SpecialCalendarDate from '@ui5/webcomponents/dist/SpecialCalendarDate.js';
@ProxyInputs(['value', 'type'])
@Component({
  standalone: true,
  selector: 'ui5-special-date',
  template: '<ng-content></ng-content>',
  inputs: ['value', 'type'],
})
class SpecialCalendarDateComponent {
  /**
     The date formatted according to the \`formatPattern\` property
of the \`ui5-calendar\` that hosts the component.
    */
  value!: string;

  /**
     Defines the type of the special date.
    */
  type!:
    | 'None'
    | 'Working'
    | 'NonWorking'
    | 'Type01'
    | 'Type02'
    | 'Type03'
    | 'Type04'
    | 'Type05'
    | 'Type06'
    | 'Type07'
    | 'Type08'
    | 'Type09'
    | 'Type10'
    | 'Type11'
    | 'Type12'
    | 'Type13'
    | 'Type14'
    | 'Type15'
    | 'Type16'
    | 'Type17'
    | 'Type18'
    | 'Type19'
    | 'Type20';

  private elementRef: ElementRef<SpecialCalendarDate> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SpecialCalendarDate {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SpecialCalendarDateComponent };
"
`;

exports[`Snapshot test Main Split Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SplitButton.js';
import SplitButton from '@ui5/webcomponents/dist/SplitButton.js';
@ProxyInputs([
  'icon',
  'activeArrowButton',
  'design',
  'disabled',
  'accessibleName',
])
@ProxyOutputs(['click: ui5Click', 'arrow-click: ui5ArrowClick'])
@Component({
  standalone: true,
  selector: 'ui5-split-button',
  template: '<ng-content></ng-content>',
  inputs: ['icon', 'activeArrowButton', 'design', 'disabled', 'accessibleName'],
  outputs: ['ui5Click', 'ui5ArrowClick'],
})
class SplitButtonComponent {
  /**
     Defines the icon to be displayed as graphical element within the component.
The SAP-icons font provides numerous options.

Example:

See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines whether the arrow button should have the active state styles or not.
    */
  activeArrowButton!: boolean;

  /**
     Defines the component design.
    */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';

  /**
     Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Fired when the user clicks on the default action.
    */
  ui5Click!: EventEmitter<void>;
  /**
     Fired when the user clicks on the arrow action.
    */
  ui5ArrowClick!: EventEmitter<void>;

  private elementRef: ElementRef<SplitButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SplitButton {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SplitButtonComponent };
"
`;

exports[`Snapshot test Main Standard List Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
import '@ui5/webcomponents/dist/StandardListItem.js';
import StandardListItem from '@ui5/webcomponents/dist/StandardListItem.js';
@ProxyInputs([
  'selected',
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'description',
  'icon',
  'iconEnd',
  'image',
  'additionalText',
  'additionalTextState',
  'movable',
  'accessibleName',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-li',
  template: '<ng-content></ng-content>',
  inputs: [
    'selected',
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'description',
    'icon',
    'iconEnd',
    'image',
    'additionalText',
    'additionalTextState',
    'movable',
    'accessibleName',
  ],
  outputs: ['ui5DetailClick'],
})
class StandardListItemComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  /**
     Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
    */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
    */
  accessibilityAttributes!: ListItemAccessibilityAttributes;

  /**
     The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
    */
  navigated!: boolean;

  /**
     Defines the text of the tooltip that would be displayed for the list item.
    */
  tooltip!: string;

  /**
     Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
    */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines the description displayed right under the item text, if such is present.
    */
  description!: string;

  /**
     Defines the \`icon\` source URI.

**Note:**
SAP-icons font provides numerous built-in icons. To find all the available icons, see the
[Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines whether the \`icon\` should be displayed in the beginning of the list item or in the end.

**Note:** If \`image\` is set, the \`icon\` would be displayed after the \`image\`.
    */
  iconEnd!: boolean;

  /**
     Defines the \`image\` source URI.

**Note:** The \`image\` would be displayed in the beginning of the list item.
    */
  image!: string;

  /**
     Defines the \`additionalText\`, displayed in the end of the list item.
    */
  additionalText!: string;

  /**
     Defines the state of the \`additionalText\`.

Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
    */
  additionalTextState!:
    | 'None'
    | 'Positive'
    | 'Critical'
    | 'Negative'
    | 'Information';

  /**
     Defines whether the item is movable.
    */
  movable!: boolean;

  /**
     Defines the text alternative of the component.
Note: If not provided a default text alternative will be set, if present.
    */
  accessibleName!: string;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<StandardListItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): StandardListItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { StandardListItemComponent };
"
`;

exports[`Snapshot test Main Step Input should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/StepInput.js';
import {
  default as StepInput,
  StepInputValueStateChangeEventDetail,
} from '@ui5/webcomponents/dist/StepInput.js';
@ProxyInputs([
  'value',
  'min',
  'max',
  'step',
  'valueState',
  'required',
  'disabled',
  'readonly',
  'placeholder',
  'name',
  'valuePrecision',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs(['change: ui5Change', 'value-state-change: ui5ValueStateChange'])
@Component({
  standalone: true,
  selector: 'ui5-step-input',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'min',
    'max',
    'step',
    'valueState',
    'required',
    'disabled',
    'readonly',
    'placeholder',
    'name',
    'valuePrecision',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change', 'ui5ValueStateChange'],
})
class StepInputComponent {
  /**
     Defines a value of the component.
    */
  value!: number;

  /**
     Defines a minimum value of the component.
    */
  min!: number | undefined;

  /**
     Defines a maximum value of the component.
    */
  max!: number | undefined;

  /**
     Defines a step of increasing/decreasing the value of the component.
    */
  step!: number;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Determines whether the component is displayed as disabled.
    */
  disabled!: boolean;

  /**
     Determines whether the component is displayed as read-only.
    */
  readonly!: boolean;

  /**
     Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
    */
  placeholder!: string | undefined;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Determines the number of digits after the decimal point of the component.
    */
  valuePrecision!: number;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired before the value state of the component is updated internally.
The event is preventable, meaning that if it's default action is
prevented, the component will not update the value state.
    */
  ui5ValueStateChange!: EventEmitter<StepInputValueStateChangeEventDetail>;

  private elementRef: ElementRef<StepInput> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): StepInput {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { StepInputComponent };
"
`;

exports[`Snapshot test Main Suggestion Group Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SuggestionGroupItem.js';
import SuggestionGroupItem from '@ui5/webcomponents/dist/SuggestionGroupItem.js';
@ProxyInputs(['text'])
@Component({
  standalone: true,
  selector: 'ui5-suggestion-group-item',
  template: '<ng-content></ng-content>',
  inputs: ['text'],
})
class SuggestionGroupItemComponent {
  /**
     Defines the text of the \`ui5-suggestion-group-item\`.
    */
  text!: string;

  private elementRef: ElementRef<SuggestionGroupItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SuggestionGroupItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SuggestionGroupItemComponent };
"
`;

exports[`Snapshot test Main Suggestion Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SuggestionItem.js';
import SuggestionItem from '@ui5/webcomponents/dist/SuggestionItem.js';
@ProxyInputs([
  'text',
  'type',
  'description',
  'icon',
  'iconEnd',
  'image',
  'additionalText',
  'additionalTextState',
])
@Component({
  standalone: true,
  selector: 'ui5-suggestion-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'text',
    'type',
    'description',
    'icon',
    'iconEnd',
    'image',
    'additionalText',
    'additionalTextState',
  ],
})
class SuggestionItemComponent {
  /**
     Defines the text of the component.
    */
  text!: string;

  /**
     Defines the visual indication and behavior of the item.
Available options are \`Active\` (by default), \`Inactive\` and \`Detail\`.

**Note:** When set to \`Active\`, the item will provide visual response upon press and hover,
while when \`Inactive\` or \`Detail\` - will not.
    */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';

  /**
     Defines the description displayed right under the item text, if such is present.
    */
  description!: string;

  /**
     Defines the \`icon\` source URI.

**Note:**
SAP-icons font provides numerous built-in icons. To find all the available icons, see the
[Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines whether the \`icon\` should be displayed in the beginning of the item or in the end.

**Note:** If \`image\` is set, the \`icon\` would be displayed after the \`image\`.
    */
  iconEnd!: boolean;

  /**
     Defines the \`image\` source URI.

**Note:** The \`image\` would be displayed in the beginning of the item.
    */
  image!: string;

  /**
     Defines the \`additionalText\`, displayed in the end of the item.
    */
  additionalText!: string;

  /**
     Defines the state of the \`additionalText\`.
    */
  additionalTextState!:
    | 'None'
    | 'Positive'
    | 'Critical'
    | 'Negative'
    | 'Information';

  private elementRef: ElementRef<SuggestionItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SuggestionItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SuggestionItemComponent };
"
`;

exports[`Snapshot test Main Switch should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Switch.js';
import Switch from '@ui5/webcomponents/dist/Switch.js';
@ProxyInputs([
  'design',
  'checked',
  'disabled',
  'textOn',
  'textOff',
  'accessibleName',
  'accessibleNameRef',
  'tooltip',
  'required',
  'name',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-switch',
  template: '<ng-content></ng-content>',
  inputs: [
    'design',
    'checked',
    'disabled',
    'textOn',
    'textOff',
    'accessibleName',
    'accessibleNameRef',
    'tooltip',
    'required',
    'name',
  ],
  outputs: ['ui5Change'],
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange(cvaValue)' },
})
class SwitchComponent {
  /**
     Defines the component design.

**Note:** If \`Graphical\` type is set,
positive and negative icons will replace the \`textOn\` and \`textOff\`.
    */
  design!: 'Textual' | 'Graphical';

  /**
     Defines if the component is checked.

**Note:** The property can be changed with user interaction,
either by cliking the component, or by pressing the \`Enter\` or \`Space\` key.
    */
  checked!: boolean;

  /**
     Defines whether the component is disabled.

**Note:** A disabled component is noninteractive.
    */
  disabled!: boolean;

  /**
     Defines the text, displayed when the component is checked.

**Note:** We recommend using short texts, up to 3 letters (larger texts would be cut off).
    */
  textOn!: string;

  /**
     Defines the text, displayed when the component is not checked.

**Note:** We recommend using short texts, up to 3 letters (larger texts would be cut off).
    */
  textOff!: string;

  /**
     Sets the accessible ARIA name of the component.

**Note**: We recommend that you set an accessibleNameRef pointing to an external label or at least an \`accessibleName\`.
Providing an \`accessibleNameRef\` or an \`accessibleName\` is mandatory in the cases when \`textOn\` and \`textOff\` properties aren't set.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the component.

**Note**: We recommend that you set an accessibleNameRef pointing to an external label or at least an \`accessibleName\`.
Providing an \`accessibleNameRef\` or an \`accessibleName\` is mandatory in the cases when \`textOn\` and \`textOff\` properties aren't set.
    */
  accessibleNameRef!: string;

  /**
     Defines the tooltip of the component.

**Note:** If applicable an external label reference should always be the preferred option to provide context to the \`ui5-switch\` component over a tooltip.
    */
  tooltip!: string;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Fired when the component checked state changes.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<Switch> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): Switch {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.checked = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.checked;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { SwitchComponent };
"
`;

exports[`Snapshot test Main Tab Container should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TabContainer.js';
import {
  default as TabContainer,
  TabContainerMoveEventDetail,
  TabContainerTabSelectEventDetail,
} from '@ui5/webcomponents/dist/TabContainer.js';
@ProxyInputs([
  'collapsed',
  'tabLayout',
  'overflowMode',
  'headerBackgroundDesign',
  'contentBackgroundDesign',
])
@ProxyOutputs([
  'tab-select: ui5TabSelect',
  'move-over: ui5MoveOver',
  'move: ui5Move',
])
@Component({
  standalone: true,
  selector: 'ui5-tabcontainer',
  template: '<ng-content></ng-content>',
  inputs: [
    'collapsed',
    'tabLayout',
    'overflowMode',
    'headerBackgroundDesign',
    'contentBackgroundDesign',
  ],
  outputs: ['ui5TabSelect', 'ui5MoveOver', 'ui5Move'],
})
class TabContainerComponent {
  /**
     Defines whether the tab content is collapsed.
    */
  collapsed!: boolean;

  /**
     Defines the alignment of the content and the \`additionalText\` of a tab.

**Note:**
The content and the \`additionalText\` would be displayed vertically by default,
but when set to \`Inline\`, they would be displayed horizontally.
    */
  tabLayout!: 'Inline' | 'Standard';

  /**
     Defines the overflow mode of the header (the tab strip). If you have a large number of tabs, only the tabs that can fit on screen will be visible.
All other tabs that can 't fit on the screen are available in an overflow tab \\"More\\".

**Note:**
Only one overflow at the end would be displayed by default,
but when set to \`StartAndEnd\`, there will be two overflows on both ends, and tab order will not change on tab selection.
    */
  overflowMode!: 'End' | 'StartAndEnd';

  /**
     Sets the background color of the Tab Container's header as \`Solid\`, \`Transparent\`, or \`Translucent\`.
    */
  headerBackgroundDesign!: 'Solid' | 'Transparent' | 'Translucent';

  /**
     Sets the background color of the Tab Container's content as \`Solid\`, \`Transparent\`, or \`Translucent\`.
    */
  contentBackgroundDesign!: 'Solid' | 'Transparent' | 'Translucent';

  /**
     Fired when a tab is selected.
    */
  ui5TabSelect!: EventEmitter<TabContainerTabSelectEventDetail>;
  /**
     Fired when element is being moved over the tab container.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5MoveOver!: EventEmitter<TabContainerMoveEventDetail>;
  /**
     Fired when element is moved to the tab container.

**Note:** \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.
    */
  ui5Move!: EventEmitter<TabContainerMoveEventDetail>;

  private elementRef: ElementRef<TabContainer> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TabContainer {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TabContainerComponent };
"
`;

exports[`Snapshot test Main Tab Separator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents/dist/TabSeparator.js';
import TabSeparator from '@ui5/webcomponents/dist/TabSeparator.js';

@Component({
  standalone: true,
  selector: 'ui5-tab-separator',
  template: '<ng-content></ng-content>',
})
class TabSeparatorComponent {
  private elementRef: ElementRef<TabSeparator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TabSeparator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TabSeparatorComponent };
"
`;

exports[`Snapshot test Main Tab should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Tab.js';
import Tab from '@ui5/webcomponents/dist/Tab.js';
@ProxyInputs([
  'text',
  'disabled',
  'additionalText',
  'icon',
  'design',
  'selected',
])
@Component({
  standalone: true,
  selector: 'ui5-tab',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'disabled', 'additionalText', 'icon', 'design', 'selected'],
})
class TabComponent {
  /**
     The text to be displayed for the item.
    */
  text!: string;

  /**
     Disabled tabs can't be selected.
    */
  disabled!: boolean;

  /**
     Represents the \\"additionalText\\" text, which is displayed in the tab. In the cases when in the same time there are tabs with icons and tabs without icons, if a tab has no icon the \\"additionalText\\" is displayed larger.
    */
  additionalText!: string;

  /**
     Defines the icon source URI to be displayed as graphical element within the component.
The SAP-icons font provides numerous built-in icons.
See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines the component's design color.

The design is applied to:

- the component icon
- the \`text\` when the component overflows
- the tab selection line

Available designs are: \`\\"Default\\"\`, \`\\"Neutral\\"\`, \`\\"Positive\\"\`, \`\\"Critical\\"\` and \`\\"Negative\\"\`.

**Note:** The design depends on the current theme.
    */
  design!: 'Default' | 'Positive' | 'Negative' | 'Critical' | 'Neutral';

  /**
     Specifies if the component is selected.
    */
  selected!: boolean;

  private elementRef: ElementRef<Tab> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Tab {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TabComponent };
"
`;

exports[`Snapshot test Main Tag should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Tag.js';
import Tag from '@ui5/webcomponents/dist/Tag.js';
@ProxyInputs([
  'design',
  'colorScheme',
  'hideStateIcon',
  'interactive',
  'wrappingType',
  'size',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-tag',
  template: '<ng-content></ng-content>',
  inputs: [
    'design',
    'colorScheme',
    'hideStateIcon',
    'interactive',
    'wrappingType',
    'size',
  ],
  outputs: ['ui5Click'],
})
class TagComponent {
  /**
     Defines the design type of the component.
    */
  design!:
    | 'Set1'
    | 'Set2'
    | 'Set3'
    | 'Neutral'
    | 'Information'
    | 'Positive'
    | 'Negative'
    | 'Critical';

  /**
     Defines the color scheme of the component.
There are 10 predefined schemes.
To use one you can set a number from \`\\"1\\"\` to \`\\"10\\"\`. The \`colorScheme\` \`\\"1\\"\` will be set by default.
    */
  colorScheme!: string;

  /**
     Defines if the default state icon is shown.
    */
  hideStateIcon!: boolean;

  /**
     Defines if the component is interactive (focusable and pressable).

**Note:** The tag cannot be \`interactive\`
when \`design\` property is \`TagDesign.Set3\`
    */
  interactive!: boolean;

  /**
     Defines how the text of a component will be displayed when there is not enough space.

**Note:** For option \\"Normal\\" the text will wrap and the
words will not be broken based on hyphenation.
    */
  wrappingType!: 'None' | 'Normal';

  /**
     Defines predefined size of the component.
    */
  size!: 'S' | 'L';

  /**
     Fired when the user clicks on an interactive tag.

**Note:** The event will be fired if the \`interactive\` property is \`true\`
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<Tag> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Tag {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TagComponent };
"
`;

exports[`Snapshot test Main Text Area should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TextArea.js';
import TextArea from '@ui5/webcomponents/dist/TextArea.js';
@ProxyInputs([
  'value',
  'disabled',
  'readonly',
  'required',
  'placeholder',
  'valueState',
  'rows',
  'maxlength',
  'showExceededText',
  'growing',
  'growingMaxRows',
  'name',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'select: ui5Select',
  'scroll: ui5Scroll',
])
@Component({
  standalone: true,
  selector: 'ui5-textarea',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'disabled',
    'readonly',
    'required',
    'placeholder',
    'valueState',
    'rows',
    'maxlength',
    'showExceededText',
    'growing',
    'growingMaxRows',
    'name',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5Select', 'ui5Scroll'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class TextAreaComponent {
  /**
     Defines the value of the component.
    */
  value!: string;

  /**
     Indicates whether the user can interact with the component or not.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines whether the component is required.
    */
  required!: boolean;

  /**
     Defines a short hint intended to aid the user with data entry when the component has no value.
    */
  placeholder!: string;

  /**
     Defines the value state of the component.

**Note:** If \`maxlength\` property is set,
the component turns into \\"Warning\\" state once the characters exceeds the limit.
In this case, only the \\"Error\\" state is considered and can be applied.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines the number of visible text rows for the component.

**Notes:**

- If the \`growing\` property is enabled, this property defines the minimum rows to be displayed
in the textarea.
- The CSS \`height\` property wins over the \`rows\` property, if both are set.
    */
  rows!: number;

  /**
     Defines the maximum number of characters that the \`value\` can have.
    */
  maxlength!: number | undefined;

  /**
     Determines whether the characters exceeding the maximum allowed character count are visible
in the component.

If set to \`false\`, the user is not allowed to enter more characters than what is set in the
\`maxlength\` property.
If set to \`true\` the characters exceeding the \`maxlength\` value are selected on
paste and the counter below the component displays their number.
    */
  showExceededText!: boolean;

  /**
     Enables the component to automatically grow and shrink dynamically with its content.
    */
  growing!: boolean;

  /**
     Defines the maximum number of rows that the component can grow.
    */
  growingMaxRows!: number;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the textarea.
    */
  accessibleNameRef!: string;

  /**
     Fired when the text has changed and the focus leaves the component.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke or when
something is pasted.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when some text has been selected.
    */
  ui5Select!: EventEmitter<void>;
  /**
     Fired when textarea is scrolled.
    */
  ui5Scroll!: EventEmitter<void>;

  private elementRef: ElementRef<TextArea> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): TextArea {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { TextAreaComponent };
"
`;

exports[`Snapshot test Main Text should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Text.js';
import Text from '@ui5/webcomponents/dist/Text.js';
@ProxyInputs(['maxLines'])
@Component({
  standalone: true,
  selector: 'ui5-text',
  template: '<ng-content></ng-content>',
  inputs: ['maxLines'],
})
class TextComponent {
  /**
     Defines the number of lines the text should wrap before it truncates.
    */
  maxLines!: number;

  private elementRef: ElementRef<Text> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Text {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TextComponent };
"
`;

exports[`Snapshot test Main Theming should match the snapshot 1`] = `
"import { Injectable } from '@angular/core';
import { WebcomponentsThemingProvider } from '@ui5/webcomponents-ngx/theming';

@Injectable({ providedIn: 'root' })
class Ui5WebcomponentsMainThemingService extends WebcomponentsThemingProvider {
  name = 'ui-5-webcomponents-main-theming-service';
  constructor() {
    super(
      () => import('@ui5/webcomponents/dist/generated/json-imports/Themes.js'),
    );
  }
}

export { Ui5WebcomponentsMainThemingService };
"
`;

exports[`Snapshot test Main Time Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TimePicker.js';
import {
  default as TimePicker,
  TimePickerChangeEventDetail,
  TimePickerInputEventDetail,
} from '@ui5/webcomponents/dist/TimePicker.js';
@ProxyInputs([
  'value',
  'name',
  'valueState',
  'disabled',
  'readonly',
  'placeholder',
  'formatPattern',
  'open',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-time-picker',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'name',
    'valueState',
    'disabled',
    'readonly',
    'placeholder',
    'formatPattern',
    'open',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5Open', 'ui5Close'],
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange(cvaValue)',
    '(input)': '_cva?.onChange(cvaValue)',
  },
})
class TimePickerComponent {
  /**
     Defines a formatted time value.
    */
  value!: string | undefined;

  /**
     Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  name!: string;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines the disabled state of the comonent.
    */
  disabled!: boolean;

  /**
     Defines the readonly state of the comonent.
    */
  readonly!: boolean;

  /**
     Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
    */
  placeholder!: string | undefined;

  /**
     Determines the format, displayed in the input field.

Example:
HH:mm:ss -> 11:42:35
hh:mm:ss a -> 2:23:15 PM
mm:ss -> 12:04 (only minutes and seconds)
    */
  formatPattern!: string;

  /**
     Defines the open or closed state of the popover.
    */
  open!: boolean;

  /**
     Fired when the input operation has finished by clicking the \\"OK\\" button or
when the text in the input field has changed and the focus leaves the input field.
    */
  ui5Change!: EventEmitter<TimePickerChangeEventDetail>;
  /**
     Fired when the value of the \`ui5-time-picker\` is changed at each key stroke.
    */
  ui5Input!: EventEmitter<TimePickerInputEventDetail>;
  /**
     Fired after the value-help dialog of the component is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the value-help dialog of the component is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<TimePicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): TimePicker {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { TimePickerComponent };
"
`;

exports[`Snapshot test Main Title should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Title.js';
import Title from '@ui5/webcomponents/dist/Title.js';
@ProxyInputs(['wrappingType', 'level'])
@Component({
  standalone: true,
  selector: 'ui5-title',
  template: '<ng-content></ng-content>',
  inputs: ['wrappingType', 'level'],
})
class TitleComponent {
  /**
     Defines how the text of a component will be displayed when there is not enough space.

**Note:** for option \\"Normal\\" the text will wrap and the words will not be broken based on hyphenation.
    */
  wrappingType!: 'None' | 'Normal';

  /**
     Defines the component level.
Available options are: \`\\"H6\\"\` to \`\\"H1\\"\`.
    */
  level!: 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6';

  private elementRef: ElementRef<Title> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Title {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TitleComponent };
"
`;

exports[`Snapshot test Main Toast should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Toast.js';
import Toast from '@ui5/webcomponents/dist/Toast.js';
@ProxyInputs(['duration', 'placement', 'open'])
@ProxyOutputs(['close: ui5Close'])
@Component({
  standalone: true,
  selector: 'ui5-toast',
  template: '<ng-content></ng-content>',
  inputs: ['duration', 'placement', 'open'],
  outputs: ['ui5Close'],
})
class ToastComponent {
  /**
     Defines the duration in milliseconds for which component
remains on the screen before it's automatically closed.

**Note:** The minimum supported value is \`500\` ms
and even if a lower value is set, the duration would remain \`500\` ms.
    */
  duration!: number;

  /**
     Defines the placement of the component.
    */
  placement!:
    | 'TopStart'
    | 'TopCenter'
    | 'TopEnd'
    | 'MiddleStart'
    | 'MiddleCenter'
    | 'MiddleEnd'
    | 'BottomStart'
    | 'BottomCenter'
    | 'BottomEnd';

  /**
     Indicates whether the component is open (visible).
    */
  open!: boolean;

  /**
     Fired after the component is auto closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Toast> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Toast {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToastComponent };
"
`;

exports[`Snapshot test Main Toggle Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ButtonAccessibilityAttributes } from '@ui5/webcomponents/dist/Button.js';
import '@ui5/webcomponents/dist/ToggleButton.js';
import ToggleButton from '@ui5/webcomponents/dist/ToggleButton.js';
@ProxyInputs([
  'design',
  'disabled',
  'icon',
  'endIcon',
  'submits',
  'tooltip',
  'accessibleName',
  'accessibleNameRef',
  'accessibilityAttributes',
  'type',
  'accessibleRole',
  'pressed',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-toggle-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'design',
    'disabled',
    'icon',
    'endIcon',
    'submits',
    'tooltip',
    'accessibleName',
    'accessibleNameRef',
    'accessibilityAttributes',
    'type',
    'accessibleRole',
    'pressed',
  ],
  outputs: ['ui5Click'],
})
class ToggleButtonComponent {
  /**
     Defines the component design.
    */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';

  /**
     Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Defines the icon, displayed as graphical element within the component.
The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines the icon, displayed as graphical element within the component after the button text.

**Note:** It is highly recommended to use \`endIcon\` property only together with \`icon\` and/or \`text\` properties.
Usage of \`endIcon\` only should be avoided.

The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  endIcon!: string;

  /**
     When set to \`true\`, the component will
automatically submit the nearest HTML form element on \`press\`.

**Note:** This property is only applicable within the context of an HTML Form element.\`
    */
  submits!: boolean;

  /**
     Defines the tooltip of the component.

**Note:** A tooltip attribute should be provided for icon-only buttons, in order to represent their exact meaning/function.
    */
  tooltip!: string;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **expanded**: Indicates whether the button, or another grouping element it controls, is currently expanded or collapsed.
Accepts the following string values: \`true\` or \`false\`

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.

- **controls**: Identifies the element (or elements) whose contents or presence are controlled by the button element.
Accepts a lowercase string value.
    */
  accessibilityAttributes!: ButtonAccessibilityAttributes;

  /**
     Defines whether the button has special form-related functionality.

**Note:** This property is only applicable within the context of an HTML Form element.
    */
  type!: 'Button' | 'Submit' | 'Reset';

  /**
     Describes the accessibility role of the button.

**Note:** Use <code>ButtonAccessibleRole.Link</code> role only with a press handler, which performs a navigation. In all other scenarios the default button semantics are recommended.
    */
  accessibleRole!: 'Button' | 'Link';

  /**
     Determines whether the component is displayed as pressed.
    */
  pressed!: boolean;

  /**
     Fired when the component is activated either with a
mouse/tap or by using the Enter or Space key.

**Note:** The event will not be fired if the \`disabled\`
property is set to \`true\`.
    */
  ui5Click!: EventEmitter<Event>;

  private elementRef: ElementRef<ToggleButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToggleButton {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToggleButtonComponent };
"
`;

exports[`Snapshot test Main Token should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Token.js';
import Token from '@ui5/webcomponents/dist/Token.js';
@ProxyInputs(['text', 'selected'])
@Component({
  standalone: true,
  selector: 'ui5-token',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'selected'],
})
class TokenComponent {
  /**
     Defines the text of the token.
    */
  text!: string;

  /**
     Defines whether the component is selected or not.
    */
  selected!: boolean;

  private elementRef: ElementRef<Token> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Token {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TokenComponent };
"
`;

exports[`Snapshot test Main Tokenizer should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Tokenizer.js';
import {
  default as Tokenizer,
  TokenizerSelectionChangeEventDetail,
  TokenizerTokenDeleteEventDetail,
} from '@ui5/webcomponents/dist/Tokenizer.js';
@ProxyInputs(['readonly', 'disabled', 'accessibleName', 'accessibleNameRef'])
@ProxyOutputs([
  'token-delete: ui5TokenDelete',
  'selection-change: ui5SelectionChange',
])
@Component({
  standalone: true,
  selector: 'ui5-tokenizer',
  template: '<ng-content></ng-content>',
  inputs: ['readonly', 'disabled', 'accessibleName', 'accessibleNameRef'],
  outputs: ['ui5TokenDelete', 'ui5SelectionChange'],
})
class TokenizerComponent {
  /**
     Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
    */
  readonly!: boolean;

  /**
     Defines whether the component is disabled.

**Note:** A disabled component is completely noninteractive.
    */
  disabled!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string | undefined;

  /**
     Fired when tokens are being deleted (delete icon, delete or backspace is pressed)
    */
  ui5TokenDelete!: EventEmitter<TokenizerTokenDeleteEventDetail>;
  /**
     Fired when token selection is changed by user interaction
    */
  ui5SelectionChange!: EventEmitter<TokenizerSelectionChangeEventDetail>;

  private elementRef: ElementRef<Tokenizer> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Tokenizer {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TokenizerComponent };
"
`;

exports[`Snapshot test Main Toolbar Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarButton.js';
import {
  ToolbarAccessibilityAttributes,
  default as ToolbarButton,
} from '@ui5/webcomponents/dist/ToolbarButton.js';
@ProxyInputs([
  'overflowPriority',
  'preventOverflowClosing',
  'disabled',
  'design',
  'icon',
  'endIcon',
  'tooltip',
  'accessibleName',
  'accessibleNameRef',
  'accessibilityAttributes',
  'text',
  'width',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'overflowPriority',
    'preventOverflowClosing',
    'disabled',
    'design',
    'icon',
    'endIcon',
    'tooltip',
    'accessibleName',
    'accessibleNameRef',
    'accessibilityAttributes',
    'text',
    'width',
  ],
  outputs: ['ui5Click'],
})
class ToolbarButtonComponent {
  /**
     Property used to define the access of the item to the overflow Popover. If \\"NeverOverflow\\" option is set,
the item never goes in the Popover, if \\"AlwaysOverflow\\" - it never comes out of it.
    */
  overflowPriority!: 'Default' | 'NeverOverflow' | 'AlwaysOverflow';

  /**
     Defines if the toolbar overflow popup should close upon intereaction with the item.
It will close by default.
    */
  preventOverflowClosing!: boolean;

  /**
     Defines if the action is disabled.

**Note:** a disabled action can't be pressed or focused, and it is not in the tab chain.
    */
  disabled!: boolean;

  /**
     Defines the action design.
    */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';

  /**
     Defines the \`icon\` source URI.

**Note:** SAP-icons font provides numerous buil-in icons. To find all the available icons, see the
[Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  icon!: string;

  /**
     Defines the icon, displayed as graphical element within the component after the button text.

**Note:** It is highly recommended to use \`endIcon\` property only together with \`icon\` and/or \`text\` properties.
Usage of \`endIcon\` only should be avoided.

The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
    */
  endIcon!: string;

  /**
     Defines the tooltip of the component.

**Note:** A tooltip attribute should be provided for icon-only buttons, in order to represent their exact meaning/function.
    */
  tooltip!: string;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string | undefined;

  /**
     Receives id(or many ids) of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Defines the additional accessibility attributes that will be applied to the component.

The following fields are supported:

- **expanded**: Indicates whether the button, or another grouping element it controls, is currently expanded or collapsed.
Accepts the following string values: \`true\` or \`false\`

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.

- **controls**: Identifies the element (or elements) whose contents or presence are controlled by the button element.
Accepts a lowercase string value.
    */
  accessibilityAttributes!: ToolbarAccessibilityAttributes;

  /**
     Button text
    */
  text!: string;

  /**
     Defines the width of the button.

**Note:** all CSS sizes are supported - 'percentage', 'px', 'rem', 'auto', etc.
    */
  width!: string | undefined;

  /**
     Fired when the component is activated either with a
mouse/tap or by using the Enter or Space key.

**Note:** The event will not be fired if the \`disabled\`
property is set to \`true\`.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<ToolbarButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarButton {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarButtonComponent };
"
`;

exports[`Snapshot test Main Toolbar Select Option should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarSelectOption.js';
import ToolbarSelectOption from '@ui5/webcomponents/dist/ToolbarSelectOption.js';
@ProxyInputs(['selected'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-select-option',
  template: '<ng-content></ng-content>',
  inputs: ['selected'],
})
class ToolbarSelectOptionComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  private elementRef: ElementRef<ToolbarSelectOption> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarSelectOption {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarSelectOptionComponent };
"
`;

exports[`Snapshot test Main Toolbar Select should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarSelect.js';
import {
  default as ToolbarSelect,
  ToolbarSelectChangeEventDetail,
} from '@ui5/webcomponents/dist/ToolbarSelect.js';
@ProxyInputs([
  'overflowPriority',
  'preventOverflowClosing',
  'width',
  'valueState',
  'disabled',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs(['change: ui5Change', 'open: ui5Open', 'close: ui5Close'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-select',
  template: '<ng-content></ng-content>',
  inputs: [
    'overflowPriority',
    'preventOverflowClosing',
    'width',
    'valueState',
    'disabled',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change', 'ui5Open', 'ui5Close'],
})
class ToolbarSelectComponent {
  /**
     Property used to define the access of the item to the overflow Popover. If \\"NeverOverflow\\" option is set,
the item never goes in the Popover, if \\"AlwaysOverflow\\" - it never comes out of it.
    */
  overflowPriority!: 'Default' | 'NeverOverflow' | 'AlwaysOverflow';

  /**
     Defines if the toolbar overflow popup should close upon intereaction with the item.
It will close by default.
    */
  preventOverflowClosing!: boolean;

  /**
     Defines the width of the select.

**Note:** all CSS sizes are supported - 'percentage', 'px', 'rem', 'auto', etc.
    */
  width!: string | undefined;

  /**
     Defines the value state of the component.
    */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Defines whether the component is in disabled state.

**Note:** A disabled component is noninteractive.
    */
  disabled!: boolean;

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the select.
    */
  accessibleNameRef!: string;

  /**
     Fired when the selected option changes.
    */
  ui5Change!: EventEmitter<ToolbarSelectChangeEventDetail>;
  /**
     Fired after the component's dropdown menu opens.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the component's dropdown menu closes.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<ToolbarSelect> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarSelect {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarSelectComponent };
"
`;

exports[`Snapshot test Main Toolbar Separator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarSeparator.js';
import ToolbarSeparator from '@ui5/webcomponents/dist/ToolbarSeparator.js';
@ProxyInputs(['overflowPriority', 'preventOverflowClosing'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-separator',
  template: '<ng-content></ng-content>',
  inputs: ['overflowPriority', 'preventOverflowClosing'],
})
class ToolbarSeparatorComponent {
  /**
     Property used to define the access of the item to the overflow Popover. If \\"NeverOverflow\\" option is set,
the item never goes in the Popover, if \\"AlwaysOverflow\\" - it never comes out of it.
    */
  overflowPriority!: 'Default' | 'NeverOverflow' | 'AlwaysOverflow';

  /**
     Defines if the toolbar overflow popup should close upon intereaction with the item.
It will close by default.
    */
  preventOverflowClosing!: boolean;

  private elementRef: ElementRef<ToolbarSeparator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarSeparator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarSeparatorComponent };
"
`;

exports[`Snapshot test Main Toolbar Spacer should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarSpacer.js';
import ToolbarSpacer from '@ui5/webcomponents/dist/ToolbarSpacer.js';
@ProxyInputs(['overflowPriority', 'preventOverflowClosing', 'width'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-spacer',
  template: '<ng-content></ng-content>',
  inputs: ['overflowPriority', 'preventOverflowClosing', 'width'],
})
class ToolbarSpacerComponent {
  /**
     Property used to define the access of the item to the overflow Popover. If \\"NeverOverflow\\" option is set,
the item never goes in the Popover, if \\"AlwaysOverflow\\" - it never comes out of it.
    */
  overflowPriority!: 'Default' | 'NeverOverflow' | 'AlwaysOverflow';

  /**
     Defines if the toolbar overflow popup should close upon intereaction with the item.
It will close by default.
    */
  preventOverflowClosing!: boolean;

  /**
     Defines the width of the spacer.

**Note:** all CSS sizes are supported - 'percentage', 'px', 'rem', 'auto', etc.
    */
  width!: string | undefined;

  private elementRef: ElementRef<ToolbarSpacer> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarSpacer {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarSpacerComponent };
"
`;

exports[`Snapshot test Main Toolbar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Toolbar.js';
import Toolbar from '@ui5/webcomponents/dist/Toolbar.js';
@ProxyInputs(['alignContent', 'accessibleName', 'accessibleNameRef'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar',
  template: '<ng-content></ng-content>',
  inputs: ['alignContent', 'accessibleName', 'accessibleNameRef'],
})
class ToolbarComponent {
  /**
     Indicated the direction in which the Toolbar items will be aligned.
    */
  alignContent!: 'Start' | 'End';

  /**
     Defines the accessible ARIA name of the component.
    */
  accessibleName!: string;

  /**
     Receives id(or many ids) of the elements that label the input.
    */
  accessibleNameRef!: string;

  private elementRef: ElementRef<Toolbar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Toolbar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarComponent };
"
`;

exports[`Snapshot test Main Tree Item Custom should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
import '@ui5/webcomponents/dist/TreeItemCustom.js';
import TreeItemCustom from '@ui5/webcomponents/dist/TreeItemCustom.js';
@ProxyInputs([
  'selected',
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'icon',
  'expanded',
  'movable',
  'indeterminate',
  'hasChildren',
  'additionalTextState',
  'accessibleName',
  'hideSelectionElement',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-tree-item-custom',
  template: '<ng-content></ng-content>',
  inputs: [
    'selected',
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'icon',
    'expanded',
    'movable',
    'indeterminate',
    'hasChildren',
    'additionalTextState',
    'accessibleName',
    'hideSelectionElement',
  ],
  outputs: ['ui5DetailClick'],
})
class TreeItemCustomComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  /**
     Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
    */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
    */
  accessibilityAttributes!: ListItemAccessibilityAttributes;

  /**
     The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
    */
  navigated!: boolean;

  /**
     Defines the text of the tooltip that would be displayed for the list item.
    */
  tooltip!: string;

  /**
     Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
    */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     If set, an icon will be displayed before the text of the tree list item.
    */
  icon!: string;

  /**
     Defines whether the tree list item will show a collapse or expand icon inside its toggle button.
    */
  expanded!: boolean;

  /**
     Defines whether the item is movable.
    */
  movable!: boolean;

  /**
     Defines whether the selection of a tree node is displayed as partially selected.

**Note:** The indeterminate state can be set only programmatically and can’t be achieved by user
interaction, meaning that the resulting visual state depends on the values of the \`indeterminate\`
and \`selected\` properties:

-  If a tree node has both \`selected\` and \`indeterminate\` set to \`true\`, it is displayed as partially selected.
-  If a tree node has \`selected\` set to \`true\` and \`indeterminate\` set to \`false\`, it is displayed as selected.
-  If a tree node has \`selected\` set to \`false\`, it is displayed as not selected regardless of the value of the \`indeterminate\` property.

**Note:** This property takes effect only when the \`ui5-tree\` is in \`Multiple\` mode.
    */
  indeterminate!: boolean;

  /**
     Defines whether the tree node has children, even if currently no other tree nodes are slotted inside.

**Note:** This property is useful for showing big tree structures where not all nodes are initially loaded due to performance reasons.
Set this to \`true\` for nodes you intend to load lazily, when the user clicks the expand button.
It is not necessary to set this property otherwise. If a tree item has children, the expand button will be displayed anyway.
    */
  hasChildren!: boolean;

  /**
     Defines the state of the \`additionalText\`.

Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
    */
  additionalTextState!:
    | 'None'
    | 'Positive'
    | 'Critical'
    | 'Negative'
    | 'Information';

  /**
     Defines the accessible name of the component.
    */
  accessibleName!: string;

  /**
     Defines whether the tree list item should display the selection element.
    */
  hideSelectionElement!: boolean;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<TreeItemCustom> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TreeItemCustom {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TreeItemCustomComponent };
"
`;

exports[`Snapshot test Main Tree Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
import '@ui5/webcomponents/dist/TreeItem.js';
import TreeItem from '@ui5/webcomponents/dist/TreeItem.js';
@ProxyInputs([
  'selected',
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'icon',
  'expanded',
  'movable',
  'indeterminate',
  'hasChildren',
  'additionalTextState',
  'accessibleName',
  'text',
  'additionalText',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-tree-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'selected',
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'icon',
    'expanded',
    'movable',
    'indeterminate',
    'hasChildren',
    'additionalTextState',
    'accessibleName',
    'text',
    'additionalText',
  ],
  outputs: ['ui5DetailClick'],
})
class TreeItemComponent {
  /**
     Defines the selected state of the component.
    */
  selected!: boolean;

  /**
     Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
    */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';

  /**
     Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
    */
  accessibilityAttributes!: ListItemAccessibilityAttributes;

  /**
     The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
    */
  navigated!: boolean;

  /**
     Defines the text of the tooltip that would be displayed for the list item.
    */
  tooltip!: string;

  /**
     Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
    */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     If set, an icon will be displayed before the text of the tree list item.
    */
  icon!: string;

  /**
     Defines whether the tree list item will show a collapse or expand icon inside its toggle button.
    */
  expanded!: boolean;

  /**
     Defines whether the item is movable.
    */
  movable!: boolean;

  /**
     Defines whether the selection of a tree node is displayed as partially selected.

**Note:** The indeterminate state can be set only programmatically and can’t be achieved by user
interaction, meaning that the resulting visual state depends on the values of the \`indeterminate\`
and \`selected\` properties:

-  If a tree node has both \`selected\` and \`indeterminate\` set to \`true\`, it is displayed as partially selected.
-  If a tree node has \`selected\` set to \`true\` and \`indeterminate\` set to \`false\`, it is displayed as selected.
-  If a tree node has \`selected\` set to \`false\`, it is displayed as not selected regardless of the value of the \`indeterminate\` property.

**Note:** This property takes effect only when the \`ui5-tree\` is in \`Multiple\` mode.
    */
  indeterminate!: boolean;

  /**
     Defines whether the tree node has children, even if currently no other tree nodes are slotted inside.

**Note:** This property is useful for showing big tree structures where not all nodes are initially loaded due to performance reasons.
Set this to \`true\` for nodes you intend to load lazily, when the user clicks the expand button.
It is not necessary to set this property otherwise. If a tree item has children, the expand button will be displayed anyway.
    */
  hasChildren!: boolean;

  /**
     Defines the state of the \`additionalText\`.

Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
    */
  additionalTextState!:
    | 'None'
    | 'Positive'
    | 'Critical'
    | 'Negative'
    | 'Information';

  /**
     Defines the accessible name of the component.
    */
  accessibleName!: string;

  /**
     Defines the text of the tree item.
    */
  text!: string;

  /**
     Defines the \`additionalText\`, displayed in the end of the tree item.
    */
  additionalText!: string;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<TreeItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TreeItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TreeItemComponent };
"
`;

exports[`Snapshot test Main Tree should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Tree.js';
import {
  default as Tree,
  TreeItemClickEventDetail,
  TreeItemDeleteEventDetail,
  TreeItemMouseoutEventDetail,
  TreeItemMouseoverEventDetail,
  TreeItemToggleEventDetail,
  TreeSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/Tree.js';
@ProxyInputs([
  'selectionMode',
  'noDataText',
  'headerText',
  'footerText',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs([
  'item-toggle: ui5ItemToggle',
  'item-mouseover: ui5ItemMouseover',
  'item-mouseout: ui5ItemMouseout',
  'item-click: ui5ItemClick',
  'item-delete: ui5ItemDelete',
  'selection-change: ui5SelectionChange',
])
@Component({
  standalone: true,
  selector: 'ui5-tree',
  template: '<ng-content></ng-content>',
  inputs: [
    'selectionMode',
    'noDataText',
    'headerText',
    'footerText',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: [
    'ui5ItemToggle',
    'ui5ItemMouseover',
    'ui5ItemMouseout',
    'ui5ItemClick',
    'ui5ItemDelete',
    'ui5SelectionChange',
  ],
})
class TreeComponent {
  /**
     Defines the selection mode of the component. Since the tree uses a \`ui5-list\` to display its structure,
the tree modes are exactly the same as the list modes, and are all applicable.
    */
  selectionMode!:
    | 'None'
    | 'Single'
    | 'SingleStart'
    | 'SingleEnd'
    | 'SingleAuto'
    | 'Multiple'
    | 'Delete';

  /**
     Defines the text that is displayed when the component contains no items.
    */
  noDataText!: string;

  /**
     Defines the component header text.

**Note:** If the \`header\` slot is set, this property is ignored.
    */
  headerText!: string;

  /**
     Defines the component footer text.
    */
  footerText!: string;

  /**
     Defines the accessible name of the component.
    */
  accessibleName!: string;

  /**
     Defines the IDs of the elements that label the component.
    */
  accessibleNameRef!: string;

  /**
     Fired when a tree item is expanded or collapsed.

**Note:** You can call \`preventDefault()\` on the event object to suppress the event, if needed.
This may be handy for example if you want to dynamically load tree items upon the user expanding a node.
Even if you prevented the event's default behavior, you can always manually call \`toggle()\` on a tree item.
    */
  ui5ItemToggle!: EventEmitter<TreeItemToggleEventDetail>;
  /**
     Fired when the mouse cursor enters the tree item borders.
    */
  ui5ItemMouseover!: EventEmitter<TreeItemMouseoverEventDetail>;
  /**
     Fired when the mouse cursor leaves the tree item borders.
    */
  ui5ItemMouseout!: EventEmitter<TreeItemMouseoutEventDetail>;
  /**
     Fired when a tree item is activated.
    */
  ui5ItemClick!: EventEmitter<TreeItemClickEventDetail>;
  /**
     Fired when the Delete button of any tree item is pressed.

**Note:** A Delete button is displayed on each item,
when the component \`selectionMode\` property is set to \`Delete\`.
    */
  ui5ItemDelete!: EventEmitter<TreeItemDeleteEventDetail>;
  /**
     Fired when selection is changed by user interaction
in \`Single\`, \`SingleStart\`, \`SingleEnd\` and \`Multiple\` modes.
    */
  ui5SelectionChange!: EventEmitter<TreeSelectionChangeEventDetail>;

  private elementRef: ElementRef<Tree> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Tree {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TreeComponent };
"
`;

exports[`Snapshot test Main Ui 5 Main Module Ts should match the snapshot 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { Ui5WebcomponentsMainThemingService } from \\"@ui5/webcomponents-ngx/main/theming\\";
import \\"@ui5/webcomponents/dist/Assets.js\\";
import { AvatarComponent } from \\"@ui5/webcomponents-ngx/main/avatar\\";
import { AvatarGroupComponent } from \\"@ui5/webcomponents-ngx/main/avatar-group\\";
import { BarComponent } from \\"@ui5/webcomponents-ngx/main/bar\\";
import { BreadcrumbsComponent } from \\"@ui5/webcomponents-ngx/main/breadcrumbs\\";
import { BreadcrumbsItemComponent } from \\"@ui5/webcomponents-ngx/main/breadcrumbs-item\\";
import { BusyIndicatorComponent } from \\"@ui5/webcomponents-ngx/main/busy-indicator\\";
import { ButtonComponent } from \\"@ui5/webcomponents-ngx/main/button\\";
import { CalendarComponent } from \\"@ui5/webcomponents-ngx/main/calendar\\";
import { CalendarDateComponent } from \\"@ui5/webcomponents-ngx/main/calendar-date\\";
import { CalendarDateRangeComponent } from \\"@ui5/webcomponents-ngx/main/calendar-date-range\\";
import { CalendarLegendComponent } from \\"@ui5/webcomponents-ngx/main/calendar-legend\\";
import { CalendarLegendItemComponent } from \\"@ui5/webcomponents-ngx/main/calendar-legend-item\\";
import { CardComponent } from \\"@ui5/webcomponents-ngx/main/card\\";
import { CardHeaderComponent } from \\"@ui5/webcomponents-ngx/main/card-header\\";
import { CarouselComponent } from \\"@ui5/webcomponents-ngx/main/carousel\\";
import { CheckBoxComponent } from \\"@ui5/webcomponents-ngx/main/check-box\\";
import { ColorPaletteComponent } from \\"@ui5/webcomponents-ngx/main/color-palette\\";
import { ColorPaletteItemComponent } from \\"@ui5/webcomponents-ngx/main/color-palette-item\\";
import { ColorPalettePopoverComponent } from \\"@ui5/webcomponents-ngx/main/color-palette-popover\\";
import { ColorPickerComponent } from \\"@ui5/webcomponents-ngx/main/color-picker\\";
import { ComboBoxComponent } from \\"@ui5/webcomponents-ngx/main/combo-box\\";
import { ComboBoxItemComponent } from \\"@ui5/webcomponents-ngx/main/combo-box-item\\";
import { ComboBoxItemGroupComponent } from \\"@ui5/webcomponents-ngx/main/combo-box-item-group\\";
import { CustomListItemComponent } from \\"@ui5/webcomponents-ngx/main/custom-list-item\\";
import { DatePickerComponent } from \\"@ui5/webcomponents-ngx/main/date-picker\\";
import { DateRangePickerComponent } from \\"@ui5/webcomponents-ngx/main/date-range-picker\\";
import { DateTimePickerComponent } from \\"@ui5/webcomponents-ngx/main/date-time-picker\\";
import { DialogComponent } from \\"@ui5/webcomponents-ngx/main/dialog\\";
import { FileUploaderComponent } from \\"@ui5/webcomponents-ngx/main/file-uploader\\";
import { FormComponent } from \\"@ui5/webcomponents-ngx/main/form\\";
import { FormGroupComponent } from \\"@ui5/webcomponents-ngx/main/form-group\\";
import { FormItemComponent } from \\"@ui5/webcomponents-ngx/main/form-item\\";
import { IconComponent } from \\"@ui5/webcomponents-ngx/main/icon\\";
import { InputComponent } from \\"@ui5/webcomponents-ngx/main/input\\";
import { LabelComponent } from \\"@ui5/webcomponents-ngx/main/label\\";
import { LinkComponent } from \\"@ui5/webcomponents-ngx/main/link\\";
import { ListComponent } from \\"@ui5/webcomponents-ngx/main/list\\";
import { ListItemGroupComponent } from \\"@ui5/webcomponents-ngx/main/list-item-group\\";
import { MenuComponent } from \\"@ui5/webcomponents-ngx/main/menu\\";
import { MenuItemComponent } from \\"@ui5/webcomponents-ngx/main/menu-item\\";
import { MessageStripComponent } from \\"@ui5/webcomponents-ngx/main/message-strip\\";
import { MultiComboBoxComponent } from \\"@ui5/webcomponents-ngx/main/multi-combo-box\\";
import { MultiComboBoxGroupItemComponent } from \\"@ui5/webcomponents-ngx/main/multi-combo-box-group-item\\";
import { MultiComboBoxItemComponent } from \\"@ui5/webcomponents-ngx/main/multi-combo-box-item\\";
import { MultiInputComponent } from \\"@ui5/webcomponents-ngx/main/multi-input\\";
import { OptionComponent } from \\"@ui5/webcomponents-ngx/main/option\\";
import { OptionCustomComponent } from \\"@ui5/webcomponents-ngx/main/option-custom\\";
import { PanelComponent } from \\"@ui5/webcomponents-ngx/main/panel\\";
import { PopoverComponent } from \\"@ui5/webcomponents-ngx/main/popover\\";
import { ProgressIndicatorComponent } from \\"@ui5/webcomponents-ngx/main/progress-indicator\\";
import { RadioButtonComponent } from \\"@ui5/webcomponents-ngx/main/radio-button\\";
import { RangeSliderComponent } from \\"@ui5/webcomponents-ngx/main/range-slider\\";
import { RatingIndicatorComponent } from \\"@ui5/webcomponents-ngx/main/rating-indicator\\";
import { ResponsivePopoverComponent } from \\"@ui5/webcomponents-ngx/main/responsive-popover\\";
import { SegmentedButtonComponent } from \\"@ui5/webcomponents-ngx/main/segmented-button\\";
import { SegmentedButtonItemComponent } from \\"@ui5/webcomponents-ngx/main/segmented-button-item\\";
import { SelectComponent } from \\"@ui5/webcomponents-ngx/main/select\\";
import { SliderComponent } from \\"@ui5/webcomponents-ngx/main/slider\\";
import { SpecialCalendarDateComponent } from \\"@ui5/webcomponents-ngx/main/special-calendar-date\\";
import { SplitButtonComponent } from \\"@ui5/webcomponents-ngx/main/split-button\\";
import { StandardListItemComponent } from \\"@ui5/webcomponents-ngx/main/standard-list-item\\";
import { StepInputComponent } from \\"@ui5/webcomponents-ngx/main/step-input\\";
import { SuggestionGroupItemComponent } from \\"@ui5/webcomponents-ngx/main/suggestion-group-item\\";
import { SuggestionItemComponent } from \\"@ui5/webcomponents-ngx/main/suggestion-item\\";
import { SwitchComponent } from \\"@ui5/webcomponents-ngx/main/switch\\";
import { TabComponent } from \\"@ui5/webcomponents-ngx/main/tab\\";
import { TabContainerComponent } from \\"@ui5/webcomponents-ngx/main/tab-container\\";
import { TabSeparatorComponent } from \\"@ui5/webcomponents-ngx/main/tab-separator\\";
import { TagComponent } from \\"@ui5/webcomponents-ngx/main/tag\\";
import { TextComponent } from \\"@ui5/webcomponents-ngx/main/text\\";
import { TextAreaComponent } from \\"@ui5/webcomponents-ngx/main/text-area\\";
import { TimePickerComponent } from \\"@ui5/webcomponents-ngx/main/time-picker\\";
import { TitleComponent } from \\"@ui5/webcomponents-ngx/main/title\\";
import { ToastComponent } from \\"@ui5/webcomponents-ngx/main/toast\\";
import { ToggleButtonComponent } from \\"@ui5/webcomponents-ngx/main/toggle-button\\";
import { TokenComponent } from \\"@ui5/webcomponents-ngx/main/token\\";
import { TokenizerComponent } from \\"@ui5/webcomponents-ngx/main/tokenizer\\";
import { ToolbarComponent } from \\"@ui5/webcomponents-ngx/main/toolbar\\";
import { ToolbarButtonComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-button\\";
import { ToolbarSelectComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-select\\";
import { ToolbarSelectOptionComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-select-option\\";
import { ToolbarSeparatorComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-separator\\";
import { ToolbarSpacerComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-spacer\\";
import { TreeComponent } from \\"@ui5/webcomponents-ngx/main/tree\\";
import { TreeItemComponent } from \\"@ui5/webcomponents-ngx/main/tree-item\\";
import { TreeItemCustomComponent } from \\"@ui5/webcomponents-ngx/main/tree-item-custom\\";

const imports = [
  AvatarComponent,
  AvatarGroupComponent,
  BarComponent,
  BreadcrumbsComponent,
  BreadcrumbsItemComponent,
  BusyIndicatorComponent,
  ButtonComponent,
  CalendarComponent,
  CalendarDateComponent,
  CalendarDateRangeComponent,
  CalendarLegendComponent,
  CalendarLegendItemComponent,
  CardComponent,
  CardHeaderComponent,
  CarouselComponent,
  CheckBoxComponent,
  ColorPaletteComponent,
  ColorPaletteItemComponent,
  ColorPalettePopoverComponent,
  ColorPickerComponent,
  ComboBoxComponent,
  ComboBoxItemComponent,
  ComboBoxItemGroupComponent,
  CustomListItemComponent,
  DatePickerComponent,
  DateRangePickerComponent,
  DateTimePickerComponent,
  DialogComponent,
  FileUploaderComponent,
  FormComponent,
  FormGroupComponent,
  FormItemComponent,
  IconComponent,
  InputComponent,
  LabelComponent,
  LinkComponent,
  ListComponent,
  ListItemGroupComponent,
  MenuComponent,
  MenuItemComponent,
  MessageStripComponent,
  MultiComboBoxComponent,
  MultiComboBoxGroupItemComponent,
  MultiComboBoxItemComponent,
  MultiInputComponent,
  OptionComponent,
  OptionCustomComponent,
  PanelComponent,
  PopoverComponent,
  ProgressIndicatorComponent,
  RadioButtonComponent,
  RangeSliderComponent,
  RatingIndicatorComponent,
  ResponsivePopoverComponent,
  SegmentedButtonComponent,
  SegmentedButtonItemComponent,
  SelectComponent,
  SliderComponent,
  SpecialCalendarDateComponent,
  SplitButtonComponent,
  StandardListItemComponent,
  StepInputComponent,
  SuggestionGroupItemComponent,
  SuggestionItemComponent,
  SwitchComponent,
  TabComponent,
  TabContainerComponent,
  TabSeparatorComponent,
  TagComponent,
  TextComponent,
  TextAreaComponent,
  TimePickerComponent,
  TitleComponent,
  ToastComponent,
  ToggleButtonComponent,
  TokenComponent,
  TokenizerComponent,
  ToolbarComponent,
  ToolbarButtonComponent,
  ToolbarSelectComponent,
  ToolbarSelectOptionComponent,
  ToolbarSeparatorComponent,
  ToolbarSpacerComponent,
  TreeComponent,
  TreeItemComponent,
  TreeItemCustomComponent,
];
const exports = [...imports];

@NgModule({
  imports: [...imports],
  exports: [...exports],
})
class Ui5MainModule {
  constructor(
    ui5WebcomponentsMainThemingService: Ui5WebcomponentsMainThemingService,
  ) {}
}
export { Ui5MainModule };
"
`;
