// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`Snapshot test Main Avatar Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/AvatarGroup.js';
import {
  default as AvatarGroup,
  AvatarGroupAccessibilityAttributes,
  AvatarGroupClickEventDetail,
} from '@ui5/webcomponents/dist/AvatarGroup.js';
@ProxyInputs([
  'type',
  'accessibilityAttributes',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs(['click: ui5Click', 'overflow: ui5Overflow'])
@Component({
  standalone: true,
  selector: 'ui5-avatar-group',
  template: '<ng-content></ng-content>',
  inputs: [
    'type',
    'accessibilityAttributes',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Click', 'ui5Overflow'],
  exportAs: 'ui5AvatarGroup',
})
class AvatarGroupComponent {
  /**
        Defines the mode of the \`AvatarGroup\`.
        */
  type!: 'Group' | 'Individual';
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following field is supported:

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.
        */
  accessibilityAttributes!: AvatarGroupAccessibilityAttributes;
  /**
        Defines the accessible name of the AvatarGroup.
When provided, this will override the default aria-label text.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(s) of the elements that describe the AvatarGroup.
When provided, this will be used as aria-labelledby instead of aria-label.
        */
  accessibleNameRef!: string | undefined;

  /**
     Fired when the component is activated either with a
click/tap or by using the Enter or Space key.
    */
  ui5Click!: EventEmitter<AvatarGroupClickEventDetail>;
  /**
     Fired when the count of visible \`ui5-avatar\` elements in the
component has changed
    */
  ui5Overflow!: EventEmitter<void>;

  private elementRef: ElementRef<AvatarGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): AvatarGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { AvatarGroupComponent };
"
`;

exports[`Snapshot test Main Avatar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Avatar.js';
import {
  default as Avatar,
  AvatarAccessibilityAttributes,
} from '@ui5/webcomponents/dist/Avatar.js';
@ProxyInputs([
  'disabled',
  'interactive',
  'icon',
  'fallbackIcon',
  'initials',
  'shape',
  'size',
  'colorScheme',
  'accessibleName',
  'accessibilityAttributes',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-avatar',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'interactive',
    'icon',
    'fallbackIcon',
    'initials',
    'shape',
    'size',
    'colorScheme',
    'accessibleName',
    'accessibilityAttributes',
  ],
  outputs: ['ui5Click'],
  exportAs: 'ui5Avatar',
})
class AvatarComponent {
  /**
        Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines if the avatar is interactive (focusable and pressable).

**Note:** This property won't have effect if the \`disabled\`
property is set to \`true\`.
        */
  @InputDecorator({ transform: booleanAttribute })
  interactive!: boolean;
  /**
        Defines the name of the UI5 Icon, that will be displayed.

**Note:** If \`image\` slot is provided, the property will be ignored.

**Note:** You should import the desired icon first, then use its name as \\"icon\\".

\`import \\"@ui5/webcomponents-icons/dist/{icon_name}.js\\"\`

\`<ui5-avatar icon=\\"employee\\">\`

**Note:** If no icon or an empty one is provided, by default the \\"employee\\" icon should be displayed.

See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines the name of the fallback icon, which should be displayed in the following cases:

	- If the initials are not valid (more than 3 letters, unsupported languages or empty initials).
	- If there are three initials and they do not fit in the shape (e.g. WWW for some of the sizes).
	- If the image src is wrong.

**Note:** If not set, a default fallback icon \\"employee\\" is displayed.

**Note:** You should import the desired icon first, then use its name as \\"fallback-icon\\".

\`import \\"@ui5/webcomponents-icons/dist/{icon_name}.js\\"\`

\`<ui5-avatar fallback-icon=\\"alert\\">\`

See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  fallbackIcon!: string;
  /**
        Defines the displayed initials.

Up to three Latin letters can be displayed as initials.
        */
  initials!: string | undefined;
  /**
        Defines the shape of the component.
        */
  shape!: 'Circle' | 'Square';
  /**
        Defines predefined size of the component.
        */
  size!: 'XS' | 'S' | 'M' | 'L' | 'XL';
  /**
        Defines the background color of the desired image.
If \`colorScheme\` is set to \`Auto\`, the avatar will be displayed with the \`Accent6\` color.
        */
  colorScheme!:
    | 'Auto'
    | 'Accent1'
    | 'Accent2'
    | 'Accent3'
    | 'Accent4'
    | 'Accent5'
    | 'Accent6'
    | 'Accent7'
    | 'Accent8'
    | 'Accent9'
    | 'Accent10'
    | 'Placeholder'
    | 'Transparent';
  /**
        Defines the text alternative of the component.
If not provided a default text alternative will be set, if present.
        */
  accessibleName!: string | undefined;
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following field is supported:

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.
        */
  accessibilityAttributes!: AvatarAccessibilityAttributes;

  /**
     Fired on mouseup, space and enter if avatar is interactive

**Note:** The event will not be fired if the \`disabled\`
property is set to \`true\`.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<Avatar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Avatar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { AvatarComponent };
"
`;

exports[`Snapshot test Main Bar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Bar.js';
import Bar from '@ui5/webcomponents/dist/Bar.js';
@ProxyInputs(['design', 'accessibleRole'])
@Component({
  standalone: true,
  selector: 'ui5-bar',
  template: '<ng-content></ng-content>',
  inputs: ['design', 'accessibleRole'],
  exportAs: 'ui5Bar',
})
class BarComponent {
  /**
        Defines the component's design.
        */
  design!: 'Header' | 'Subheader' | 'Footer' | 'FloatingFooter';
  /**
        Specifies the ARIA role applied to the component for accessibility purposes.

**Note:**

- Set accessibleRole to \\"toolbar\\" only when the component contains two or more active, interactive elements (such as buttons, links, or input fields) within the bar.

- If there is only one or no active element, it is recommended to avoid using the \\"toolbar\\" role, as it implies a grouping of multiple interactive controls.
        */
  accessibleRole!: 'Toolbar' | 'None';

  private elementRef: ElementRef<Bar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Bar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { BarComponent };
"
`;

exports[`Snapshot test Main Breadcrumbs Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/BreadcrumbsItem.js';
import BreadcrumbsItem from '@ui5/webcomponents/dist/BreadcrumbsItem.js';
@ProxyInputs(['href', 'target', 'accessibleName'])
@Component({
  standalone: true,
  selector: 'ui5-breadcrumbs-item',
  template: '<ng-content></ng-content>',
  inputs: ['href', 'target', 'accessibleName'],
  exportAs: 'ui5BreadcrumbsItem',
})
class BreadcrumbsItemComponent {
  /**
        Defines the link href.

**Note:** Standard hyperlink behavior is supported.
        */
  href!: string | undefined;
  /**
        Defines the link target.

Available options are:

- \`_self\`
- \`_top\`
- \`_blank\`
- \`_parent\`
- \`_search\`

**Note:** This property must only be used when the \`href\` property is set.
        */
  target!: string | undefined;
  /**
        Defines the accessible ARIA name of the item.
        */
  accessibleName!: string | undefined;

  private elementRef: ElementRef<BreadcrumbsItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): BreadcrumbsItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { BreadcrumbsItemComponent };
"
`;

exports[`Snapshot test Main Breadcrumbs should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Breadcrumbs.js';
import {
  default as Breadcrumbs,
  BreadcrumbsItemClickEventDetail,
} from '@ui5/webcomponents/dist/Breadcrumbs.js';
@ProxyInputs(['design', 'separators'])
@ProxyOutputs(['item-click: ui5ItemClick'])
@Component({
  standalone: true,
  selector: 'ui5-breadcrumbs',
  template: '<ng-content></ng-content>',
  inputs: ['design', 'separators'],
  outputs: ['ui5ItemClick'],
  exportAs: 'ui5Breadcrumbs',
})
class BreadcrumbsComponent {
  /**
        Defines the visual appearance of the last BreadcrumbsItem.

The Breadcrumbs supports two visual appearances for the last BreadcrumbsItem:
- \\"Standard\\" - displaying the last item as \\"current page\\" (bold and without separator)
- \\"NoCurrentPage\\" - displaying the last item as a regular BreadcrumbsItem, followed by separator
        */
  design!: 'Standard' | 'NoCurrentPage';
  /**
        Determines the visual style of the separator between the breadcrumb items.
        */
  separators!:
    | 'Slash'
    | 'BackSlash'
    | 'DoubleBackSlash'
    | 'DoubleGreaterThan'
    | 'DoubleSlash'
    | 'GreaterThan';

  /**
     Fires when a \`BreadcrumbsItem\` is clicked.

**Note:** You can prevent browser location change by calling \`event.preventDefault()\`.
    */
  ui5ItemClick!: EventEmitter<BreadcrumbsItemClickEventDetail>;

  private elementRef: ElementRef<Breadcrumbs> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Breadcrumbs {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { BreadcrumbsComponent };
"
`;

exports[`Snapshot test Main Busy Indicator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/BusyIndicator.js';
import BusyIndicator from '@ui5/webcomponents/dist/BusyIndicator.js';
@ProxyInputs(['text', 'size', 'active', 'delay', 'textPlacement'])
@Component({
  standalone: true,
  selector: 'ui5-busy-indicator',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'size', 'active', 'delay', 'textPlacement'],
  exportAs: 'ui5BusyIndicator',
})
class BusyIndicatorComponent {
  /**
        Defines text to be displayed below the component. It can be used to inform the user of the current operation.
        */
  text!: string | undefined;
  /**
        Defines the size of the component.
        */
  size!: 'S' | 'M' | 'L';
  /**
        Defines if the busy indicator is visible on the screen. By default it is not.
        */
  @InputDecorator({ transform: booleanAttribute })
  active!: boolean;
  /**
        Defines the delay in milliseconds, after which the busy indicator will be visible on the screen.
        */
  delay!: number;
  /**
        Defines the placement of the text.
        */
  textPlacement!: 'Top' | 'Bottom';

  private elementRef: ElementRef<BusyIndicator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): BusyIndicator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { BusyIndicatorComponent };
"
`;

exports[`Snapshot test Main Button Badge should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ButtonBadge.js';
import ButtonBadge from '@ui5/webcomponents/dist/ButtonBadge.js';
@ProxyInputs(['design', 'text'])
@Component({
  standalone: true,
  selector: 'ui5-button-badge',
  template: '<ng-content></ng-content>',
  inputs: ['design', 'text'],
  exportAs: 'ui5ButtonBadge',
})
class ButtonBadgeComponent {
  /**
        Defines the badge placement and appearance.
- **InlineText** - displayed inside the button after its text, and recommended for **compact** density.
- **OverlayText** - displayed at the top-end corner of the button, and recommended for **cozy** density.
- **AttentionDot** - displayed at the top-end corner of the button as a dot, and suitable for both **cozy** and **compact** densities.
        */
  design!: 'InlineText' | 'OverlayText' | 'AttentionDot';
  /**
        Defines the text of the component.

**Note:** Text is not applied when the \`design\` property is set to \`AttentionDot\`.

**Note:** The badge component only accepts numeric values and the \\"+\\" symbol. Using other characters or formats may result in unpredictable behavior, which is not guaranteed or supported.
        */
  text!: string;

  private elementRef: ElementRef<ButtonBadge> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ButtonBadge {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ButtonBadgeComponent };
"
`;

exports[`Snapshot test Main Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Button.js';
import {
  default as Button,
  ButtonAccessibilityAttributes,
  ButtonClickEventDetail,
} from '@ui5/webcomponents/dist/Button.js';
@ProxyInputs([
  'design',
  'disabled',
  'icon',
  'endIcon',
  'submits',
  'tooltip',
  'accessibleName',
  'accessibleNameRef',
  'accessibilityAttributes',
  'accessibleDescription',
  'type',
  'accessibleRole',
  'loading',
  'loadingDelay',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'design',
    'disabled',
    'icon',
    'endIcon',
    'submits',
    'tooltip',
    'accessibleName',
    'accessibleNameRef',
    'accessibilityAttributes',
    'accessibleDescription',
    'type',
    'accessibleRole',
    'loading',
    'loadingDelay',
  ],
  outputs: ['ui5Click'],
  exportAs: 'ui5Button',
})
class ButtonComponent {
  /**
        Defines the component design.
        */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';
  /**
        Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the icon, displayed as graphical element within the component.
The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines the icon, displayed as graphical element within the component after the button text.

**Note:** It is highly recommended to use \`endIcon\` property only together with \`icon\` and/or \`text\` properties.
Usage of \`endIcon\` only should be avoided.

The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  endIcon!: string | undefined;
  /**
        When set to \`true\`, the component will
automatically submit the nearest HTML form element on \`press\`.

**Note:** This property is only applicable within the context of an HTML Form element.\`
        */
  @InputDecorator({ transform: booleanAttribute })
  submits!: boolean;
  /**
        Defines the tooltip of the component.

**Note:** A tooltip attribute should be provided for icon-only buttons, in order to represent their exact meaning/function.
        */
  tooltip!: string | undefined;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **expanded**: Indicates whether the button, or another grouping element it controls, is currently expanded or collapsed.
Accepts the following string values: \`true\` or \`false\`

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.

- **ariaLabel**: Defines the accessible ARIA name of the component.
Accepts any string value.

 - **ariaKeyShortcuts**: Defines keyboard shortcuts that activate or give focus to the button.

- **controls**: Identifies the element (or elements) whose contents or presence are controlled by the button element.
Accepts a lowercase string value.
        */
  accessibilityAttributes!: ButtonAccessibilityAttributes;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Defines whether the button has special form-related functionality.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  type!: 'Button' | 'Submit' | 'Reset';
  /**
        Describes the accessibility role of the button.

**Note:** Use <code>ButtonAccessibleRole.Link</code> role only with a press handler, which performs a navigation. In all other scenarios the default button semantics are recommended.
        */
  accessibleRole!: 'Button' | 'Link';
  /**
        Defines whether the button shows a loading indicator.

**Note:** If set to \`true\`, a busy indicator component will be displayed on the related button.
        */
  @InputDecorator({ transform: booleanAttribute })
  loading!: boolean;
  /**
        Specifies the delay in milliseconds before the loading indicator appears within the associated button.
        */
  loadingDelay!: number;

  /**
     Fired when the component is activated either with a mouse/tap or by using the Enter or Space key.

**Note:** The event will not be fired if the \`disabled\` property is set to \`true\`.
    */
  ui5Click!: EventEmitter<ButtonClickEventDetail>;

  private elementRef: ElementRef<Button> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Button {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ButtonComponent };
"
`;

exports[`Snapshot test Main Calendar Date Range should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CalendarDateRange.js';
import CalendarDateRange from '@ui5/webcomponents/dist/CalendarDateRange.js';
@ProxyInputs(['startValue', 'endValue'])
@Component({
  standalone: true,
  selector: 'ui5-date-range',
  template: '<ng-content></ng-content>',
  inputs: ['startValue', 'endValue'],
  exportAs: 'ui5DateRange',
})
class CalendarDateRangeComponent {
  /**
        Start of date range formatted according to the \`formatPattern\` property
of the \`ui5-calendar\` that hosts the component.
        */
  startValue!: string;
  /**
        End of date range formatted according to the \`formatPattern\` property
of the \`ui5-calendar\` that hosts the component.
        */
  endValue!: string;

  private elementRef: ElementRef<CalendarDateRange> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CalendarDateRange {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarDateRangeComponent };
"
`;

exports[`Snapshot test Main Calendar Date should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CalendarDate.js';
import CalendarDate from '@ui5/webcomponents/dist/CalendarDate.js';
@ProxyInputs(['value'])
@Component({
  standalone: true,
  selector: 'ui5-date',
  template: '<ng-content></ng-content>',
  inputs: ['value'],
  exportAs: 'ui5Date',
})
class CalendarDateComponent {
  /**
        The date formatted according to the \`formatPattern\` property
of the \`ui5-calendar\` that hosts the component.
        */
  value!: string;

  private elementRef: ElementRef<CalendarDate> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CalendarDate {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarDateComponent };
"
`;

exports[`Snapshot test Main Calendar Legend Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CalendarLegendItem.js';
import CalendarLegendItem from '@ui5/webcomponents/dist/CalendarLegendItem.js';
@ProxyInputs(['text', 'type'])
@Component({
  standalone: true,
  selector: 'ui5-calendar-legend-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'type'],
  exportAs: 'ui5CalendarLegendItem',
})
class CalendarLegendItemComponent {
  /**
        Defines the text content of the Calendar Legend Item.
        */
  text!: string | undefined;
  /**
        Defines the type of the Calendar Legend Item.
        */
  type!:
    | 'None'
    | 'Working'
    | 'NonWorking'
    | 'Type01'
    | 'Type02'
    | 'Type03'
    | 'Type04'
    | 'Type05'
    | 'Type06'
    | 'Type07'
    | 'Type08'
    | 'Type09'
    | 'Type10'
    | 'Type11'
    | 'Type12'
    | 'Type13'
    | 'Type14'
    | 'Type15'
    | 'Type16'
    | 'Type17'
    | 'Type18'
    | 'Type19'
    | 'Type20';

  private elementRef: ElementRef<CalendarLegendItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CalendarLegendItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarLegendItemComponent };
"
`;

exports[`Snapshot test Main Calendar Legend should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CalendarLegend.js';
import CalendarLegend from '@ui5/webcomponents/dist/CalendarLegend.js';
@ProxyInputs([
  'hideToday',
  'hideSelectedDay',
  'hideNonWorkingDay',
  'hideWorkingDay',
])
@Component({
  standalone: true,
  selector: 'ui5-calendar-legend',
  template: '<ng-content></ng-content>',
  inputs: [
    'hideToday',
    'hideSelectedDay',
    'hideNonWorkingDay',
    'hideWorkingDay',
  ],
  exportAs: 'ui5CalendarLegend',
})
class CalendarLegendComponent {
  /**
        Hides the Today item in the legend.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideToday!: boolean;
  /**
        Hides the Selected day item in the legend.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideSelectedDay!: boolean;
  /**
        Hides the Non-Working day item in the legend.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideNonWorkingDay!: boolean;
  /**
        Hides the Working day item in the legend.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideWorkingDay!: boolean;

  private elementRef: ElementRef<CalendarLegend> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CalendarLegend {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarLegendComponent };
"
`;

exports[`Snapshot test Main Calendar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Calendar.js';
import {
  default as Calendar,
  CalendarSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/Calendar.js';
@ProxyInputs([
  'primaryCalendarType',
  'secondaryCalendarType',
  'formatPattern',
  'displayFormat',
  'valueFormat',
  'minDate',
  'maxDate',
  'calendarWeekNumbering',
  'selectionMode',
  'hideWeekNumbers',
])
@ProxyOutputs(['selection-change: ui5SelectionChange'])
@Component({
  standalone: true,
  selector: 'ui5-calendar',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryCalendarType',
    'secondaryCalendarType',
    'formatPattern',
    'displayFormat',
    'valueFormat',
    'minDate',
    'maxDate',
    'calendarWeekNumbering',
    'selectionMode',
    'hideWeekNumbers',
  ],
  outputs: ['ui5SelectionChange'],
  exportAs: 'ui5Calendar',
})
class CalendarComponent {
  /**
        Sets a calendar type used for display.
If not set, the calendar type of the global configuration is used.
        */
  primaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;
  /**
        Defines the secondary calendar type.
If not set, the calendar will only show the primary calendar type.
        */
  secondaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;
  /**
        Determines the format, displayed in the input field.
        */
  formatPattern!: string | undefined;
  /**
        Determines the format, displayed in the input field.
        */
  displayFormat!: string | undefined;
  /**
        Determines the format, used for the value attribute.
        */
  valueFormat!: string | undefined;
  /**
        Determines the minimum date available for selection.

**Note:** If the formatPattern property is not set, the minDate value must be provided in the ISO date format (yyyy-MM-dd).
        */
  minDate!: string;
  /**
        Determines the maximum date available for selection.

**Note:** If the formatPattern property is not set, the maxDate value must be provided in the ISO date format (yyyy-MM-dd).
        */
  maxDate!: string;
  /**
        Defines how to calculate calendar weeks and first day of the week.
If not set, the calendar will be displayed according to the currently set global configuration.
        */
  calendarWeekNumbering!:
    | 'Default'
    | 'ISO_8601'
    | 'MiddleEastern'
    | 'WesternTraditional';
  /**
        Defines the type of selection used in the calendar component.
Accepted property values are:

- \`CalendarSelectionMode.Single\` - enables a single date selection.(default value)
- \`CalendarSelectionMode.Range\` - enables selection of a date range.
- \`CalendarSelectionMode.Multiple\` - enables selection of multiple dates.
        */
  selectionMode!: 'Single' | 'Multiple' | 'Range';
  /**
        Defines the visibility of the week numbers column.

**Note:** For calendars other than Gregorian,
the week numbers are not displayed regardless of what is set.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideWeekNumbers!: boolean;

  /**
     Fired when the selected dates change.

**Note:** If you call \`preventDefault()\` for this event, the component will not
create instances of \`ui5-date\` for the newly selected dates. In that case you should do this manually.
    */
  ui5SelectionChange!: EventEmitter<CalendarSelectionChangeEventDetail>;

  private elementRef: ElementRef<Calendar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Calendar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CalendarComponent };
"
`;

exports[`Snapshot test Main Card Header should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CardHeader.js';
import CardHeader from '@ui5/webcomponents/dist/CardHeader.js';
@ProxyInputs(['titleText', 'subtitleText', 'additionalText', 'interactive'])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-card-header',
  template: '<ng-content></ng-content>',
  inputs: ['titleText', 'subtitleText', 'additionalText', 'interactive'],
  outputs: ['ui5Click'],
  exportAs: 'ui5CardHeader',
})
class CardHeaderComponent {
  /**
        Defines the title text.
        */
  titleText!: string | undefined;
  /**
        Defines the subtitle text.
        */
  subtitleText!: string | undefined;
  /**
        Defines the additional text.
        */
  additionalText!: string | undefined;
  /**
        Defines if the component would be interactive,
e.g gets hover effect and \`click\` event is fired, when pressed.
        */
  @InputDecorator({ transform: booleanAttribute })
  interactive!: boolean;

  /**
     Fired when the component is activated by mouse/tap or by using the Enter or Space key.

**Note:** The event would be fired only if the \`interactive\` property is set to true.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<CardHeader> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): CardHeader {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CardHeaderComponent };
"
`;

exports[`Snapshot test Main Card should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Card.js';
import Card from '@ui5/webcomponents/dist/Card.js';
@ProxyInputs(['accessibleName', 'accessibleNameRef', 'loading', 'loadingDelay'])
@Component({
  standalone: true,
  selector: 'ui5-card',
  template: '<ng-content></ng-content>',
  inputs: ['accessibleName', 'accessibleNameRef', 'loading', 'loadingDelay'],
  exportAs: 'ui5Card',
})
class CardComponent {
  /**
        Defines the accessible name of the component, which is used as the name of the card region and should be unique per card.

**Note:** \`accessibleName\` should be always set, unless \`accessibleNameRef\` is set.
        */
  accessibleName!: string | undefined;
  /**
        Defines the IDs of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines if a loading indicator would be displayed over the card.
        */
  @InputDecorator({ transform: booleanAttribute })
  loading!: boolean;
  /**
        Defines the delay in milliseconds, after which the loading indicator will show up for this card.
        */
  loadingDelay!: number;

  private elementRef: ElementRef<Card> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Card {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CardComponent };
"
`;

exports[`Snapshot test Main Carousel should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Carousel.js';
import {
  default as Carousel,
  CarouselNavigateEventDetail,
} from '@ui5/webcomponents/dist/Carousel.js';
@ProxyInputs([
  'accessibleName',
  'accessibleNameRef',
  'cyclic',
  'itemsPerPage',
  'hideNavigationArrows',
  'hidePageIndicator',
  'pageIndicatorType',
  'backgroundDesign',
  'pageIndicatorBackgroundDesign',
  'pageIndicatorBorderDesign',
  'arrowsPlacement',
])
@ProxyOutputs(['navigate: ui5Navigate'])
@Component({
  standalone: true,
  selector: 'ui5-carousel',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleName',
    'accessibleNameRef',
    'cyclic',
    'itemsPerPage',
    'hideNavigationArrows',
    'hidePageIndicator',
    'pageIndicatorType',
    'backgroundDesign',
    'pageIndicatorBackgroundDesign',
    'pageIndicatorBorderDesign',
    'arrowsPlacement',
  ],
  outputs: ['ui5Navigate'],
  exportAs: 'ui5Carousel',
})
class CarouselComponent {
  /**
        Defines the accessible name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the IDs of the elements that label the input.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines whether the carousel should loop, i.e show the first page after the last page is reached and vice versa.
        */
  @InputDecorator({ transform: booleanAttribute })
  cyclic!: boolean;
  /**
        Defines the number of items per page depending on the carousel width.

- 'S' for screens smaller than 600 pixels.
- 'M' for screens greater than or equal to 600 pixels and smaller than 1024 pixels.
- 'L' for screens greater than or equal to 1024 pixels and smaller than 1440 pixels.
- 'XL' for screens greater than or equal to 1440 pixels.

One item per page is shown by default.
        */
  itemsPerPage!: string;
  /**
        Defines the visibility of the navigation arrows.
If set to true the navigation arrows will be hidden.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideNavigationArrows!: boolean;
  /**
        Defines the visibility of the page indicator.
If set to true the page indicator will be hidden.
        */
  @InputDecorator({ transform: booleanAttribute })
  hidePageIndicator!: boolean;
  /**
        Defines the style of the page indicator.
Available options are:

- \`Default\` - The page indicator will be visualized as dots if there are fewer than 9 pages. If there are more pages, the page indicator will switch to displaying the current page and the total number of pages. (e.g. X of Y)
- \`Numeric\` - The page indicator will display the current page and the total number of pages. (e.g. X of Y)
        */
  pageIndicatorType!: 'Default' | 'Numeric';
  /**
        Defines the carousel's background design.
        */
  backgroundDesign!: 'Solid' | 'Transparent' | 'Translucent';
  /**
        Defines the page indicator background design.
        */
  pageIndicatorBackgroundDesign!: 'Solid' | 'Transparent' | 'Translucent';
  /**
        Defines the page indicator border design.
        */
  pageIndicatorBorderDesign!: 'Solid' | 'None';
  /**
        Defines the position of arrows.

Available options are:

- \`Content\` - the arrows are placed on the sides of the current page.
- \`Navigation\` - the arrows are placed on the sides of the page indicator.
        */
  arrowsPlacement!: 'Content' | 'Navigation';

  /**
     Fired whenever the page changes due to user interaction,
when the user clicks on the navigation arrows or while resizing,
based on the \`items-per-page\` property.
    */
  ui5Navigate!: EventEmitter<CarouselNavigateEventDetail>;

  private elementRef: ElementRef<Carousel> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Carousel {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { CarouselComponent };
"
`;

exports[`Snapshot test Main Check Box should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/CheckBox.js';
import CheckBox from '@ui5/webcomponents/dist/CheckBox.js';
@ProxyInputs([
  'accessibleNameRef',
  'accessibleName',
  'disabled',
  'readonly',
  'displayOnly',
  'required',
  'indeterminate',
  'checked',
  'text',
  'valueState',
  'wrappingType',
  'name',
  'value',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-checkbox',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleNameRef',
    'accessibleName',
    'disabled',
    'readonly',
    'displayOnly',
    'required',
    'indeterminate',
    'checked',
    'text',
    'valueState',
    'wrappingType',
    'name',
    'value',
  ],
  outputs: ['ui5Change'],
  exportAs: 'ui5Checkbox',
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange?.(cvaValue);' },
})
class CheckBoxComponent {
  /**
        Receives id(or many ids) of the elements that label the component
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines whether the component is disabled.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Determines whether the \`ui5-checkbox\` is in display only state.

When set to \`true\`, the \`ui5-checkbox\` is not interactive, not editable, not focusable
and not in the tab chain. This setting is used for forms in review mode.

**Note:** When the property \`disabled\` is set to \`true\` this property has no effect.
        */
  @InputDecorator({ transform: booleanAttribute })
  displayOnly!: boolean;
  /**
        Defines whether the component is required.

**Note:** We advise against using the text property of the checkbox when there is a
label associated with it to avoid having two required asterisks.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines whether the component is displayed as partially checked.

**Note:** The indeterminate state can be set only programmatically and canâ€™t be achieved by user
interaction and the resulting visual state depends on the values of the \`indeterminate\`
and \`checked\` properties:

-  If the component is checked and indeterminate, it will be displayed as partially checked
-  If the component is checked and it is not indeterminate, it will be displayed as checked
-  If the component is not checked, it will be displayed as not checked regardless value of the indeterminate attribute
        */
  @InputDecorator({ transform: booleanAttribute })
  indeterminate!: boolean;
  /**
        Defines if the component is checked.

**Note:** The property can be changed with user interaction,
either by cliking/tapping on the component, or by
pressing the Enter or Space key.
        */
  @InputDecorator({ transform: booleanAttribute })
  checked!: boolean;
  /**
        Defines the text of the component.
        */
  text!: string | undefined;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component text wraps when there is not enough space.

**Note:** for option \\"Normal\\" the text will wrap and the words will not be broken based on hyphenation.
**Note:** for option \\"None\\" the text will be truncated with an ellipsis.
        */
  wrappingType!: 'None' | 'Normal';
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the form value of the component that is submitted when the checkbox is checked.

When a form containing \`ui5-checkbox\` elements is submitted, only the values of the
**checked** checkboxes are included in the form data sent to the server. Unchecked
checkboxes do not contribute any data to the form submission.

This property is particularly useful for **checkbox groups**, where multiple checkboxes with the same \`name\` but different \`value\` properties can be used to represent a set of related options.
        */
  value!: string;

  /**
     Fired when the component checked state changes.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<CheckBox> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): CheckBox {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.checked = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.checked;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { CheckBoxComponent };
"
`;

exports[`Snapshot test Main Color Palette Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ColorPaletteItem.js';
import ColorPaletteItem from '@ui5/webcomponents/dist/ColorPaletteItem.js';
@ProxyInputs(['value', 'selected'])
@Component({
  standalone: true,
  selector: 'ui5-color-palette-item',
  template: '<ng-content></ng-content>',
  inputs: ['value', 'selected'],
  exportAs: 'ui5ColorPaletteItem',
})
class ColorPaletteItemComponent {
  /**
        Defines the colour of the component.

**Note:** The value should be a valid CSS color.
        */
  value!: string;
  /**
        Defines if the component is selected.

**Note:** Only one item must be selected per <code>ui5-color-palette</code>.
If more than one item is defined as selected, the last one would be considered as the selected one.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;

  private elementRef: ElementRef<ColorPaletteItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ColorPaletteItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ColorPaletteItemComponent };
"
`;

exports[`Snapshot test Main Color Palette Popover should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ColorPalettePopover.js';
import {
  default as ColorPalettePopover,
  ColorPalettePopoverItemClickEventDetail,
} from '@ui5/webcomponents/dist/ColorPalettePopover.js';
@ProxyInputs([
  'showRecentColors',
  'showMoreColors',
  'showDefaultColor',
  'defaultColor',
  'open',
  'opener',
])
@ProxyOutputs(['item-click: ui5ItemClick', 'close: ui5Close'])
@Component({
  standalone: true,
  selector: 'ui5-color-palette-popover',
  template: '<ng-content></ng-content>',
  inputs: [
    'showRecentColors',
    'showMoreColors',
    'showDefaultColor',
    'defaultColor',
    'open',
    'opener',
  ],
  outputs: ['ui5ItemClick', 'ui5Close'],
  exportAs: 'ui5ColorPalettePopover',
})
class ColorPalettePopoverComponent {
  /**
        Defines whether the user can see the last used colors in the bottom of the component
        */
  @InputDecorator({ transform: booleanAttribute })
  showRecentColors!: boolean;
  /**
        Defines whether the user can choose a custom color from a component.
        */
  @InputDecorator({ transform: booleanAttribute })
  showMoreColors!: boolean;
  /**
        Defines whether the user can choose the default color from a button.
        */
  @InputDecorator({ transform: booleanAttribute })
  showDefaultColor!: boolean;
  /**
        Defines the default color of the component.

**Note:** The default color should be a part of the ColorPalette colors\`
        */
  defaultColor!: string | undefined;
  /**
        Defines the open | closed state of the popover.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Defines the ID or DOM Reference of the element that the popover is shown at.
When using this attribute in a declarative way, you must only use the \`id\` (as a string) of the element at which you want to show the popover.
You can only set the \`opener\` attribute to a DOM Reference when using JavaScript.
        */
  opener!: HTMLElement | string | null | undefined;

  /**
     Fired when the user selects a color.
    */
  ui5ItemClick!: EventEmitter<ColorPalettePopoverItemClickEventDetail>;
  /**
     Fired when the \`ui5-color-palette-popover\` is closed due to user interaction.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<ColorPalettePopover> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ColorPalettePopover {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ColorPalettePopoverComponent };
"
`;

exports[`Snapshot test Main Color Palette should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ColorPalette.js';
import {
  default as ColorPalette,
  ColorPaletteItemClickEventDetail,
} from '@ui5/webcomponents/dist/ColorPalette.js';

@ProxyOutputs(['item-click: ui5ItemClick'])
@Component({
  standalone: true,
  selector: 'ui5-color-palette',
  template: '<ng-content></ng-content>',
  outputs: ['ui5ItemClick'],
  exportAs: 'ui5ColorPalette',
})
class ColorPaletteComponent {
  /**
     Fired when the user selects a color.
    */
  ui5ItemClick!: EventEmitter<ColorPaletteItemClickEventDetail>;

  private elementRef: ElementRef<ColorPalette> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ColorPalette {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ColorPaletteComponent };
"
`;

exports[`Snapshot test Main Color Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ColorPicker.js';
import ColorPicker from '@ui5/webcomponents/dist/ColorPicker.js';
@ProxyInputs(['value', 'name', 'simplified'])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-color-picker',
  template: '<ng-content></ng-content>',
  inputs: ['value', 'name', 'simplified'],
  outputs: ['ui5Change'],
  exportAs: 'ui5ColorPicker',
})
class ColorPickerComponent {
  /**
        Defines the currently selected color of the component.

**Note**: use HEX, RGB, RGBA, HSV formats or a CSS color name when modifying this property.
        */
  value!: string;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        When set to \`true\`, the alpha slider and inputs for RGB values will not be displayed.
        */
  @InputDecorator({ transform: booleanAttribute })
  simplified!: boolean;

  /**
     Fired when the the selected color is changed
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<ColorPicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ColorPicker {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ColorPickerComponent };
"
`;

exports[`Snapshot test Main Combo Box Item Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ComboBoxItemGroup.js';
import ComboBoxItemGroup from '@ui5/webcomponents/dist/ComboBoxItemGroup.js';
import { ListItemGroupMoveEventDetail } from '@ui5/webcomponents/dist/ListItemGroup.js';
@ProxyInputs(['headerText', 'headerAccessibleName', 'wrappingType'])
@ProxyOutputs(['move-over: ui5MoveOver', 'move: ui5Move'])
@Component({
  standalone: true,
  selector: 'ui5-cb-item-group',
  template: '<ng-content></ng-content>',
  inputs: ['headerText', 'headerAccessibleName', 'wrappingType'],
  outputs: ['ui5MoveOver', 'ui5Move'],
  exportAs: 'ui5CbItemGroup',
})
class ComboBoxItemGroupComponent {
  /**
        Defines the header text of the <code>ui5-li-group</code>.
        */
  headerText!: string | undefined;
  /**
        Defines the accessible name of the header.
        */
  headerAccessibleName!: string | undefined;
  /**
        Defines if the text of the component should wrap when it's too long.
When set to \\"Normal\\", the content (title, description) will be wrapped
using the \`ui5-expandable-text\` component.<br/>

The text can wrap up to 100 characters on small screens (size S) and
up to 300 characters on larger screens (size M and above). When text exceeds
these limits, it truncates with an ellipsis followed by a text expansion trigger.

Available options are:
- \`None\` (default) - The text will truncate with an ellipsis.
- \`Normal\` - The text will wrap (without truncation).
        */
  wrappingType!: 'None' | 'Normal';

  /**
     Fired when a movable list item is moved over a potential drop target during a dragging operation.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5MoveOver!: EventEmitter<ListItemGroupMoveEventDetail>;
  /**
     Fired when a movable list item is dropped onto a drop target.

**Note:** \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.
    */
  ui5Move!: EventEmitter<ListItemGroupMoveEventDetail>;

  private elementRef: ElementRef<ComboBoxItemGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ComboBoxItemGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ComboBoxItemGroupComponent };
"
`;

exports[`Snapshot test Main Combo Box Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ComboBoxItem.js';
import ComboBoxItem from '@ui5/webcomponents/dist/ComboBoxItem.js';
@ProxyInputs(['text', 'additionalText'])
@Component({
  standalone: true,
  selector: 'ui5-cb-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'additionalText'],
  exportAs: 'ui5CbItem',
})
class ComboBoxItemComponent {
  /**
        Defines the text of the component.
        */
  text!: string | undefined;
  /**
        Defines the additional text of the component.
        */
  additionalText!: string | undefined;

  private elementRef: ElementRef<ComboBoxItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ComboBoxItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ComboBoxItemComponent };
"
`;

exports[`Snapshot test Main Combo Box should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ComboBox.js';
import {
  default as ComboBox,
  ComboBoxSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/ComboBox.js';
@ProxyInputs([
  'value',
  'name',
  'noTypeahead',
  'placeholder',
  'disabled',
  'valueState',
  'readonly',
  'required',
  'loading',
  'filter',
  'showClearIcon',
  'accessibleName',
  'accessibleNameRef',
  'open',
])
@ProxyOutputs([
  'change: ui5Change',
  'open: ui5Open',
  'close: ui5Close',
  'input: ui5Input',
  'selection-change: ui5SelectionChange',
])
@Component({
  standalone: true,
  selector: 'ui5-combobox',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'name',
    'noTypeahead',
    'placeholder',
    'disabled',
    'valueState',
    'readonly',
    'required',
    'loading',
    'filter',
    'showClearIcon',
    'accessibleName',
    'accessibleNameRef',
    'open',
  ],
  outputs: [
    'ui5Change',
    'ui5Open',
    'ui5Close',
    'ui5Input',
    'ui5SelectionChange',
  ],
  exportAs: 'ui5Combobox',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class ComboBoxComponent {
  /**
        Defines the value of the component.
        */
  value!: string;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines whether the value will be autocompleted to match an item
        */
  @InputDecorator({ transform: booleanAttribute })
  noTypeahead!: boolean;
  /**
        Defines a short hint intended to aid the user with data entry when the
component has no value.
        */
  placeholder!: string | undefined;
  /**
        Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Indicates whether a loading indicator should be shown in the picker.
        */
  @InputDecorator({ transform: booleanAttribute })
  loading!: boolean;
  /**
        Defines the filter type of the component.
        */
  filter!: 'StartsWithPerTerm' | 'StartsWith' | 'Contains' | 'None';
  /**
        Defines whether the clear icon of the combobox will be shown.
        */
  @InputDecorator({ transform: booleanAttribute })
  showClearIcon!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component
        */
  accessibleNameRef!: string | undefined;
  /**
        Indicates whether the items picker is open.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;

  /**
     Fired when the input operation has finished by pressing Enter, focusout or an item is selected.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the dropdown is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired when the dropdown is closed.
    */
  ui5Close!: EventEmitter<void>;
  /**
     Fired when typing in input or clear icon is pressed.

**Note:** filterValue property is updated, input is changed.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when selection is changed by user interaction
    */
  ui5SelectionChange!: EventEmitter<ComboBoxSelectionChangeEventDetail>;

  private elementRef: ElementRef<ComboBox> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): ComboBox {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { ComboBoxComponent };
"
`;

exports[`Snapshot test Main DS Store should match the snapshot 1`] = `
"   Bud1                                                                      i n gbwspbl                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          @      ï¿½                                        @      ï¿½                                          @      ï¿½                                          @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  t h e m i n gbwspblob   ï¿½bplist00ï¿½]ShowStatusBar[ShowToolbar[ShowTabView_ContainerShowSidebar\\\\WindowBounds[ShowSidebar		_{{500, 459}, {920, 436}}	#/;R_klmnoï¿½             
               ï¿½    t h e m i n glsvCblob  Sbplist00ï¿½	

WXYZ[_viewOptionsVersion_showIconPreviewWcolumns_calculateAllSizes_scrollPositionYXtextSize_scrollPositionXZsortColumnXiconSize_useRelativeDates               	ï¿½$(-27<@EIMQï¿½ZidentifierYascendingUwidthWvisibleTname	,	ï¿½UwidthYascendingWvisibleXubiquity#ï¿½ \\"\\\\dateModifiedï¿½	ï¿½%\\"[dateCreatedï¿½)+Tsizea	ï¿½.0Tkind	s	ï¿½35Ulabel	dï¿½8:Wversion	Kï¿½=Xcomments	ï¿½AC^dateLastOpenedï¿½ï¿½FCZshareOwnerï¿½JC_shareLastEditorï¿½N\\"YdateAddedï¿½SUï¿½_invitationStatus#        #@*      #ï¿½bï¿½     Tname#@0      	   2 D L \` r { ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
$,5789BOPRS\\\\hijsxy{|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\\",-.78:;NOXajox             ]              y    t h e m i n glsvpblob  ï¿½bplist00ï¿½	

GHIJK_viewOptionsVersion_showIconPreviewWcolumns_calculateAllSizes_scrollPositionYXtextSize_scrollPositionXZsortColumnXiconSize_useRelativeDates               	ï¿½ %*/48=AXcommentsUlabelWversion[dateCreatedTsize\\\\dateModifiedTkindTname^dateLastOpenedï¿½WvisibleYascendingUwidthUindex	,ï¿½#$	dï¿½()	Kï¿½-.ï¿½ï¿½23	aï¿½-7	ï¿½;<		sï¿½@		 ï¿½DEï¿½#        #@*      #ï¿½bï¿½     Tname#@0      	   2 D L \` r { ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½'08BHNOPSU^_\`bdmnoqs|}~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½             M              ï¿½    t h e m i n gvSrnlong                                                                                                                                                                                                                      E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 \`          ï¿½                                        @      ï¿½                                          @      ï¿½                                          @       XZsortColumnXiconSize_useRelativeDates               	ï¿½ %*/48=AXcommentsUlabelWversion[dateCreatedTsize\\\\dateModifiedTkindTname^dateLastOpenedï¿½WvisibleYascendingUwidthUindex	,ï¿½#$	dï¿½()	Kï¿½-.ï¿½ï¿½23	aï¿½-7	ï¿½;<		sï¿½@		 ï¿½DEï¿½#        #@*      #ï¿½bï¿½     Tname#@0      	   2 D L \` r { ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½'08BHNOPSU^_\`bdmnoqs|}~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½             M              ï¿½    t h e m i n gvSrnlong                                                                                                                                                                                                          "
`;

exports[`Snapshot test Main Date Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/DatePicker.js';
import {
  default as DatePicker,
  DatePickerChangeEventDetail,
  DatePickerInputEventDetail,
  DatePickerValueStateChangeEventDetail,
} from '@ui5/webcomponents/dist/DatePicker.js';
@ProxyInputs([
  'primaryCalendarType',
  'secondaryCalendarType',
  'formatPattern',
  'displayFormat',
  'valueFormat',
  'minDate',
  'maxDate',
  'calendarWeekNumbering',
  'value',
  'valueState',
  'required',
  'disabled',
  'readonly',
  'placeholder',
  'name',
  'hideWeekNumbers',
  'open',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'value-state-change: ui5ValueStateChange',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-date-picker',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryCalendarType',
    'secondaryCalendarType',
    'formatPattern',
    'displayFormat',
    'valueFormat',
    'minDate',
    'maxDate',
    'calendarWeekNumbering',
    'value',
    'valueState',
    'required',
    'disabled',
    'readonly',
    'placeholder',
    'name',
    'hideWeekNumbers',
    'open',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
  ],
  outputs: [
    'ui5Change',
    'ui5Input',
    'ui5ValueStateChange',
    'ui5Open',
    'ui5Close',
  ],
  exportAs: 'ui5DatePicker',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class DatePickerComponent {
  /**
        Sets a calendar type used for display.
If not set, the calendar type of the global configuration is used.
        */
  primaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;
  /**
        Defines the secondary calendar type.
If not set, the calendar will only show the primary calendar type.
        */
  secondaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;
  /**
        Determines the format, displayed in the input field.
        */
  formatPattern!: string | undefined;
  /**
        Determines the format, displayed in the input field.
        */
  displayFormat!: string | undefined;
  /**
        Determines the format, used for the value attribute.
        */
  valueFormat!: string | undefined;
  /**
        Determines the minimum date available for selection.

**Note:** If the formatPattern property is not set, the minDate value must be provided in the ISO date format (yyyy-MM-dd).
        */
  minDate!: string;
  /**
        Determines the maximum date available for selection.

**Note:** If the formatPattern property is not set, the maxDate value must be provided in the ISO date format (yyyy-MM-dd).
        */
  maxDate!: string;
  /**
        Defines how to calculate calendar weeks and first day of the week.
If not set, the calendar will be displayed according to the currently set global configuration.
        */
  calendarWeekNumbering!:
    | 'Default'
    | 'ISO_8601'
    | 'MiddleEastern'
    | 'WesternTraditional';
  /**
        Defines a formatted date value.
        */
  value!: string;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Determines whether the component is displayed as disabled.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Determines whether the component is displayed as read-only.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
        */
  placeholder!: string | undefined;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the visibility of the week numbers column.

**Note:** For calendars other than Gregorian,
the week numbers are not displayed regardless of what is set.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideWeekNumbers!: boolean;
  /**
        Defines the open or closed state of the popover.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Defines the aria-label attribute for the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the input.
        */
  accessibleDescriptionRef!: string | undefined;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<DatePickerChangeEventDetail>;
  /**
     Fired when the value of the component is changed at each key stroke.
    */
  ui5Input!: EventEmitter<DatePickerInputEventDetail>;
  /**
     Fired before the value state of the component is updated internally.
The event is preventable, meaning that if it's default action is
prevented, the component will not update the value state.
    */
  ui5ValueStateChange!: EventEmitter<DatePickerValueStateChangeEventDetail>;
  /**
     Fired after the component's picker is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the component's picker is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<DatePicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): DatePicker {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { DatePickerComponent };
"
`;

exports[`Snapshot test Main Date Range Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import {
  DatePickerChangeEventDetail,
  DatePickerInputEventDetail,
  DatePickerValueStateChangeEventDetail,
} from '@ui5/webcomponents/dist/DatePicker.js';
import '@ui5/webcomponents/dist/DateRangePicker.js';
import DateRangePicker from '@ui5/webcomponents/dist/DateRangePicker.js';
@ProxyInputs([
  'primaryCalendarType',
  'secondaryCalendarType',
  'formatPattern',
  'displayFormat',
  'valueFormat',
  'minDate',
  'maxDate',
  'calendarWeekNumbering',
  'value',
  'valueState',
  'required',
  'disabled',
  'readonly',
  'placeholder',
  'name',
  'hideWeekNumbers',
  'open',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'delimiter',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'value-state-change: ui5ValueStateChange',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-daterange-picker',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryCalendarType',
    'secondaryCalendarType',
    'formatPattern',
    'displayFormat',
    'valueFormat',
    'minDate',
    'maxDate',
    'calendarWeekNumbering',
    'value',
    'valueState',
    'required',
    'disabled',
    'readonly',
    'placeholder',
    'name',
    'hideWeekNumbers',
    'open',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'delimiter',
  ],
  outputs: [
    'ui5Change',
    'ui5Input',
    'ui5ValueStateChange',
    'ui5Open',
    'ui5Close',
  ],
  exportAs: 'ui5DaterangePicker',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class DateRangePickerComponent {
  /**
        Sets a calendar type used for display.
If not set, the calendar type of the global configuration is used.
        */
  primaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;
  /**
        Defines the secondary calendar type.
If not set, the calendar will only show the primary calendar type.
        */
  secondaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;
  /**
        Determines the format, displayed in the input field.
        */
  formatPattern!: string | undefined;
  /**
        Determines the format, displayed in the input field.
        */
  displayFormat!: string | undefined;
  /**
        Determines the format, used for the value attribute.
        */
  valueFormat!: string | undefined;
  /**
        Determines the minimum date available for selection.

**Note:** If the formatPattern property is not set, the minDate value must be provided in the ISO date format (yyyy-MM-dd).
        */
  minDate!: string;
  /**
        Determines the maximum date available for selection.

**Note:** If the formatPattern property is not set, the maxDate value must be provided in the ISO date format (yyyy-MM-dd).
        */
  maxDate!: string;
  /**
        Defines how to calculate calendar weeks and first day of the week.
If not set, the calendar will be displayed according to the currently set global configuration.
        */
  calendarWeekNumbering!:
    | 'Default'
    | 'ISO_8601'
    | 'MiddleEastern'
    | 'WesternTraditional';
  /**
        Defines a formatted date value.
        */
  value!: string;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Determines whether the component is displayed as disabled.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Determines whether the component is displayed as read-only.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
        */
  placeholder!: string | undefined;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the visibility of the week numbers column.

**Note:** For calendars other than Gregorian,
the week numbers are not displayed regardless of what is set.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideWeekNumbers!: boolean;
  /**
        Defines the open or closed state of the popover.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Defines the aria-label attribute for the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the input.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Determines the symbol which separates the dates.
If not supplied, the default time interval delimiter for the current locale will be used.
        */
  delimiter!: string;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<DatePickerChangeEventDetail>;
  /**
     Fired when the value of the component is changed at each key stroke.
    */
  ui5Input!: EventEmitter<DatePickerInputEventDetail>;
  /**
     Fired before the value state of the component is updated internally.
The event is preventable, meaning that if it's default action is
prevented, the component will not update the value state.
    */
  ui5ValueStateChange!: EventEmitter<DatePickerValueStateChangeEventDetail>;
  /**
     Fired after the component's picker is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the component's picker is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<DateRangePicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): DateRangePicker {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { DateRangePickerComponent };
"
`;

exports[`Snapshot test Main Date Time Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import {
  DatePickerChangeEventDetail,
  DatePickerInputEventDetail,
  DatePickerValueStateChangeEventDetail,
} from '@ui5/webcomponents/dist/DatePicker.js';
import '@ui5/webcomponents/dist/DateTimePicker.js';
import DateTimePicker from '@ui5/webcomponents/dist/DateTimePicker.js';
@ProxyInputs([
  'primaryCalendarType',
  'secondaryCalendarType',
  'formatPattern',
  'displayFormat',
  'valueFormat',
  'minDate',
  'maxDate',
  'calendarWeekNumbering',
  'value',
  'valueState',
  'required',
  'disabled',
  'readonly',
  'placeholder',
  'name',
  'hideWeekNumbers',
  'open',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'value-state-change: ui5ValueStateChange',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-datetime-picker',
  template: '<ng-content></ng-content>',
  inputs: [
    'primaryCalendarType',
    'secondaryCalendarType',
    'formatPattern',
    'displayFormat',
    'valueFormat',
    'minDate',
    'maxDate',
    'calendarWeekNumbering',
    'value',
    'valueState',
    'required',
    'disabled',
    'readonly',
    'placeholder',
    'name',
    'hideWeekNumbers',
    'open',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
  ],
  outputs: [
    'ui5Change',
    'ui5Input',
    'ui5ValueStateChange',
    'ui5Open',
    'ui5Close',
  ],
  exportAs: 'ui5DatetimePicker',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class DateTimePickerComponent {
  /**
        Sets a calendar type used for display.
If not set, the calendar type of the global configuration is used.
        */
  primaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;
  /**
        Defines the secondary calendar type.
If not set, the calendar will only show the primary calendar type.
        */
  secondaryCalendarType!:
    | 'Gregorian'
    | 'Islamic'
    | 'Japanese'
    | 'Buddhist'
    | 'Persian'
    | undefined;
  /**
        Determines the format, displayed in the input field.
        */
  formatPattern!: string | undefined;
  /**
        Determines the format, displayed in the input field.
        */
  displayFormat!: string | undefined;
  /**
        Determines the format, used for the value attribute.
        */
  valueFormat!: string | undefined;
  /**
        Determines the minimum date available for selection.

**Note:** If the formatPattern property is not set, the minDate value must be provided in the ISO date format (yyyy-MM-dd).
        */
  minDate!: string;
  /**
        Determines the maximum date available for selection.

**Note:** If the formatPattern property is not set, the maxDate value must be provided in the ISO date format (yyyy-MM-dd).
        */
  maxDate!: string;
  /**
        Defines how to calculate calendar weeks and first day of the week.
If not set, the calendar will be displayed according to the currently set global configuration.
        */
  calendarWeekNumbering!:
    | 'Default'
    | 'ISO_8601'
    | 'MiddleEastern'
    | 'WesternTraditional';
  /**
        Defines a formatted date value.
        */
  value!: string;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Determines whether the component is displayed as disabled.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Determines whether the component is displayed as read-only.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
        */
  placeholder!: string | undefined;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the visibility of the week numbers column.

**Note:** For calendars other than Gregorian,
the week numbers are not displayed regardless of what is set.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideWeekNumbers!: boolean;
  /**
        Defines the open or closed state of the popover.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Defines the aria-label attribute for the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the input.
        */
  accessibleDescriptionRef!: string | undefined;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<DatePickerChangeEventDetail>;
  /**
     Fired when the value of the component is changed at each key stroke.
    */
  ui5Input!: EventEmitter<DatePickerInputEventDetail>;
  /**
     Fired before the value state of the component is updated internally.
The event is preventable, meaning that if it's default action is
prevented, the component will not update the value state.
    */
  ui5ValueStateChange!: EventEmitter<DatePickerValueStateChangeEventDetail>;
  /**
     Fired after the component's picker is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the component's picker is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<DateTimePicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): DateTimePicker {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { DateTimePickerComponent };
"
`;

exports[`Snapshot test Main Dialog should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Dialog.js';
import Dialog from '@ui5/webcomponents/dist/Dialog.js';
import { PopupBeforeCloseEventDetail } from '@ui5/webcomponents/dist/Popup.js';
@ProxyInputs([
  'initialFocus',
  'preventFocusRestore',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'preventInitialFocus',
  'open',
  'headerText',
  'stretch',
  'draggable',
  'resizable',
  'state',
])
@ProxyOutputs([
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-dialog',
  template: '<ng-content></ng-content>',
  inputs: [
    'initialFocus',
    'preventFocusRestore',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'preventInitialFocus',
    'open',
    'headerText',
    'stretch',
    'draggable',
    'resizable',
    'state',
  ],
  outputs: ['ui5BeforeOpen', 'ui5Open', 'ui5BeforeClose', 'ui5Close'],
  exportAs: 'ui5Dialog',
})
class DialogComponent {
  /**
        Defines the ID of the HTML Element, which will get the initial focus.

**Note:** If an element with \`autofocus\` attribute is added inside the component,
\`initialFocus\` won't take effect.
        */
  initialFocus!: string | undefined;
  /**
        Defines if the focus should be returned to the previously focused element,
when the popup closes.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventFocusRestore!: boolean;
  /**
        Defines the accessible name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the IDs of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Allows setting a custom role.
        */
  accessibleRole!: 'None' | 'Dialog' | 'AlertDialog';
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the component.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Indicates whether initial focus should be prevented.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventInitialFocus!: boolean;
  /**
        Indicates if the element is open
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Defines the header text.

**Note:** If \`header\` slot is provided, the \`headerText\` is ignored.
        */
  headerText!: string | undefined;
  /**
        Determines if the dialog will be stretched to full screen on mobile. On desktop,
the dialog will be stretched to approximately 90% of the viewport.

**Note:** For better usability of the component it is recommended to set this property to \\"true\\" when the dialog is opened on phone.
        */
  @InputDecorator({ transform: booleanAttribute })
  stretch!: boolean;
  /**
        Determines whether the component is draggable.
If this property is set to true, the Dialog will be draggable by its header.

**Note:** The component can be draggable only in desktop mode.

**Note:** This property overrides the default HTML \\"draggable\\" attribute native behavior.
When \\"draggable\\" is set to true, the native browser \\"draggable\\"
behavior is prevented and only the Dialog custom logic (\\"draggable by its header\\") works.
        */
  @InputDecorator({ transform: booleanAttribute })
  draggable!: boolean;
  /**
        Configures the component to be resizable.
If this property is set to true, the Dialog will have a resize handle in its bottom right corner in LTR languages.
In RTL languages, the resize handle will be placed in the bottom left corner.

**Note:** The component can be resizable only in desktop mode.

**Note:** Upon resizing, externally defined height and width styling will be ignored.
        */
  @InputDecorator({ transform: booleanAttribute })
  resizable!: boolean;
  /**
        Defines the state of the \`Dialog\`.

**Note:** If \`\\"Negative\\"\` and \`\\"Critical\\"\` states is set, it will change the
accessibility role to \\"alertdialog\\", if the accessibleRole property is set to \`\\"Dialog\\"\`.
        */
  state!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  /**
     Fired before the component is opened. This event can be cancelled, which will prevent the popup from opening.
    */
  ui5BeforeOpen!: EventEmitter<void>;
  /**
     Fired after the component is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the component is closed. This event can be cancelled, which will prevent the popup from closing.
    */
  ui5BeforeClose!: EventEmitter<PopupBeforeCloseEventDetail>;
  /**
     Fired after the component is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Dialog> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Dialog {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { DialogComponent };
"
`;

exports[`Snapshot test Main Dynamic Date Range should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/DynamicDateRange.js';
import {
  default as DynamicDateRange,
  DynamicDateRangeValue,
} from '@ui5/webcomponents/dist/DynamicDateRange.js';
@ProxyInputs(['value', 'options'])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-dynamic-date-range',
  template: '<ng-content></ng-content>',
  inputs: ['value', 'options'],
  outputs: ['ui5Change'],
  exportAs: 'ui5DynamicDateRange',
})
class DynamicDateRangeComponent {
  /**
        Defines the value object.
        */
  value!: DynamicDateRangeValue | undefined;
  /**
        Defines the options listed as a string, separated by commas and using capital case.
Example: \\"TODAY, YESTERDAY, DATERANGE\\"
        */
  options!: string;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout or a value is selected in the popover.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<DynamicDateRange> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): DynamicDateRange {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { DynamicDateRangeComponent };
"
`;

exports[`Snapshot test Main Expandable Text should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ExpandableText.js';
import ExpandableText from '@ui5/webcomponents/dist/ExpandableText.js';
@ProxyInputs(['text', 'maxCharacters', 'overflowMode', 'emptyIndicatorMode'])
@Component({
  standalone: true,
  selector: 'ui5-expandable-text',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'maxCharacters', 'overflowMode', 'emptyIndicatorMode'],
  exportAs: 'ui5ExpandableText',
})
class ExpandableTextComponent {
  /**
        Text of the component.
        */
  text!: string | undefined;
  /**
        Maximum number of characters to be displayed initially. If the text length exceeds this limit, the text will be truncated with an ellipsis, and the \\"More\\" link will be displayed.
        */
  maxCharacters!: number;
  /**
        Determines how the full text will be displayed.
        */
  overflowMode!: 'InPlace' | 'Popover';
  /**
        Specifies if an empty indicator should be displayed when there is no text.
        */
  emptyIndicatorMode!: 'Off' | 'On';

  private elementRef: ElementRef<ExpandableText> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ExpandableText {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ExpandableTextComponent };
"
`;

exports[`Snapshot test Main File Uploader should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/FileUploader.js';
import {
  default as FileUploader,
  FileUploaderChangeEventDetail,
  FileUploaderFileSizeExceedEventDetail,
} from '@ui5/webcomponents/dist/FileUploader.js';
@ProxyInputs([
  'accept',
  'hideInput',
  'disabled',
  'multiple',
  'name',
  'placeholder',
  'value',
  'maxFileSize',
  'valueState',
  'required',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
])
@ProxyOutputs(['change: ui5Change', 'file-size-exceed: ui5FileSizeExceed'])
@Component({
  standalone: true,
  selector: 'ui5-file-uploader',
  template: '<ng-content></ng-content>',
  inputs: [
    'accept',
    'hideInput',
    'disabled',
    'multiple',
    'name',
    'placeholder',
    'value',
    'maxFileSize',
    'valueState',
    'required',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
  ],
  outputs: ['ui5Change', 'ui5FileSizeExceed'],
  exportAs: 'ui5FileUploader',
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange?.(cvaValue);' },
})
class FileUploaderComponent {
  /**
        Comma-separated list of file types that the component should accept.

**Note:** Please make sure you are adding the \`.\` in front on the file type, e.g. \`.png\` in case you want to accept png's only.
        */
  accept!: string | undefined;
  /**
        If set to \\"true\\", the input field of component will not be rendered. Only the default slot that is passed will be rendered.

**Note:** Use this property in combination with the default slot to achieve a button-only file uploader design.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideInput!: boolean;
  /**
        Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Allows multiple files to be chosen.
        */
  @InputDecorator({ transform: booleanAttribute })
  multiple!: boolean;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines a short hint intended to aid the user with data entry when the component has no value.
        */
  placeholder!: string | undefined;
  /**
        Defines the name/names of the file/files to upload.
        */
  value!: string;
  /**
        Defines the maximum file size in megabytes which prevents the upload if at least one file exceeds it.
        */
  maxFileSize!: number | undefined;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the input.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the input.
        */
  accessibleDescriptionRef!: string | undefined;

  /**
     Event is fired when the value of the file path has been changed.

**Note:** Keep in mind that because of the HTML input element of type file, the event is also fired in Chrome browser when the Cancel button of the uploads window is pressed.
    */
  ui5Change!: EventEmitter<FileUploaderChangeEventDetail>;
  /**
     Event is fired when the size of a file is above the \`maxFileSize\` property value.
    */
  ui5FileSizeExceed!: EventEmitter<FileUploaderFileSizeExceedEventDetail>;

  private elementRef: ElementRef<FileUploader> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): FileUploader {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { FileUploaderComponent };
"
`;

exports[`Snapshot test Main Form Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/FormGroup.js';
import FormGroup from '@ui5/webcomponents/dist/FormGroup.js';
@ProxyInputs(['headerText', 'headerLevel', 'columnSpan'])
@Component({
  standalone: true,
  selector: 'ui5-form-group',
  template: '<ng-content></ng-content>',
  inputs: ['headerText', 'headerLevel', 'columnSpan'],
  exportAs: 'ui5FormGroup',
})
class FormGroupComponent {
  /**
        Defines header text of the component.
        */
  headerText!: string | undefined;
  /**
        Defines the compoennt heading level,
set by the \`headerText\`.
        */
  headerLevel!: 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6';
  /**
        Defines column span of the component,
e.g how many columns the group should span to.
        */
  columnSpan!: number | undefined;

  private elementRef: ElementRef<FormGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): FormGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { FormGroupComponent };
"
`;

exports[`Snapshot test Main Form Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/FormItem.js';
import FormItem from '@ui5/webcomponents/dist/FormItem.js';
@ProxyInputs(['columnSpan'])
@Component({
  standalone: true,
  selector: 'ui5-form-item',
  template: '<ng-content></ng-content>',
  inputs: ['columnSpan'],
  exportAs: 'ui5FormItem',
})
class FormItemComponent {
  /**
        Defines the column span of the component,
e.g how many columns the component should span to.

**Note:** The column span should be a number between 1 and the available columns of the FormGroup (when items are placed in a group)
or the Form. The available columns can be affected by the FormGroup#columnSpan and/or the Form#layout.
A number bigger than the available columns won't take effect.
        */
  columnSpan!: number | undefined;

  private elementRef: ElementRef<FormItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): FormItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { FormItemComponent };
"
`;

exports[`Snapshot test Main Form should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Form.js';
import Form from '@ui5/webcomponents/dist/Form.js';
@ProxyInputs([
  'accessibleName',
  'layout',
  'labelSpan',
  'emptySpan',
  'headerText',
  'headerLevel',
  'itemSpacing',
])
@Component({
  standalone: true,
  selector: 'ui5-form',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleName',
    'layout',
    'labelSpan',
    'emptySpan',
    'headerText',
    'headerLevel',
    'itemSpacing',
  ],
  exportAs: 'ui5Form',
})
class FormComponent {
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the number of columns to distribute the form content by breakpoint.

Supported values:
- \`S\` - 1 column by default (1 column is recommended)
- \`M\` - 1 column by default (up to 2 columns are recommended)
- \`L\` - 2 columns by default (up to 3 columns are recommended)
- \`XL\` - 3 columns by default (up to 6 columns  are recommended)
        */
  layout!: string;
  /**
        Defines the width proportion of the labels and fields of a form item by breakpoint.

By default, the labels take 4/12 (or 1/3) of the form item in M,L and XL sizes,
and 12/12 in S size, e.g in S the label is on top of its associated field.

The supported values are between 1 and 12. Greater the number, more space the label will use.

**Note:** If \\"12\\" is set, the label will be displayed on top of its assosiated field.
        */
  labelSpan!: string;
  /**
        Defines the number of cells that are empty at the end of each form item, configurable by breakpoint.

By default, a form item spans 12 cells, fully divided between its label (4 cells) and field (8 cells), with no empty space at the end.
The \`emptySpan\` provides additional layout flexibility by defining empty space at the form itemâ€™s end.

**Note:**
- The maximum allowable empty space is 10 cells. At least 1 cell each must remain for the label and the field.
- When \`emptySpan\` is specified (greater than 0), ensure that the combined value of \`emptySpan\` and \`labelSpan\` does not exceed 11. This guarantees a minimum of 1 cell for the field.
        */
  emptySpan!: string;
  /**
        Defines the header text of the component.

**Note:** The property gets overridden by the \`header\` slot.
        */
  headerText!: string | undefined;
  /**
        Defines the compoennt heading level,
set by the \`headerText\`.
        */
  headerLevel!: 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6';
  /**
        Defines the vertical spacing between form items.

**Note:** If the Form is meant to be switched between \\"non-edit\\" and \\"edit\\" modes,
we recommend using \\"Large\\" item spacing in \\"non-edit\\" mode, and \\"Normal\\" - for \\"edit\\" mode,
to avoid \\"jumping\\" effect, caused by the hight difference between texts in \\"non-edit\\" mode and the input fields in \\"edit\\" mode.
        */
  itemSpacing!: 'Normal' | 'Large';

  private elementRef: ElementRef<Form> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Form {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { FormComponent };
"
`;

exports[`Snapshot test Main Icon should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Icon.js';
import Icon from '@ui5/webcomponents/dist/Icon.js';
@ProxyInputs(['design', 'name', 'accessibleName', 'showTooltip', 'mode'])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-icon',
  template: '<ng-content></ng-content>',
  inputs: ['design', 'name', 'accessibleName', 'showTooltip', 'mode'],
  outputs: ['ui5Click'],
  exportAs: 'ui5Icon',
})
class IconComponent {
  /**
        Defines the component semantic design.
        */
  design!:
    | 'Contrast'
    | 'Critical'
    | 'Default'
    | 'Information'
    | 'Negative'
    | 'Neutral'
    | 'NonInteractive'
    | 'Positive';
  /**
        Defines the unique identifier (icon name) of the component.

To browse all available icons, see the
[SAP Icons](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html),
[SAP Fiori Tools](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html#/overview/SAP-icons-TNT) and
[SAP Business Suite](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html)

Example:
\`name='add'\`, \`name='delete'\`, \`name='employee'\`.

**Note:** To use the SAP Fiori Tools icons,
you need to set the \`tnt\` prefix in front of the icon's name.

Example:
\`name='tnt/antenna'\`, \`name='tnt/actor'\`, \`name='tnt/api'\`.

**Note:** To use the SAP Business Suite icons,
you need to set the \`business-suite\` prefix in front of the icon's name.

Example:
\`name='business-suite/3d'\`, \`name='business-suite/1x2-grid-layout'\`, \`name='business-suite/4x4-grid-layout'\`.
        */
  name!: string | undefined;
  /**
        Defines the text alternative of the component.
If not provided a default text alternative will be set, if present.

**Note:** Every icon should have a text alternative in order to
calculate its accessible name.
        */
  accessibleName!: string | undefined;
  /**
        Defines whether the component should have a tooltip.

**Note:** The tooltip text should be provided via the \`accessible-name\` property.
        */
  @InputDecorator({ transform: booleanAttribute })
  showTooltip!: boolean;
  /**
        Defines the mode of the component.
        */
  mode!: 'Image' | 'Decorative' | 'Interactive';

  /**
     Fired on mouseup, \`SPACE\` and \`ENTER\`.
- on mouse click, the icon fires native \`click\` event
- on \`SPACE\` and \`ENTER\`, the icon fires custom \`click\` event
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<Icon> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Icon {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { IconComponent };
"
`;

exports[`Snapshot test Main Index Ts should match the snapshot 1`] = `"export { Ui5MainModule } from './ui5-main.module';"`;

exports[`Snapshot test Main Input should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Input.js';
import {
  default as Input,
  InputSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/Input.js';
@ProxyInputs([
  'disabled',
  'placeholder',
  'readonly',
  'required',
  'noTypeahead',
  'type',
  'value',
  'valueState',
  'name',
  'showSuggestions',
  'maxlength',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'showClearIcon',
  'open',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'select: ui5Select',
  'selection-change: ui5SelectionChange',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-input',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'placeholder',
    'readonly',
    'required',
    'noTypeahead',
    'type',
    'value',
    'valueState',
    'name',
    'showSuggestions',
    'maxlength',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'showClearIcon',
    'open',
  ],
  outputs: [
    'ui5Change',
    'ui5Input',
    'ui5Select',
    'ui5SelectionChange',
    'ui5Open',
    'ui5Close',
  ],
  exportAs: 'ui5Input',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class InputComponent {
  /**
        Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines a short hint intended to aid the user with data entry when the
component has no value.
        */
  placeholder!: string | undefined;
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines whether the value will be autcompleted to match an item
        */
  @InputDecorator({ transform: booleanAttribute })
  noTypeahead!: boolean;
  /**
        Defines the HTML type of the component.

**Notes:**

- The particular effect of this property differs depending on the browser
and the current language settings, especially for type \`Number\`.
- The property is mostly intended to be used with touch devices
that use different soft keyboard layouts depending on the given input type.
        */
  type!: 'Text' | 'Email' | 'Number' | 'Password' | 'Tel' | 'URL' | 'Search';
  /**
        Defines the value of the component.

**Note:** The property is updated upon typing.
        */
  value!: string;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines whether the component should show suggestions, if such are present.
        */
  @InputDecorator({ transform: booleanAttribute })
  showSuggestions!: boolean;
  /**
        Sets the maximum number of characters available in the input field.

**Note:** This property is not compatible with the ui5-input type InputType.Number. If the ui5-input type is set to Number, the maxlength value is ignored.
        */
  maxlength!: number | undefined;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the input.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the input.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Defines whether the clear icon of the input will be shown.
        */
  @InputDecorator({ transform: booleanAttribute })
  showClearIcon!: boolean;
  /**
        Defines whether the suggestions picker is open.
The picker will not open if the \`showSuggestions\` property is set to \`false\`, the input is disabled or the input is readonly.
The picker will close automatically and \`close\` event will be fired if the input is not in the viewport.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke,
and when a suggestion item has been selected.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when some text has been selected.
    */
  ui5Select!: EventEmitter<void>;
  /**
     Fired when the user navigates to a suggestion item via the ARROW keys,
as a preview, before the final selection.
    */
  ui5SelectionChange!: EventEmitter<InputSelectionChangeEventDetail>;
  /**
     Fired when the suggestions picker is open.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired when the suggestions picker is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Input> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): Input {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { InputComponent };
"
`;

exports[`Snapshot test Main Label should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Label.js';
import Label from '@ui5/webcomponents/dist/Label.js';
@ProxyInputs(['for', 'showColon', 'required', 'wrappingType'])
@Component({
  standalone: true,
  selector: 'ui5-label',
  template: '<ng-content></ng-content>',
  inputs: ['for', 'showColon', 'required', 'wrappingType'],
  exportAs: 'ui5Label',
})
class LabelComponent {
  /**
        Defines the labeled input by providing its ID.

**Note:** Can be used with both \`ui5-input\` and native input.
        */
  for!: string | undefined;
  /**
        Defines whether colon is added to the component text.

**Note:** Usually used in forms.
        */
  @InputDecorator({ transform: booleanAttribute })
  showColon!: boolean;
  /**
        Defines whether an asterisk character is added to the component text.

**Note:** Usually indicates that user input (bound with the \`for\` property) is required.
In that case the \`required\` property of
the corresponding input should also be set.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines how the text of a component will be displayed when there is not enough space.

**Note:** for option \\"Normal\\" the text will wrap and the words will not be broken based on hyphenation.
        */
  wrappingType!: 'None' | 'Normal';

  private elementRef: ElementRef<Label> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Label {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { LabelComponent };
"
`;

exports[`Snapshot test Main Link should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Link.js';
import {
  default as Link,
  LinkAccessibilityAttributes,
  LinkClickEventDetail,
} from '@ui5/webcomponents/dist/Link.js';
@ProxyInputs([
  'disabled',
  'tooltip',
  'href',
  'target',
  'design',
  'interactiveAreaSize',
  'wrappingType',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
  'accessibilityAttributes',
  'accessibleDescription',
  'icon',
  'endIcon',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-link',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'tooltip',
    'href',
    'target',
    'design',
    'interactiveAreaSize',
    'wrappingType',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
    'accessibilityAttributes',
    'accessibleDescription',
    'icon',
    'endIcon',
  ],
  outputs: ['ui5Click'],
  exportAs: 'ui5Link',
})
class LinkComponent {
  /**
        Defines whether the component is disabled.

**Note:** When disabled, the click event cannot be triggered by the user.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the tooltip of the component.
        */
  tooltip!: string | undefined;
  /**
        Defines the component href.

**Note:** Standard hyperlink behavior is supported.
        */
  href!: string | undefined;
  /**
        Defines the component target.

**Notes:**

- \`_self\`
- \`_top\`
- \`_blank\`
- \`_parent\`
- \`_search\`

**This property must only be used when the \`href\` property is set.**
        */
  target!: string | undefined;
  /**
        Defines the component design.

**Note:** Avaialble options are \`Default\`, \`Subtle\`, and \`Emphasized\`.
        */
  design!: 'Default' | 'Subtle' | 'Emphasized';
  /**
        Defines the target area size of the link:
- **InteractiveAreaSize.Normal**: The default target area size.
- **InteractiveAreaSize.Large**: The target area size is enlarged to 24px in height.

**Note:**The property is designed to make links easier to activate and helps meet the WCAG 2.2 Target Size requirement. It is applicable only for the SAP Horizon themes.
**Note:**To improve <code>ui5-link</code>'s reliability and usability, it is recommended to use the <code>InteractiveAreaSize.Large</code> value in scenarios where the <code>ui5-link</code> component is placed inside another interactive component, such as a list item or a table cell.
Setting the <code>interactiveAreaSize</code> property to <code>InteractiveAreaSize.Large</code> increases the <code>ui5-link</code>'s invisible touch area. As a result, the user's intended one-time selection command is more likely to activate the desired <code>ui5-link</code>, with minimal chance of unintentionally activating the underlying component.
        */
  interactiveAreaSize!: 'Normal' | 'Large';
  /**
        Defines how the text of a component will be displayed when there is not enough space.

**Note:** By default the text will wrap. If \\"None\\" is set - the text will truncate.
        */
  wrappingType!: 'None' | 'Normal';
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the input
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the ARIA role of the component.

**Note:** Use the <code>LinkAccessibleRole.Button</code> role in cases when navigation is not expected to occur and the href property is not defined.
        */
  accessibleRole!: 'Link' | 'Button';
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **expanded**: Indicates whether the button, or another grouping element it controls, is currently expanded or collapsed.
Accepts the following string values: \`true\` or \`false\`.

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.
        */
  accessibilityAttributes!: LinkAccessibilityAttributes;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Defines the icon, displayed as graphical element within the component before the link's text.
The SAP-icons font provides numerous options.

**Note:** Usage of icon-only link is not supported, the link must always have a text.

**Note:** We recommend using Ð°n icon in the beginning or the end only, and with text.

See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines the icon, displayed as graphical element within the component after the link's text.
The SAP-icons font provides numerous options.

**Note:** Usage of icon-only link is not supported, the link must always have a text.

**Note:** We recommend using Ð°n icon in the beginning or the end only, and with text.

See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  endIcon!: string | undefined;

  /**
     Fired when the component is triggered either with a mouse/tap
or by using the Enter key.
    */
  ui5Click!: EventEmitter<LinkClickEventDetail>;

  private elementRef: ElementRef<Link> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Link {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { LinkComponent };
"
`;

exports[`Snapshot test Main List Item Custom should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
import '@ui5/webcomponents/dist/ListItemCustom.js';
import ListItemCustom from '@ui5/webcomponents/dist/ListItemCustom.js';
@ProxyInputs([
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'selected',
  'movable',
  'accessibleName',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-li-custom',
  template: '<ng-content></ng-content>',
  inputs: [
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'selected',
    'movable',
    'accessibleName',
  ],
  outputs: ['ui5DetailClick'],
  exportAs: 'ui5LiCustom',
})
class ListItemCustomComponent {
  /**
        Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
        */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
        */
  accessibilityAttributes!: ListItemAccessibilityAttributes;
  /**
        The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
        */
  @InputDecorator({ transform: booleanAttribute })
  navigated!: boolean;
  /**
        Defines the text of the tooltip that would be displayed for the list item.
        */
  tooltip!: string | undefined;
  /**
        Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
        */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;
  /**
        Defines whether the item is movable.
        */
  @InputDecorator({ transform: booleanAttribute })
  movable!: boolean;
  /**
        Defines the text alternative of the component.

**Note**: If not provided a default text alternative will be set, if present.
        */
  accessibleName!: string | undefined;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<ListItemCustom> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ListItemCustom {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ListItemCustomComponent };
"
`;

exports[`Snapshot test Main List Item Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ListItemGroup.js';
import {
  default as ListItemGroup,
  ListItemGroupMoveEventDetail,
} from '@ui5/webcomponents/dist/ListItemGroup.js';
@ProxyInputs(['headerText', 'headerAccessibleName', 'wrappingType'])
@ProxyOutputs(['move-over: ui5MoveOver', 'move: ui5Move'])
@Component({
  standalone: true,
  selector: 'ui5-li-group',
  template: '<ng-content></ng-content>',
  inputs: ['headerText', 'headerAccessibleName', 'wrappingType'],
  outputs: ['ui5MoveOver', 'ui5Move'],
  exportAs: 'ui5LiGroup',
})
class ListItemGroupComponent {
  /**
        Defines the header text of the <code>ui5-li-group</code>.
        */
  headerText!: string | undefined;
  /**
        Defines the accessible name of the header.
        */
  headerAccessibleName!: string | undefined;
  /**
        Defines if the text of the component should wrap when it's too long.
When set to \\"Normal\\", the content (title, description) will be wrapped
using the \`ui5-expandable-text\` component.<br/>

The text can wrap up to 100 characters on small screens (size S) and
up to 300 characters on larger screens (size M and above). When text exceeds
these limits, it truncates with an ellipsis followed by a text expansion trigger.

Available options are:
- \`None\` (default) - The text will truncate with an ellipsis.
- \`Normal\` - The text will wrap (without truncation).
        */
  wrappingType!: 'None' | 'Normal';

  /**
     Fired when a movable list item is moved over a potential drop target during a dragging operation.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5MoveOver!: EventEmitter<ListItemGroupMoveEventDetail>;
  /**
     Fired when a movable list item is dropped onto a drop target.

**Note:** \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.
    */
  ui5Move!: EventEmitter<ListItemGroupMoveEventDetail>;

  private elementRef: ElementRef<ListItemGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ListItemGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ListItemGroupComponent };
"
`;

exports[`Snapshot test Main List Item Standard should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
import '@ui5/webcomponents/dist/ListItemStandard.js';
import ListItemStandard from '@ui5/webcomponents/dist/ListItemStandard.js';
@ProxyInputs([
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'selected',
  'text',
  'description',
  'icon',
  'iconEnd',
  'additionalText',
  'additionalTextState',
  'movable',
  'accessibleName',
  'wrappingType',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-li',
  template: '<ng-content></ng-content>',
  inputs: [
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'selected',
    'text',
    'description',
    'icon',
    'iconEnd',
    'additionalText',
    'additionalTextState',
    'movable',
    'accessibleName',
    'wrappingType',
  ],
  outputs: ['ui5DetailClick'],
  exportAs: 'ui5Li',
})
class ListItemStandardComponent {
  /**
        Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
        */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
        */
  accessibilityAttributes!: ListItemAccessibilityAttributes;
  /**
        The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
        */
  @InputDecorator({ transform: booleanAttribute })
  navigated!: boolean;
  /**
        Defines the text of the tooltip that would be displayed for the list item.
        */
  tooltip!: string | undefined;
  /**
        Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
        */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;
  /**
        Defines the text of the component.
        */
  text!: string | undefined;
  /**
        Defines the description displayed right under the item text, if such is present.
        */
  description!: string | undefined;
  /**
        Defines the \`icon\` source URI.

**Note:**
SAP-icons font provides numerous built-in icons. To find all the available icons, see the
[Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines whether the \`icon\` should be displayed in the beginning of the list item or in the end.
        */
  @InputDecorator({ transform: booleanAttribute })
  iconEnd!: boolean;
  /**
        Defines the \`additionalText\`, displayed in the end of the list item.
        */
  additionalText!: string | undefined;
  /**
        Defines the state of the \`additionalText\`.

Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
        */
  additionalTextState!:
    | 'None'
    | 'Positive'
    | 'Critical'
    | 'Negative'
    | 'Information';
  /**
        Defines whether the item is movable.
        */
  @InputDecorator({ transform: booleanAttribute })
  movable!: boolean;
  /**
        Defines the text alternative of the component.
Note: If not provided a default text alternative will be set, if present.
        */
  accessibleName!: string | undefined;
  /**
        Defines if the text of the component should wrap when it's too long.
When set to \\"Normal\\", the content (title, description) will be wrapped
using the \`ui5-expandable-text\` component.<br/>

The text can wrap up to 100 characters on small screens (size S) and
up to 300 characters on larger screens (size M and above). When text exceeds
these limits, it truncates with an ellipsis followed by a text expansion trigger.

Available options are:
- \`None\` (default) - The text will truncate with an ellipsis.
- \`Normal\` - The text will wrap (without truncation).
        */
  wrappingType!: 'None' | 'Normal';

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<ListItemStandard> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ListItemStandard {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ListItemStandardComponent };
"
`;

exports[`Snapshot test Main List should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/List.js';
import {
  default as List,
  ListAccessibilityAttributes,
  ListItemClickEventDetail,
  ListItemCloseEventDetail,
  ListItemDeleteEventDetail,
  ListItemToggleEventDetail,
  ListMoveEventDetail,
  ListSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/List.js';
@ProxyInputs([
  'headerText',
  'footerText',
  'indent',
  'selectionMode',
  'noDataText',
  'separators',
  'growing',
  'growingButtonText',
  'loading',
  'loadingDelay',
  'accessibleName',
  'accessibilityAttributes',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'accessibleRole',
])
@ProxyOutputs([
  'item-click: ui5ItemClick',
  'item-close: ui5ItemClose',
  'item-toggle: ui5ItemToggle',
  'item-delete: ui5ItemDelete',
  'selection-change: ui5SelectionChange',
  'load-more: ui5LoadMore',
  'move-over: ui5MoveOver',
  'move: ui5Move',
])
@Component({
  standalone: true,
  selector: 'ui5-list',
  template: '<ng-content></ng-content>',
  inputs: [
    'headerText',
    'footerText',
    'indent',
    'selectionMode',
    'noDataText',
    'separators',
    'growing',
    'growingButtonText',
    'loading',
    'loadingDelay',
    'accessibleName',
    'accessibilityAttributes',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'accessibleRole',
  ],
  outputs: [
    'ui5ItemClick',
    'ui5ItemClose',
    'ui5ItemToggle',
    'ui5ItemDelete',
    'ui5SelectionChange',
    'ui5LoadMore',
    'ui5MoveOver',
    'ui5Move',
  ],
  exportAs: 'ui5List',
})
class ListComponent {
  /**
        Defines the component header text.

**Note:** If \`header\` is set this property is ignored.
        */
  headerText!: string | undefined;
  /**
        Defines the footer text.
        */
  footerText!: string | undefined;
  /**
        Determines whether the component is indented.
        */
  @InputDecorator({ transform: booleanAttribute })
  indent!: boolean;
  /**
        Defines the selection mode of the component.
        */
  selectionMode!:
    | 'None'
    | 'Single'
    | 'SingleStart'
    | 'SingleEnd'
    | 'SingleAuto'
    | 'Multiple'
    | 'Delete';
  /**
        Defines the text that is displayed when the component contains no items.
        */
  noDataText!: string | undefined;
  /**
        Defines the item separator style that is used.
        */
  separators!: 'All' | 'Inner' | 'None';
  /**
        Defines whether the component will have growing capability either by pressing a \`More\` button,
or via user scroll. In both cases \`load-more\` event is fired.

**Restrictions:** \`growing=\\"Scroll\\"\` is not supported for Internet Explorer,
on IE the component will fallback to \`growing=\\"Button\\"\`.
        */
  growing!: 'Button' | 'Scroll' | 'None';
  /**
        Defines the text that will be displayed inside the growing button.

**Note:** If not specified a built-in text will be displayed.

**Note:** This property takes effect if the \`growing\` property is set to the \`Button\`.
        */
  growingButtonText!: string | undefined;
  /**
        Defines if the component would display a loading indicator over the list.
        */
  @InputDecorator({ transform: booleanAttribute })
  loading!: boolean;
  /**
        Defines the delay in milliseconds, after which the loading indicator will show up for this component.
        */
  loadingDelay!: number;
  /**
        Defines the accessible name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines additional accessibility attributes on different areas of the component.

The accessibilityAttributes object has the following field:

 - **growingButton**: \`growingButton.name\`.

 The accessibility attributes support the following values:

- **name**: Defines the accessible ARIA name of the growing button.
Accepts any string.

 **Note:** The \`accessibilityAttributes\` property is in an experimental state and is a subject to change.
        */
  accessibilityAttributes!: ListAccessibilityAttributes;
  /**
        Defines the IDs of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Defines the IDs of the elements that describe the component.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Defines the accessible role of the component.
        */
  accessibleRole!: 'List' | 'Menu' | 'Tree' | 'ListBox';

  /**
     Fired when an item is activated, unless the item's \`type\` property
is set to \`Inactive\`.

**Note**: This event is not triggered by interactions with selection components such as the checkboxes and radio buttons,
associated with non-default \`selectionMode\` values, or if any other **interactive** component
(such as a button or input) within the list item is directly clicked.
    */
  ui5ItemClick!: EventEmitter<ListItemClickEventDetail>;
  /**
     Fired when the \`Close\` button of any item is clicked

**Note:** This event is only applicable to list items that can be closed (such as notification list items),
not to be confused with \`item-delete\`.
    */
  ui5ItemClose!: EventEmitter<ListItemCloseEventDetail>;
  /**
     Fired when the \`Toggle\` button of any item is clicked.

**Note:** This event is only applicable to list items that can be toggled (such as notification group list items).
    */
  ui5ItemToggle!: EventEmitter<ListItemToggleEventDetail>;
  /**
     Fired when the Delete button of any item is pressed.

**Note:** A Delete button is displayed on each item,
when the component \`selectionMode\` property is set to \`Delete\`.
    */
  ui5ItemDelete!: EventEmitter<ListItemDeleteEventDetail>;
  /**
     Fired when selection is changed by user interaction
in \`Single\`, \`SingleStart\`, \`SingleEnd\` and \`Multiple\` selection modes.
    */
  ui5SelectionChange!: EventEmitter<ListSelectionChangeEventDetail>;
  /**
     Fired when the user scrolls to the bottom of the list.

**Note:** The event is fired when the \`growing='Scroll'\` property is enabled.
    */
  ui5LoadMore!: EventEmitter<void>;
  /**
     Fired when a movable list item is moved over a potential drop target during a dragging operation.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5MoveOver!: EventEmitter<ListMoveEventDetail>;
  /**
     Fired when a movable list item is dropped onto a drop target.

**Note:** \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.
    */
  ui5Move!: EventEmitter<ListMoveEventDetail>;

  private elementRef: ElementRef<List> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): List {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ListComponent };
"
`;

exports[`Snapshot test Main Menu Item Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MenuItemGroup.js';
import MenuItemGroup from '@ui5/webcomponents/dist/MenuItemGroup.js';
@ProxyInputs(['checkMode'])
@Component({
  standalone: true,
  selector: 'ui5-menu-item-group',
  template: '<ng-content></ng-content>',
  inputs: ['checkMode'],
  exportAs: 'ui5MenuItemGroup',
})
class MenuItemGroupComponent {
  /**
        Defines the component's check mode.
        */
  checkMode!: 'None' | 'Single' | 'Multiple';

  private elementRef: ElementRef<MenuItemGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MenuItemGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MenuItemGroupComponent };
"
`;

exports[`Snapshot test Main Menu Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MenuItem.js';
import {
  MenuBeforeCloseEventDetail,
  MenuBeforeOpenEventDetail,
  default as MenuItem,
  MenuItemAccessibilityAttributes,
} from '@ui5/webcomponents/dist/MenuItem.js';
@ProxyInputs([
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'selected',
  'text',
  'additionalText',
  'icon',
  'disabled',
  'loading',
  'loadingDelay',
  'accessibleName',
  'checked',
])
@ProxyOutputs([
  'detail-click: ui5DetailClick',
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
  'check: ui5Check',
])
@Component({
  standalone: true,
  selector: 'ui5-menu-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'selected',
    'text',
    'additionalText',
    'icon',
    'disabled',
    'loading',
    'loadingDelay',
    'accessibleName',
    'checked',
  ],
  outputs: [
    'ui5DetailClick',
    'ui5BeforeOpen',
    'ui5Open',
    'ui5BeforeClose',
    'ui5Close',
    'ui5Check',
  ],
  exportAs: 'ui5MenuItem',
})
class MenuItemComponent {
  /**
        Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
        */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaKeyShortcuts**: Indicated the availability of a keyboard shortcuts defined for the menu item.

- **role**: Defines the role of the menu item. If not set, menu item will have default role=\\"menuitem\\".
        */
  accessibilityAttributes!: MenuItemAccessibilityAttributes;
  /**
        The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
        */
  @InputDecorator({ transform: booleanAttribute })
  navigated!: boolean;
  /**
        Defines the text of the tooltip for the menu item.
        */
  tooltip!: string | undefined;
  /**
        Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
        */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;
  /**
        Defines the text of the tree item.
        */
  text!: string | undefined;
  /**
        Defines the \`additionalText\`, displayed in the end of the menu item.

**Note:** The additional text will not be displayed if there are items added in \`items\` slot or there are
components added to \`endContent\` slot.

The priority of what will be displayed at the end of the menu item is as follows:
sub-menu arrow (if there are items added in \`items\` slot) -> components added in \`endContent\` -> text set to \`additionalText\`.
        */
  additionalText!: string | undefined;
  /**
        Defines the icon to be displayed as graphical element within the component.
The SAP-icons font provides numerous options.

**Example:**

See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines whether menu item is in disabled state.

**Note:** A disabled menu item is noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the delay in milliseconds, after which the loading indicator will be displayed inside the corresponding menu popover.

**Note:** If set to \`true\` a busy indicator component will be displayed into the related one to the current menu item sub-menu popover.
        */
  @InputDecorator({ transform: booleanAttribute })
  loading!: boolean;
  /**
        Defines the delay in milliseconds, after which the loading indicator will be displayed inside the corresponding menu popover.
        */
  loadingDelay!: number;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines whether menu item is in checked state.

**Note:** checked state is only taken into account when menu item is added to menu item group
with \`checkMode\` other than \`None\`.

**Note:** A checked menu item has a checkmark displayed at its end.
        */
  @InputDecorator({ transform: booleanAttribute })
  checked!: boolean;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;
  /**
     Fired before the menu is opened. This event can be cancelled, which will prevent the menu from opening.

**Note:** Since 1.14.0 the event is also fired before a sub-menu opens.
    */
  ui5BeforeOpen!: EventEmitter<MenuBeforeOpenEventDetail>;
  /**
     Fired after the menu is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the menu is closed. This event can be cancelled, which will prevent the menu from closing.
    */
  ui5BeforeClose!: EventEmitter<MenuBeforeCloseEventDetail>;
  /**
     Fired after the menu is closed.
    */
  ui5Close!: EventEmitter<void>;
  /**
     Fired when an item is checked or unchecked.
    */
  ui5Check!: EventEmitter<void>;

  private elementRef: ElementRef<MenuItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MenuItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MenuItemComponent };
"
`;

exports[`Snapshot test Main Menu Separator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents/dist/MenuSeparator.js';
import MenuSeparator from '@ui5/webcomponents/dist/MenuSeparator.js';

@Component({
  standalone: true,
  selector: 'ui5-menu-separator',
  template: '<ng-content></ng-content>',
  exportAs: 'ui5MenuSeparator',
})
class MenuSeparatorComponent {
  private elementRef: ElementRef<MenuSeparator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MenuSeparator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MenuSeparatorComponent };
"
`;

exports[`Snapshot test Main Menu should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Menu.js';
import {
  default as Menu,
  MenuBeforeCloseEventDetail,
  MenuBeforeOpenEventDetail,
  MenuItemClickEventDetail,
} from '@ui5/webcomponents/dist/Menu.js';
@ProxyInputs([
  'headerText',
  'open',
  'horizontalAlign',
  'loading',
  'loadingDelay',
  'opener',
])
@ProxyOutputs([
  'item-click: ui5ItemClick',
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-menu',
  template: '<ng-content></ng-content>',
  inputs: [
    'headerText',
    'open',
    'horizontalAlign',
    'loading',
    'loadingDelay',
    'opener',
  ],
  outputs: [
    'ui5ItemClick',
    'ui5BeforeOpen',
    'ui5Open',
    'ui5BeforeClose',
    'ui5Close',
  ],
  exportAs: 'ui5Menu',
})
class MenuComponent {
  /**
        Defines the header text of the menu (displayed on mobile).
        */
  headerText!: string | undefined;
  /**
        Indicates if the menu is open.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Determines the horizontal alignment of the menu relative to its opener control.
        */
  horizontalAlign!: 'Center' | 'Start' | 'End' | 'Stretch';
  /**
        Defines if a loading indicator would be displayed inside the corresponding ui5-menu popover.
        */
  @InputDecorator({ transform: booleanAttribute })
  loading!: boolean;
  /**
        Defines the delay in milliseconds, after which the loading indicator will be displayed inside the corresponding ui5-menu popover.
        */
  loadingDelay!: number;
  /**
        Defines the ID or DOM Reference of the element at which the menu is shown.
When using this attribute in a declarative way, you must only use the \`id\` (as a string) of the element at which you want to show the popover.
You can only set the \`opener\` attribute to a DOM Reference when using JavaScript.
        */
  opener!: HTMLElement | string | null | undefined;

  /**
     Fired when an item is being clicked.

**Note:** Since 1.17.0 the event is preventable, allowing the menu to remain open after an item is pressed.
    */
  ui5ItemClick!: EventEmitter<MenuItemClickEventDetail>;
  /**
     Fired before the menu is opened. This event can be cancelled, which will prevent the menu from opening.

**Note:** Since 1.14.0 the event is also fired before a sub-menu opens.
    */
  ui5BeforeOpen!: EventEmitter<MenuBeforeOpenEventDetail>;
  /**
     Fired after the menu is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the menu is closed. This event can be cancelled, which will prevent the menu from closing.
    */
  ui5BeforeClose!: EventEmitter<MenuBeforeCloseEventDetail>;
  /**
     Fired after the menu is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Menu> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Menu {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MenuComponent };
"
`;

exports[`Snapshot test Main Message Strip should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MessageStrip.js';
import MessageStrip from '@ui5/webcomponents/dist/MessageStrip.js';
@ProxyInputs(['design', 'colorScheme', 'hideIcon', 'hideCloseButton'])
@ProxyOutputs(['close: ui5Close'])
@Component({
  standalone: true,
  selector: 'ui5-message-strip',
  template: '<ng-content></ng-content>',
  inputs: ['design', 'colorScheme', 'hideIcon', 'hideCloseButton'],
  outputs: ['ui5Close'],
  exportAs: 'ui5MessageStrip',
})
class MessageStripComponent {
  /**
        Defines the component type.
        */
  design!:
    | 'Information'
    | 'Positive'
    | 'Negative'
    | 'Critical'
    | 'ColorSet1'
    | 'ColorSet2';
  /**
        Defines the color scheme of the component.
There are 10 predefined schemes.
To use one you can set a number from \`\\"1\\"\` to \`\\"10\\"\`. The \`colorScheme\` \`\\"1\\"\` will be set by default.
        */
  colorScheme!: string;
  /**
        Defines whether the MessageStrip will show an icon in the beginning.
You can directly provide an icon with the \`icon\` slot. Otherwise, the default icon for the type will be used.

 * **Note:** If <code>MessageStripDesign.ColorSet1</code> or <code>MessageStripDesign.ColorSet2</code> value is set to the <code>design</code> property, default icon will not be presented.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideIcon!: boolean;
  /**
        Defines whether the MessageStrip renders close button.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideCloseButton!: boolean;

  /**
     Fired when the close button is pressed either with a
click/tap or by using the Enter or Space key.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<MessageStrip> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MessageStrip {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MessageStripComponent };
"
`;

exports[`Snapshot test Main Multi Combo Box Item Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemGroupMoveEventDetail } from '@ui5/webcomponents/dist/ListItemGroup.js';
import '@ui5/webcomponents/dist/MultiComboBoxItemGroup.js';
import MultiComboBoxItemGroup from '@ui5/webcomponents/dist/MultiComboBoxItemGroup.js';
@ProxyInputs(['headerText', 'headerAccessibleName', 'wrappingType'])
@ProxyOutputs(['move-over: ui5MoveOver', 'move: ui5Move'])
@Component({
  standalone: true,
  selector: 'ui5-mcb-item-group',
  template: '<ng-content></ng-content>',
  inputs: ['headerText', 'headerAccessibleName', 'wrappingType'],
  outputs: ['ui5MoveOver', 'ui5Move'],
  exportAs: 'ui5McbItemGroup',
})
class MultiComboBoxItemGroupComponent {
  /**
        Defines the header text of the <code>ui5-li-group</code>.
        */
  headerText!: string | undefined;
  /**
        Defines the accessible name of the header.
        */
  headerAccessibleName!: string | undefined;
  /**
        Defines if the text of the component should wrap when it's too long.
When set to \\"Normal\\", the content (title, description) will be wrapped
using the \`ui5-expandable-text\` component.<br/>

The text can wrap up to 100 characters on small screens (size S) and
up to 300 characters on larger screens (size M and above). When text exceeds
these limits, it truncates with an ellipsis followed by a text expansion trigger.

Available options are:
- \`None\` (default) - The text will truncate with an ellipsis.
- \`Normal\` - The text will wrap (without truncation).
        */
  wrappingType!: 'None' | 'Normal';

  /**
     Fired when a movable list item is moved over a potential drop target during a dragging operation.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5MoveOver!: EventEmitter<ListItemGroupMoveEventDetail>;
  /**
     Fired when a movable list item is dropped onto a drop target.

**Note:** \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.
    */
  ui5Move!: EventEmitter<ListItemGroupMoveEventDetail>;

  private elementRef: ElementRef<MultiComboBoxItemGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MultiComboBoxItemGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MultiComboBoxItemGroupComponent };
"
`;

exports[`Snapshot test Main Multi Combo Box Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MultiComboBoxItem.js';
import MultiComboBoxItem from '@ui5/webcomponents/dist/MultiComboBoxItem.js';
@ProxyInputs(['text', 'additionalText', 'selected'])
@Component({
  standalone: true,
  selector: 'ui5-mcb-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'additionalText', 'selected'],
  exportAs: 'ui5McbItem',
})
class MultiComboBoxItemComponent {
  /**
        Defines the text of the component.
        */
  text!: string | undefined;
  /**
        Defines the additional text of the component.
        */
  additionalText!: string | undefined;
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;

  private elementRef: ElementRef<MultiComboBoxItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): MultiComboBoxItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { MultiComboBoxItemComponent };
"
`;

exports[`Snapshot test Main Multi Combo Box should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/MultiComboBox.js';
import {
  default as MultiComboBox,
  MultiComboBoxSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/MultiComboBox.js';
@ProxyInputs([
  'value',
  'name',
  'noTypeahead',
  'placeholder',
  'noValidation',
  'disabled',
  'valueState',
  'readonly',
  'required',
  'filter',
  'showClearIcon',
  'accessibleName',
  'accessibleNameRef',
  'showSelectAll',
  'open',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'open: ui5Open',
  'close: ui5Close',
  'selection-change: ui5SelectionChange',
])
@Component({
  standalone: true,
  selector: 'ui5-multi-combobox',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'name',
    'noTypeahead',
    'placeholder',
    'noValidation',
    'disabled',
    'valueState',
    'readonly',
    'required',
    'filter',
    'showClearIcon',
    'accessibleName',
    'accessibleNameRef',
    'showSelectAll',
    'open',
  ],
  outputs: [
    'ui5Change',
    'ui5Input',
    'ui5Open',
    'ui5Close',
    'ui5SelectionChange',
  ],
  exportAs: 'ui5MultiCombobox',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class MultiComboBoxComponent {
  /**
        Defines the value of the component.

**Note:** The property is updated upon typing.
        */
  value!: string;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
**Note:** When the component is used inside a form element,
the value is sent as the first element in the form data, even if it's empty.
        */
  name!: string | undefined;
  /**
        Defines whether the value will be autcompleted to match an item
        */
  @InputDecorator({ transform: booleanAttribute })
  noTypeahead!: boolean;
  /**
        Defines a short hint intended to aid the user with data entry when the
component has no value.
        */
  placeholder!: string | undefined;
  /**
        Defines if the user input will be prevented, if no matching item has been found
        */
  @InputDecorator({ transform: booleanAttribute })
  noValidation!: boolean;
  /**
        Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines the filter type of the component.
        */
  filter!: 'StartsWithPerTerm' | 'StartsWith' | 'Contains' | 'None';
  /**
        Defines whether the clear icon of the multi-combobox will be shown.
        */
  @InputDecorator({ transform: booleanAttribute })
  showClearIcon!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Determines if the select all checkbox is visible on top of suggestions.
        */
  @InputDecorator({ transform: booleanAttribute })
  showSelectAll!: boolean;
  /**
        Indicates whether the items picker is open.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke or clear icon is pressed.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when the dropdown is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired when the dropdown is closed.
    */
  ui5Close!: EventEmitter<void>;
  /**
     Fired when selection is changed by user interaction.
    */
  ui5SelectionChange!: EventEmitter<MultiComboBoxSelectionChangeEventDetail>;

  private elementRef: ElementRef<MultiComboBox> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): MultiComboBox {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { MultiComboBoxComponent };
"
`;

exports[`Snapshot test Main Multi Input should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { InputSelectionChangeEventDetail } from '@ui5/webcomponents/dist/Input.js';
import '@ui5/webcomponents/dist/MultiInput.js';
import {
  default as MultiInput,
  MultiInputTokenDeleteEventDetail,
} from '@ui5/webcomponents/dist/MultiInput.js';
@ProxyInputs([
  'disabled',
  'placeholder',
  'readonly',
  'required',
  'noTypeahead',
  'type',
  'value',
  'valueState',
  'name',
  'showSuggestions',
  'maxlength',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'showClearIcon',
  'open',
  'showValueHelpIcon',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'select: ui5Select',
  'selection-change: ui5SelectionChange',
  'open: ui5Open',
  'close: ui5Close',
  'value-help-trigger: ui5ValueHelpTrigger',
  'token-delete: ui5TokenDelete',
])
@Component({
  standalone: true,
  selector: 'ui5-multi-input',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'placeholder',
    'readonly',
    'required',
    'noTypeahead',
    'type',
    'value',
    'valueState',
    'name',
    'showSuggestions',
    'maxlength',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'showClearIcon',
    'open',
    'showValueHelpIcon',
  ],
  outputs: [
    'ui5Change',
    'ui5Input',
    'ui5Select',
    'ui5SelectionChange',
    'ui5Open',
    'ui5Close',
    'ui5ValueHelpTrigger',
    'ui5TokenDelete',
  ],
  exportAs: 'ui5MultiInput',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class MultiInputComponent {
  /**
        Defines whether the component is in disabled state.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines a short hint intended to aid the user with data entry when the
component has no value.
        */
  placeholder!: string | undefined;
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines whether the value will be autcompleted to match an item
        */
  @InputDecorator({ transform: booleanAttribute })
  noTypeahead!: boolean;
  /**
        Defines the HTML type of the component.

**Notes:**

- The particular effect of this property differs depending on the browser
and the current language settings, especially for type \`Number\`.
- The property is mostly intended to be used with touch devices
that use different soft keyboard layouts depending on the given input type.
        */
  type!: 'Text' | 'Email' | 'Number' | 'Password' | 'Tel' | 'URL' | 'Search';
  /**
        Defines the value of the component.

**Note:** The property is updated upon typing.
        */
  value!: string;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
**Note:** When the component is used inside a form element,
the value is sent as the first element in the form data, even if it's empty.
        */
  name!: string | undefined;
  /**
        Defines whether the component should show suggestions, if such are present.
        */
  @InputDecorator({ transform: booleanAttribute })
  showSuggestions!: boolean;
  /**
        Sets the maximum number of characters available in the input field.

**Note:** This property is not compatible with the ui5-input type InputType.Number. If the ui5-input type is set to Number, the maxlength value is ignored.
        */
  maxlength!: number | undefined;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the input.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the input.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Defines whether the clear icon of the input will be shown.
        */
  @InputDecorator({ transform: booleanAttribute })
  showClearIcon!: boolean;
  /**
        Defines whether the suggestions picker is open.
The picker will not open if the \`showSuggestions\` property is set to \`false\`, the input is disabled or the input is readonly.
The picker will close automatically and \`close\` event will be fired if the input is not in the viewport.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Determines whether a value help icon will be visualized in the end of the input.
Pressing the icon will fire \`value-help-trigger\` event.
        */
  @InputDecorator({ transform: booleanAttribute })
  showValueHelpIcon!: boolean;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke,
and when a suggestion item has been selected.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired when some text has been selected.
    */
  ui5Select!: EventEmitter<void>;
  /**
     Fired when the user navigates to a suggestion item via the ARROW keys,
as a preview, before the final selection.
    */
  ui5SelectionChange!: EventEmitter<InputSelectionChangeEventDetail>;
  /**
     Fired when the suggestions picker is open.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired when the suggestions picker is closed.
    */
  ui5Close!: EventEmitter<void>;
  /**
     Fired when the value help icon is pressed
and F4 or ALT/OPTION + ARROW_UP/ARROW_DOWN keyboard keys are used.
    */
  ui5ValueHelpTrigger!: EventEmitter<void>;
  /**
     Fired when tokens are being deleted.
    */
  ui5TokenDelete!: EventEmitter<MultiInputTokenDeleteEventDetail>;

  private elementRef: ElementRef<MultiInput> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): MultiInput {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { MultiInputComponent };
"
`;

exports[`Snapshot test Main Ng Package Json should match the snapshot 1`] = `"{\\"lib\\":{\\"entryFile\\":\\"./index.ts\\"}}"`;

exports[`Snapshot test Main Option Custom should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/OptionCustom.js';
import OptionCustom from '@ui5/webcomponents/dist/OptionCustom.js';
@ProxyInputs(['displayText', 'value', 'tooltip', 'selected'])
@Component({
  standalone: true,
  selector: 'ui5-option-custom',
  template: '<ng-content></ng-content>',
  inputs: ['displayText', 'value', 'tooltip', 'selected'],
  exportAs: 'ui5OptionCustom',
})
class OptionCustomComponent {
  /**
        Defines the text, displayed inside the \`ui5-select\` input filed
when the option gets selected.
        */
  displayText!: string | undefined;
  /**
        Defines the value of the \`ui5-select\` inside an HTML Form element when this component is selected.
For more information on HTML Form support, see the \`name\` property of \`ui5-select\`.
        */
  value!: string | undefined;
  /**
        Defines the tooltip of the option.
        */
  tooltip!: string | undefined;
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;

  private elementRef: ElementRef<OptionCustom> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): OptionCustom {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { OptionCustomComponent };
"
`;

exports[`Snapshot test Main Option should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Option.js';
import Option from '@ui5/webcomponents/dist/Option.js';
@ProxyInputs(['value', 'icon', 'additionalText', 'tooltip', 'selected'])
@Component({
  standalone: true,
  selector: 'ui5-option',
  template: '<ng-content></ng-content>',
  inputs: ['value', 'icon', 'additionalText', 'tooltip', 'selected'],
  exportAs: 'ui5Option',
})
class OptionComponent {
  /**
        Defines the value of the \`ui5-select\` inside an HTML Form element when this component is selected.
For more information on HTML Form support, see the \`name\` property of \`ui5-select\`.
        */
  value!: string | undefined;
  /**
        Defines the \`icon\` source URI.

**Note:**
SAP-icons font provides numerous built-in icons. To find all the available icons, see the
[Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines the \`additionalText\`, displayed in the end of the option.
        */
  additionalText!: string | undefined;
  /**
        Defines the tooltip of the option.
        */
  tooltip!: string | undefined;
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;

  private elementRef: ElementRef<Option> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Option {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { OptionComponent };
"
`;

exports[`Snapshot test Main Panel should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Panel.js';
import Panel from '@ui5/webcomponents/dist/Panel.js';
@ProxyInputs([
  'headerText',
  'fixed',
  'collapsed',
  'noAnimation',
  'accessibleRole',
  'headerLevel',
  'accessibleName',
  'stickyHeader',
])
@ProxyOutputs(['toggle: ui5Toggle'])
@Component({
  standalone: true,
  selector: 'ui5-panel',
  template: '<ng-content></ng-content>',
  inputs: [
    'headerText',
    'fixed',
    'collapsed',
    'noAnimation',
    'accessibleRole',
    'headerLevel',
    'accessibleName',
    'stickyHeader',
  ],
  outputs: ['ui5Toggle'],
  exportAs: 'ui5Panel',
})
class PanelComponent {
  /**
        This property is used to set the header text of the component.
The text is visible in both expanded and collapsed states.

**Note:** This property is overridden by the \`header\` slot.
        */
  headerText!: string | undefined;
  /**
        Determines whether the component is in a fixed state that is not
expandable/collapsible by user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  fixed!: boolean;
  /**
        Indicates whether the component is collapsed and only the header is displayed.
        */
  @InputDecorator({ transform: booleanAttribute })
  collapsed!: boolean;
  /**
        Indicates whether the transition between the expanded and the collapsed state of the component is animated. By default the animation is enabled.
        */
  @InputDecorator({ transform: booleanAttribute })
  noAnimation!: boolean;
  /**
        Sets the accessible ARIA role of the component.
Depending on the usage, you can change the role from the default \`Form\`
to \`Region\` or \`Complementary\`.
        */
  accessibleRole!: 'Complementary' | 'Form' | 'Region';
  /**
        Defines the \\"aria-level\\" of component heading,
set by the \`headerText\`.
        */
  headerLevel!: 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6';
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Indicates whether the Panel header is sticky or not.
If stickyHeader is set to true, then whenever you scroll the content or
the application, the header of the panel will be always visible and
a solid color will be used for its design.
        */
  @InputDecorator({ transform: booleanAttribute })
  stickyHeader!: boolean;

  /**
     Fired when the component is expanded/collapsed by user interaction.
    */
  ui5Toggle!: EventEmitter<void>;

  private elementRef: ElementRef<Panel> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Panel {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { PanelComponent };
"
`;

exports[`Snapshot test Main Popover should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Popover.js';
import Popover from '@ui5/webcomponents/dist/Popover.js';
import { PopupBeforeCloseEventDetail } from '@ui5/webcomponents/dist/Popup.js';
@ProxyInputs([
  'initialFocus',
  'preventFocusRestore',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'preventInitialFocus',
  'open',
  'headerText',
  'placement',
  'horizontalAlign',
  'verticalAlign',
  'modal',
  'hideArrow',
  'allowTargetOverlap',
  'opener',
])
@ProxyOutputs([
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-popover',
  template: '<ng-content></ng-content>',
  inputs: [
    'initialFocus',
    'preventFocusRestore',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'preventInitialFocus',
    'open',
    'headerText',
    'placement',
    'horizontalAlign',
    'verticalAlign',
    'modal',
    'hideArrow',
    'allowTargetOverlap',
    'opener',
  ],
  outputs: ['ui5BeforeOpen', 'ui5Open', 'ui5BeforeClose', 'ui5Close'],
  exportAs: 'ui5Popover',
})
class PopoverComponent {
  /**
        Defines the ID of the HTML Element, which will get the initial focus.

**Note:** If an element with \`autofocus\` attribute is added inside the component,
\`initialFocus\` won't take effect.
        */
  initialFocus!: string | undefined;
  /**
        Defines if the focus should be returned to the previously focused element,
when the popup closes.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventFocusRestore!: boolean;
  /**
        Defines the accessible name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the IDs of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Allows setting a custom role.
        */
  accessibleRole!: 'None' | 'Dialog' | 'AlertDialog';
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the component.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Indicates whether initial focus should be prevented.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventInitialFocus!: boolean;
  /**
        Indicates if the element is open
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Defines the header text.

**Note:** If \`header\` slot is provided, the \`headerText\` is ignored.
        */
  headerText!: string | undefined;
  /**
        Determines on which side the component is placed at.
        */
  placement!: 'Start' | 'End' | 'Top' | 'Bottom';
  /**
        Determines the horizontal alignment of the component.
        */
  horizontalAlign!: 'Center' | 'Start' | 'End' | 'Stretch';
  /**
        Determines the vertical alignment of the component.
        */
  verticalAlign!: 'Center' | 'Top' | 'Bottom' | 'Stretch';
  /**
        Defines whether the component should close when
clicking/tapping outside of the popover.
If enabled, it blocks any interaction with the background.
        */
  @InputDecorator({ transform: booleanAttribute })
  modal!: boolean;
  /**
        Determines whether the component arrow is hidden.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideArrow!: boolean;
  /**
        Determines if there is no enough space, the component can be placed
over the target.
        */
  @InputDecorator({ transform: booleanAttribute })
  allowTargetOverlap!: boolean;
  /**
        Defines the ID or DOM Reference of the element at which the popover is shown.
When using this attribute in a declarative way, you must only use the \`id\` (as a string) of the element at which you want to show the popover.
You can only set the \`opener\` attribute to a DOM Reference when using JavaScript.
        */
  opener!: HTMLElement | string | null | undefined;

  /**
     Fired before the component is opened. This event can be cancelled, which will prevent the popup from opening.
    */
  ui5BeforeOpen!: EventEmitter<void>;
  /**
     Fired after the component is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the component is closed. This event can be cancelled, which will prevent the popup from closing.
    */
  ui5BeforeClose!: EventEmitter<PopupBeforeCloseEventDetail>;
  /**
     Fired after the component is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Popover> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Popover {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { PopoverComponent };
"
`;

exports[`Snapshot test Main Progress Indicator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ProgressIndicator.js';
import ProgressIndicator from '@ui5/webcomponents/dist/ProgressIndicator.js';
@ProxyInputs([
  'accessibleName',
  'hideValue',
  'value',
  'displayValue',
  'valueState',
])
@Component({
  standalone: true,
  selector: 'ui5-progress-indicator',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleName',
    'hideValue',
    'value',
    'displayValue',
    'valueState',
  ],
  exportAs: 'ui5ProgressIndicator',
})
class ProgressIndicatorComponent {
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines whether the component value is shown.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideValue!: boolean;
  /**
        Specifies the numerical value in percent for the length of the component.

**Note:**
If a value greater than 100 is provided, the percentValue is set to 100. In other cases of invalid value, percentValue is set to its default of 0.
        */
  value!: number;
  /**
        Specifies the text value to be displayed in the bar.

**Note:**

- If there is no value provided or the value is empty, the default percentage value is shown.
- If \`hideValue\` property is \`true\` both the \`displayValue\` and \`value\` property values are not shown.
        */
  displayValue!: string | undefined;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';

  private elementRef: ElementRef<ProgressIndicator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ProgressIndicator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ProgressIndicatorComponent };
"
`;

exports[`Snapshot test Main Radio Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/RadioButton.js';
import RadioButton from '@ui5/webcomponents/dist/RadioButton.js';
@ProxyInputs([
  'disabled',
  'readonly',
  'required',
  'checked',
  'text',
  'valueState',
  'name',
  'value',
  'wrappingType',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-radio-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'readonly',
    'required',
    'checked',
    'text',
    'valueState',
    'name',
    'value',
    'wrappingType',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change'],
  exportAs: 'ui5RadioButton',
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange?.(cvaValue);' },
})
class RadioButtonComponent {
  /**
        Defines whether the component is disabled.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines whether the component is read-only.

**Note:** A read-only component isn't editable or selectable.
However, because it's focusable, it still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines whether the component is checked or not.

**Note:** The property value can be changed with user interaction,
either by clicking/tapping on the component,
or by using the Space or Enter key.

**Note:** Only enabled radio buttons can be checked.
Read-only radio buttons are not selectable, and therefore are always unchecked.
        */
  @InputDecorator({ transform: booleanAttribute })
  checked!: boolean;
  /**
        Defines the text of the component.
        */
  text!: string | undefined;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

Radio buttons with the same \`name\` will form a radio button group.

**Note:** By this name the component will be identified upon submission in an HTML form.

**Note:** The selection can be changed with \`ARROW_UP/DOWN\` and \`ARROW_LEFT/RIGHT\` keys between radio buttons in same group.

**Note:** Only one radio button can be selected per group.
        */
  name!: string | undefined;
  /**
        Defines the form value of the component.
When a form with a radio button group is submitted, the group's value
will be the value of the currently selected radio button.
        */
  value!: string;
  /**
        Defines whether the component text wraps when there is not enough space.

**Note:** for option \\"Normal\\" the text will wrap and the words will not be broken based on hyphenation.
        */
  wrappingType!: 'None' | 'Normal';
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the IDs of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;

  /**
     Fired when the component checked state changes.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<RadioButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): RadioButton {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val: string) {
    this.element.checked = this.element.value === val;
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { RadioButtonComponent };
"
`;

exports[`Snapshot test Main Range Slider should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/RangeSlider.js';
import RangeSlider from '@ui5/webcomponents/dist/RangeSlider.js';
@ProxyInputs([
  'min',
  'max',
  'name',
  'step',
  'labelInterval',
  'showTickmarks',
  'showTooltip',
  'editableTooltip',
  'disabled',
  'accessibleName',
  'startValue',
  'endValue',
])
@ProxyOutputs(['change: ui5Change', 'input: ui5Input'])
@Component({
  standalone: true,
  selector: 'ui5-range-slider',
  template: '<ng-content></ng-content>',
  inputs: [
    'min',
    'max',
    'name',
    'step',
    'labelInterval',
    'showTickmarks',
    'showTooltip',
    'editableTooltip',
    'disabled',
    'accessibleName',
    'startValue',
    'endValue',
  ],
  outputs: ['ui5Change', 'ui5Input'],
  exportAs: 'ui5RangeSlider',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class RangeSliderComponent {
  /**
        Defines the minimum value of the slider.
        */
  min!: number;
  /**
        Defines the maximum value of the slider.
        */
  max!: number;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).

**Note:** If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.
        */
  step!: number;
  /**
        Displays a label with a value on every N-th step.

**Note:** The step and tickmarks properties must be enabled.
Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second
tickmark will be labelled, which means every 4th value number.
        */
  labelInterval!: number;
  /**
        Enables tickmarks visualization for each step.

**Note:** The step must be a positive number.
        */
  @InputDecorator({ transform: booleanAttribute })
  showTickmarks!: boolean;
  /**
        Enables handle tooltip displaying the current value.
        */
  @InputDecorator({ transform: booleanAttribute })
  showTooltip!: boolean;
  /**
        
Indicates whether input fields should be used as tooltips for the handles.

**Note:** Setting this option to true will only work if showTooltip is set to true.
**Note:** In order for the component to comply with the accessibility standard, it is recommended to set the editableTooltip property to true.
        */
  @InputDecorator({ transform: booleanAttribute })
  editableTooltip!: boolean;
  /**
        Defines whether the slider is in disabled state.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines start point of a selection - position of a first handle on the slider.
        */
  startValue!: number;
  /**
        Defines end point of a selection - position of a second handle on the slider.
        */
  endValue!: number;

  /**
     Fired when the value changes and the user has finished interacting with the slider.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.
    */
  ui5Input!: EventEmitter<void>;

  private elementRef: ElementRef<RangeSlider> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): RangeSlider {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.startValue = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.startValue;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { RangeSliderComponent };
"
`;

exports[`Snapshot test Main Rating Indicator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/RatingIndicator.js';
import RatingIndicator from '@ui5/webcomponents/dist/RatingIndicator.js';
@ProxyInputs([
  'value',
  'max',
  'size',
  'disabled',
  'readonly',
  'accessibleName',
  'accessibleNameRef',
  'required',
  'tooltip',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-rating-indicator',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'max',
    'size',
    'disabled',
    'readonly',
    'accessibleName',
    'accessibleNameRef',
    'required',
    'tooltip',
  ],
  outputs: ['ui5Change'],
  exportAs: 'ui5RatingIndicator',
})
class RatingIndicatorComponent {
  /**
        The indicated value of the rating.

**Note:** If you set a number which is not round, it would be shown as follows:

- 1.0 - 1.2 -> 1
- 1.3 - 1.7 -> 1.5
- 1.8 - 1.9 -> 2
        */
  value!: number;
  /**
        The number of displayed rating symbols.
        */
  max!: number;
  /**
        Defines the size of the component.
        */
  size!: 'S' | 'M' | 'L';
  /**
        Defines whether the component is disabled.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines the tooltip of the component.
        */
  tooltip!: string | undefined;

  /**
     The event is fired when the value changes.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<RatingIndicator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): RatingIndicator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { RatingIndicatorComponent };
"
`;

exports[`Snapshot test Main Responsive Popover should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { PopupBeforeCloseEventDetail } from '@ui5/webcomponents/dist/Popup.js';
import '@ui5/webcomponents/dist/ResponsivePopover.js';
import ResponsivePopover from '@ui5/webcomponents/dist/ResponsivePopover.js';
@ProxyInputs([
  'initialFocus',
  'preventFocusRestore',
  'accessibleName',
  'accessibleNameRef',
  'accessibleRole',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'preventInitialFocus',
  'open',
  'headerText',
  'placement',
  'horizontalAlign',
  'verticalAlign',
  'modal',
  'hideArrow',
  'allowTargetOverlap',
  'opener',
])
@ProxyOutputs([
  'before-open: ui5BeforeOpen',
  'open: ui5Open',
  'before-close: ui5BeforeClose',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-responsive-popover',
  template: '<ng-content></ng-content>',
  inputs: [
    'initialFocus',
    'preventFocusRestore',
    'accessibleName',
    'accessibleNameRef',
    'accessibleRole',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'preventInitialFocus',
    'open',
    'headerText',
    'placement',
    'horizontalAlign',
    'verticalAlign',
    'modal',
    'hideArrow',
    'allowTargetOverlap',
    'opener',
  ],
  outputs: ['ui5BeforeOpen', 'ui5Open', 'ui5BeforeClose', 'ui5Close'],
  exportAs: 'ui5ResponsivePopover',
})
class ResponsivePopoverComponent {
  /**
        Defines the ID of the HTML Element, which will get the initial focus.

**Note:** If an element with \`autofocus\` attribute is added inside the component,
\`initialFocus\` won't take effect.
        */
  initialFocus!: string | undefined;
  /**
        Defines if the focus should be returned to the previously focused element,
when the popup closes.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventFocusRestore!: boolean;
  /**
        Defines the accessible name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the IDs of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Allows setting a custom role.
        */
  accessibleRole!: 'None' | 'Dialog' | 'AlertDialog';
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the component.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Indicates whether initial focus should be prevented.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventInitialFocus!: boolean;
  /**
        Indicates if the element is open
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Defines the header text.

**Note:** If \`header\` slot is provided, the \`headerText\` is ignored.
        */
  headerText!: string | undefined;
  /**
        Determines on which side the component is placed at.
        */
  placement!: 'Start' | 'End' | 'Top' | 'Bottom';
  /**
        Determines the horizontal alignment of the component.
        */
  horizontalAlign!: 'Center' | 'Start' | 'End' | 'Stretch';
  /**
        Determines the vertical alignment of the component.
        */
  verticalAlign!: 'Center' | 'Top' | 'Bottom' | 'Stretch';
  /**
        Defines whether the component should close when
clicking/tapping outside of the popover.
If enabled, it blocks any interaction with the background.
        */
  @InputDecorator({ transform: booleanAttribute })
  modal!: boolean;
  /**
        Determines whether the component arrow is hidden.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideArrow!: boolean;
  /**
        Determines if there is no enough space, the component can be placed
over the target.
        */
  @InputDecorator({ transform: booleanAttribute })
  allowTargetOverlap!: boolean;
  /**
        Defines the ID or DOM Reference of the element at which the popover is shown.
When using this attribute in a declarative way, you must only use the \`id\` (as a string) of the element at which you want to show the popover.
You can only set the \`opener\` attribute to a DOM Reference when using JavaScript.
        */
  opener!: HTMLElement | string | null | undefined;

  /**
     Fired before the component is opened. This event can be cancelled, which will prevent the popup from opening.
    */
  ui5BeforeOpen!: EventEmitter<void>;
  /**
     Fired after the component is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired before the component is closed. This event can be cancelled, which will prevent the popup from closing.
    */
  ui5BeforeClose!: EventEmitter<PopupBeforeCloseEventDetail>;
  /**
     Fired after the component is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<ResponsivePopover> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ResponsivePopover {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ResponsivePopoverComponent };
"
`;

exports[`Snapshot test Main Segmented Button Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SegmentedButtonItem.js';
import SegmentedButtonItem from '@ui5/webcomponents/dist/SegmentedButtonItem.js';
@ProxyInputs([
  'disabled',
  'selected',
  'tooltip',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'icon',
])
@Component({
  standalone: true,
  selector: 'ui5-segmented-button-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'selected',
    'tooltip',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'icon',
  ],
  exportAs: 'ui5SegmentedButtonItem',
})
class SegmentedButtonItemComponent {
  /**
        Defines whether the component is disabled.
A disabled component can't be selected or
focused, and it is not in the tab chain.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Determines whether the component is displayed as selected.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;
  /**
        Defines the tooltip of the component.

**Note:** A tooltip attribute should be provided for icon-only buttons, in order to represent their exact meaning/function.
        */
  tooltip!: string | undefined;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Defines the IDs of the HTML Elements that describe the component.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Defines the icon, displayed as graphical element within the component.
The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;

  private elementRef: ElementRef<SegmentedButtonItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SegmentedButtonItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SegmentedButtonItemComponent };
"
`;

exports[`Snapshot test Main Segmented Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SegmentedButton.js';
import {
  default as SegmentedButton,
  SegmentedButtonSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/SegmentedButton.js';
@ProxyInputs([
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'selectionMode',
])
@ProxyOutputs(['selection-change: ui5SelectionChange'])
@Component({
  standalone: true,
  selector: 'ui5-segmented-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'selectionMode',
  ],
  outputs: ['ui5SelectionChange'],
  exportAs: 'ui5SegmentedButton',
})
class SegmentedButtonComponent {
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the IDs of the HTML Elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Defines the IDs of the HTML Elements that describe the component.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Defines the component selection mode.
        */
  selectionMode!: 'Single' | 'Multiple';

  /**
     Fired when the selected item changes.
    */
  ui5SelectionChange!: EventEmitter<SegmentedButtonSelectionChangeEventDetail>;

  private elementRef: ElementRef<SegmentedButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SegmentedButton {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SegmentedButtonComponent };
"
`;

exports[`Snapshot test Main Select should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Select.js';
import {
  default as Select,
  SelectChangeEventDetail,
  SelectLiveChangeEventDetail,
} from '@ui5/webcomponents/dist/Select.js';
@ProxyInputs([
  'disabled',
  'name',
  'valueState',
  'required',
  'readonly',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
  'tooltip',
  'value',
])
@ProxyOutputs([
  'change: ui5Change',
  'live-change: ui5LiveChange',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-select',
  template: '<ng-content></ng-content>',
  inputs: [
    'disabled',
    'name',
    'valueState',
    'required',
    'readonly',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
    'tooltip',
    'value',
  ],
  outputs: ['ui5Change', 'ui5LiveChange', 'ui5Open', 'ui5Close'],
  exportAs: 'ui5Select',
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange?.(cvaValue);' },
})
class SelectComponent {
  /**
        Defines whether the component is in disabled state.

**Note:** A disabled component is noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the select.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the select.
        */
  accessibleDescriptionRef!: string | undefined;
  /**
        Defines the tooltip of the select.
        */
  tooltip!: string | undefined;
  /**
        Defines the value of the component:

- when get - returns the value of the component or the value/text content of the selected option.
- when set - selects the option with matching \`value\` property or text content.

**Note:** Use either the Select's value or the Options' selected property.
Mixed usage could result in unexpected behavior.

**Note:** If the given value does not match any existing option,
no option will be selected and the Select component will be displayed as empty.
        */
  value!: string;

  /**
     Fired when the selected option changes.
    */
  ui5Change!: EventEmitter<SelectChangeEventDetail>;
  /**
     Fired when the user navigates through the options, but the selection is not finalized,
or when pressing the ESC key to revert the current selection.
    */
  ui5LiveChange!: EventEmitter<SelectLiveChangeEventDetail>;
  /**
     Fired after the component's dropdown menu opens.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the component's dropdown menu closes.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Select> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): Select {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { SelectComponent };
"
`;

exports[`Snapshot test Main Slider should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Slider.js';
import Slider from '@ui5/webcomponents/dist/Slider.js';
@ProxyInputs([
  'min',
  'max',
  'name',
  'step',
  'labelInterval',
  'showTickmarks',
  'showTooltip',
  'editableTooltip',
  'disabled',
  'accessibleName',
  'value',
])
@ProxyOutputs(['change: ui5Change', 'input: ui5Input'])
@Component({
  standalone: true,
  selector: 'ui5-slider',
  template: '<ng-content></ng-content>',
  inputs: [
    'min',
    'max',
    'name',
    'step',
    'labelInterval',
    'showTickmarks',
    'showTooltip',
    'editableTooltip',
    'disabled',
    'accessibleName',
    'value',
  ],
  outputs: ['ui5Change', 'ui5Input'],
  exportAs: 'ui5Slider',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class SliderComponent {
  /**
        Defines the minimum value of the slider.
        */
  min!: number;
  /**
        Defines the maximum value of the slider.
        */
  max!: number;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).

**Note:** If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.
        */
  step!: number;
  /**
        Displays a label with a value on every N-th step.

**Note:** The step and tickmarks properties must be enabled.
Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second
tickmark will be labelled, which means every 4th value number.
        */
  labelInterval!: number;
  /**
        Enables tickmarks visualization for each step.

**Note:** The step must be a positive number.
        */
  @InputDecorator({ transform: booleanAttribute })
  showTickmarks!: boolean;
  /**
        Enables handle tooltip displaying the current value.
        */
  @InputDecorator({ transform: booleanAttribute })
  showTooltip!: boolean;
  /**
        
Indicates whether input fields should be used as tooltips for the handles.

**Note:** Setting this option to true will only work if showTooltip is set to true.
**Note:** In order for the component to comply with the accessibility standard, it is recommended to set the editableTooltip property to true.
        */
  @InputDecorator({ transform: booleanAttribute })
  editableTooltip!: boolean;
  /**
        Defines whether the slider is in disabled state.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Current value of the slider
        */
  value!: number;

  /**
     Fired when the value changes and the user has finished interacting with the slider.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.
    */
  ui5Input!: EventEmitter<void>;

  private elementRef: ElementRef<Slider> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): Slider {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { SliderComponent };
"
`;

exports[`Snapshot test Main Special Calendar Date should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SpecialCalendarDate.js';
import SpecialCalendarDate from '@ui5/webcomponents/dist/SpecialCalendarDate.js';
@ProxyInputs(['value', 'type'])
@Component({
  standalone: true,
  selector: 'ui5-special-date',
  template: '<ng-content></ng-content>',
  inputs: ['value', 'type'],
  exportAs: 'ui5SpecialDate',
})
class SpecialCalendarDateComponent {
  /**
        The date formatted according to the \`formatPattern\` property
of the \`ui5-calendar\` that hosts the component.
        */
  value!: string;
  /**
        Defines the type of the special date.
        */
  type!:
    | 'None'
    | 'Working'
    | 'NonWorking'
    | 'Type01'
    | 'Type02'
    | 'Type03'
    | 'Type04'
    | 'Type05'
    | 'Type06'
    | 'Type07'
    | 'Type08'
    | 'Type09'
    | 'Type10'
    | 'Type11'
    | 'Type12'
    | 'Type13'
    | 'Type14'
    | 'Type15'
    | 'Type16'
    | 'Type17'
    | 'Type18'
    | 'Type19'
    | 'Type20';

  private elementRef: ElementRef<SpecialCalendarDate> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SpecialCalendarDate {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SpecialCalendarDateComponent };
"
`;

exports[`Snapshot test Main Split Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SplitButton.js';
import {
  default as SplitButton,
  SplitButtonAccessibilityAttributes,
} from '@ui5/webcomponents/dist/SplitButton.js';
@ProxyInputs([
  'icon',
  'activeArrowButton',
  'design',
  'disabled',
  'accessibleName',
  'accessibilityAttributes',
])
@ProxyOutputs(['click: ui5Click', 'arrow-click: ui5ArrowClick'])
@Component({
  standalone: true,
  selector: 'ui5-split-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'icon',
    'activeArrowButton',
    'design',
    'disabled',
    'accessibleName',
    'accessibilityAttributes',
  ],
  outputs: ['ui5Click', 'ui5ArrowClick'],
  exportAs: 'ui5SplitButton',
})
class SplitButtonComponent {
  /**
        Defines the icon to be displayed as graphical element within the component.
The SAP-icons font provides numerous options.

Example:

See all available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines whether the arrow button should have the active state styles or not.
        */
  @InputDecorator({ transform: booleanAttribute })
  activeArrowButton!: boolean;
  /**
        Defines the component design.
        */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';
  /**
        Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The \`accessibilityAttributes\` property accepts an object with the following optional fields:

- **root**: Attributes that will be applied to the main (text) button.
  - **hasPopup**: Indicates the presence and type of popup triggered by the button.
    Accepts string values: \`\\"dialog\\"\`, \`\\"grid\\"\`, \`\\"listbox\\"\`, \`\\"menu\\"\`, or \`\\"tree\\"\`.
  - **roleDescription**: Provides a human-readable description for the role of the button.
    Accepts any string value.
  - **title**: Specifies a tooltip or description for screen readers.
    Accepts any string value.
	- **ariaKeyShortcuts**: Defines keyboard shortcuts that activate or give focus to the button.

- **arrowButton**: Attributes applied specifically to the arrow (split) button.
  - **hasPopup**: Indicates the presence and type of popup triggered by the arrow button.
    Accepts string values: \`\\"dialog\\"\`, \`\\"grid\\"\`, \`\\"listbox\\"\`, \`\\"menu\\"\`, or \`\\"tree\\"\`.
  - **expanded**: Indicates whether the popup triggered by the arrow button is currently expanded.
    Accepts boolean values: \`true\` or \`false\`.
        */
  accessibilityAttributes!: SplitButtonAccessibilityAttributes;

  /**
     Fired when the user clicks on the default action.
    */
  ui5Click!: EventEmitter<void>;
  /**
     Fired when the user clicks on the arrow action.
    */
  ui5ArrowClick!: EventEmitter<void>;

  private elementRef: ElementRef<SplitButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SplitButton {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SplitButtonComponent };
"
`;

exports[`Snapshot test Main Step Input should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/StepInput.js';
import {
  default as StepInput,
  StepInputValueStateChangeEventDetail,
} from '@ui5/webcomponents/dist/StepInput.js';
@ProxyInputs([
  'value',
  'min',
  'max',
  'step',
  'valueState',
  'required',
  'disabled',
  'readonly',
  'placeholder',
  'name',
  'valuePrecision',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'value-state-change: ui5ValueStateChange',
])
@Component({
  standalone: true,
  selector: 'ui5-step-input',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'min',
    'max',
    'step',
    'valueState',
    'required',
    'disabled',
    'readonly',
    'placeholder',
    'name',
    'valuePrecision',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5ValueStateChange'],
  exportAs: 'ui5StepInput',
})
class StepInputComponent {
  /**
        Defines a value of the component.
        */
  value!: number;
  /**
        Defines a minimum value of the component.
        */
  min!: number | undefined;
  /**
        Defines a maximum value of the component.
        */
  max!: number | undefined;
  /**
        Defines a step of increasing/decreasing the value of the component.
        */
  step!: number;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Determines whether the component is displayed as disabled.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Determines whether the component is displayed as read-only.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
        */
  placeholder!: string | undefined;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Determines the number of digits after the decimal point of the component.
        */
  valuePrecision!: number;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;

  /**
     Fired when the input operation has finished by pressing Enter or on focusout.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke.
    */
  ui5Input!: EventEmitter<void>;
  /**
     Fired before the value state of the component is updated internally.
The event is preventable, meaning that if it's default action is
prevented, the component will not update the value state.
    */
  ui5ValueStateChange!: EventEmitter<StepInputValueStateChangeEventDetail>;

  private elementRef: ElementRef<StepInput> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): StepInput {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { StepInputComponent };
"
`;

exports[`Snapshot test Main Suggestion Item Custom should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SuggestionItemCustom.js';
import SuggestionItemCustom from '@ui5/webcomponents/dist/SuggestionItemCustom.js';
@ProxyInputs(['text'])
@Component({
  standalone: true,
  selector: 'ui5-suggestion-item-custom',
  template: '<ng-content></ng-content>',
  inputs: ['text'],
  exportAs: 'ui5SuggestionItemCustom',
})
class SuggestionItemCustomComponent {
  /**
        Defines the text of the \`ui5-suggestion-item-custom\`.
**Note:** The text property is considered only for autocomplete.
        */
  text!: string | undefined;

  private elementRef: ElementRef<SuggestionItemCustom> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SuggestionItemCustom {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SuggestionItemCustomComponent };
"
`;

exports[`Snapshot test Main Suggestion Item Group should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemGroupMoveEventDetail } from '@ui5/webcomponents/dist/ListItemGroup.js';
import '@ui5/webcomponents/dist/SuggestionItemGroup.js';
import SuggestionItemGroup from '@ui5/webcomponents/dist/SuggestionItemGroup.js';
@ProxyInputs(['headerText', 'headerAccessibleName', 'wrappingType'])
@ProxyOutputs(['move-over: ui5MoveOver', 'move: ui5Move'])
@Component({
  standalone: true,
  selector: 'ui5-suggestion-item-group',
  template: '<ng-content></ng-content>',
  inputs: ['headerText', 'headerAccessibleName', 'wrappingType'],
  outputs: ['ui5MoveOver', 'ui5Move'],
  exportAs: 'ui5SuggestionItemGroup',
})
class SuggestionItemGroupComponent {
  /**
        Defines the header text of the <code>ui5-li-group</code>.
        */
  headerText!: string | undefined;
  /**
        Defines the accessible name of the header.
        */
  headerAccessibleName!: string | undefined;
  /**
        Defines if the text of the component should wrap when it's too long.
When set to \\"Normal\\", the content (title, description) will be wrapped
using the \`ui5-expandable-text\` component.<br/>

The text can wrap up to 100 characters on small screens (size S) and
up to 300 characters on larger screens (size M and above). When text exceeds
these limits, it truncates with an ellipsis followed by a text expansion trigger.

Available options are:
- \`None\` (default) - The text will truncate with an ellipsis.
- \`Normal\` - The text will wrap (without truncation).
        */
  wrappingType!: 'None' | 'Normal';

  /**
     Fired when a movable list item is moved over a potential drop target during a dragging operation.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5MoveOver!: EventEmitter<ListItemGroupMoveEventDetail>;
  /**
     Fired when a movable list item is dropped onto a drop target.

**Note:** \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.
    */
  ui5Move!: EventEmitter<ListItemGroupMoveEventDetail>;

  private elementRef: ElementRef<SuggestionItemGroup> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SuggestionItemGroup {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SuggestionItemGroupComponent };
"
`;

exports[`Snapshot test Main Suggestion Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/SuggestionItem.js';
import SuggestionItem from '@ui5/webcomponents/dist/SuggestionItem.js';
@ProxyInputs(['text', 'additionalText'])
@Component({
  standalone: true,
  selector: 'ui5-suggestion-item',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'additionalText'],
  exportAs: 'ui5SuggestionItem',
})
class SuggestionItemComponent {
  /**
        Defines the text of the component.
        */
  text!: string | undefined;
  /**
        Defines the \`additionalText\`, displayed in the end of the item.
        */
  additionalText!: string | undefined;

  private elementRef: ElementRef<SuggestionItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): SuggestionItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { SuggestionItemComponent };
"
`;

exports[`Snapshot test Main Switch should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Switch.js';
import Switch from '@ui5/webcomponents/dist/Switch.js';
@ProxyInputs([
  'design',
  'checked',
  'disabled',
  'textOn',
  'textOff',
  'accessibleName',
  'accessibleNameRef',
  'tooltip',
  'required',
  'name',
  'value',
])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-switch',
  template: '<ng-content></ng-content>',
  inputs: [
    'design',
    'checked',
    'disabled',
    'textOn',
    'textOff',
    'accessibleName',
    'accessibleNameRef',
    'tooltip',
    'required',
    'name',
    'value',
  ],
  outputs: ['ui5Change'],
  exportAs: 'ui5Switch',
  hostDirectives: [GenericControlValueAccessor],
  host: { '(change)': '_cva?.onChange?.(cvaValue);' },
})
class SwitchComponent {
  /**
        Defines the component design.

**Note:** If \`Graphical\` type is set,
positive and negative icons will replace the \`textOn\` and \`textOff\`.
        */
  design!: 'Textual' | 'Graphical';
  /**
        Defines if the component is checked.

**Note:** The property can be changed with user interaction,
either by cliking the component, or by pressing the \`Enter\` or \`Space\` key.
        */
  @InputDecorator({ transform: booleanAttribute })
  checked!: boolean;
  /**
        Defines whether the component is disabled.

**Note:** A disabled component is noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the text, displayed when the component is checked.

**Note:** We recommend using short texts, up to 3 letters (larger texts would be cut off).
        */
  textOn!: string | undefined;
  /**
        Defines the text, displayed when the component is not checked.

**Note:** We recommend using short texts, up to 3 letters (larger texts would be cut off).
        */
  textOff!: string | undefined;
  /**
        Sets the accessible ARIA name of the component.

**Note**: We recommend that you set an accessibleNameRef pointing to an external label or at least an \`accessibleName\`.
Providing an \`accessibleNameRef\` or an \`accessibleName\` is mandatory in the cases when \`textOn\` and \`textOff\` properties aren't set.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.

**Note**: We recommend that you set an accessibleNameRef pointing to an external label or at least an \`accessibleName\`.
Providing an \`accessibleNameRef\` or an \`accessibleName\` is mandatory in the cases when \`textOn\` and \`textOff\` properties aren't set.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the tooltip of the component.

**Note:** If applicable an external label reference should always be the preferred option to provide context to the \`ui5-switch\` component over a tooltip.
        */
  tooltip!: string | undefined;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the form value of the component.
        */
  value!: string;

  /**
     Fired when the component checked state changes.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<Switch> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): Switch {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.checked = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.checked;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { SwitchComponent };
"
`;

exports[`Snapshot test Main Tab Container should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TabContainer.js';
import {
  default as TabContainer,
  TabContainerMoveEventDetail,
  TabContainerTabSelectEventDetail,
} from '@ui5/webcomponents/dist/TabContainer.js';
@ProxyInputs([
  'collapsed',
  'tabLayout',
  'overflowMode',
  'headerBackgroundDesign',
  'contentBackgroundDesign',
  'noAutoSelection',
])
@ProxyOutputs([
  'tab-select: ui5TabSelect',
  'move-over: ui5MoveOver',
  'move: ui5Move',
])
@Component({
  standalone: true,
  selector: 'ui5-tabcontainer',
  template: '<ng-content></ng-content>',
  inputs: [
    'collapsed',
    'tabLayout',
    'overflowMode',
    'headerBackgroundDesign',
    'contentBackgroundDesign',
    'noAutoSelection',
  ],
  outputs: ['ui5TabSelect', 'ui5MoveOver', 'ui5Move'],
  exportAs: 'ui5Tabcontainer',
})
class TabContainerComponent {
  /**
        Defines whether the tab content is collapsed.
        */
  @InputDecorator({ transform: booleanAttribute })
  collapsed!: boolean;
  /**
        Defines the alignment of the content and the \`additionalText\` of a tab.

**Note:**
The content and the \`additionalText\` would be displayed vertically by default,
but when set to \`Inline\`, they would be displayed horizontally.
        */
  tabLayout!: 'Inline' | 'Standard';
  /**
        Defines the overflow mode of the header (the tab strip). If you have a large number of tabs, only the tabs that can fit on screen will be visible.
All other tabs that can 't fit on the screen are available in an overflow tab \\"More\\".

**Note:**
Only one overflow at the end would be displayed by default,
but when set to \`StartAndEnd\`, there will be two overflows on both ends, and tab order will not change on tab selection.
        */
  overflowMode!: 'End' | 'StartAndEnd';
  /**
        Sets the background color of the Tab Container's header as \`Solid\`, \`Transparent\`, or \`Translucent\`.
        */
  headerBackgroundDesign!: 'Solid' | 'Transparent' | 'Translucent';
  /**
        Sets the background color of the Tab Container's content as \`Solid\`, \`Transparent\`, or \`Translucent\`.
        */
  contentBackgroundDesign!: 'Solid' | 'Transparent' | 'Translucent';
  /**
        Defines if automatic tab selection is deactivated.

**Note:** By default, if none of the child tabs have the \`selected\` property set, the first tab will be automatically selected.
Setting this property to \`true\` allows preventing this behavior.
        */
  @InputDecorator({ transform: booleanAttribute })
  noAutoSelection!: boolean;

  /**
     Fired when a tab is selected.
    */
  ui5TabSelect!: EventEmitter<TabContainerTabSelectEventDetail>;
  /**
     Fired when element is being moved over the tab container.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5MoveOver!: EventEmitter<TabContainerMoveEventDetail>;
  /**
     Fired when element is moved to the tab container.

**Note:** \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.
    */
  ui5Move!: EventEmitter<TabContainerMoveEventDetail>;

  private elementRef: ElementRef<TabContainer> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TabContainer {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TabContainerComponent };
"
`;

exports[`Snapshot test Main Tab Separator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import '@ui5/webcomponents/dist/TabSeparator.js';
import TabSeparator from '@ui5/webcomponents/dist/TabSeparator.js';

@Component({
  standalone: true,
  selector: 'ui5-tab-separator',
  template: '<ng-content></ng-content>',
  exportAs: 'ui5TabSeparator',
})
class TabSeparatorComponent {
  private elementRef: ElementRef<TabSeparator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TabSeparator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TabSeparatorComponent };
"
`;

exports[`Snapshot test Main Tab should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Tab.js';
import Tab from '@ui5/webcomponents/dist/Tab.js';
@ProxyInputs([
  'text',
  'disabled',
  'additionalText',
  'icon',
  'design',
  'selected',
  'movable',
])
@Component({
  standalone: true,
  selector: 'ui5-tab',
  template: '<ng-content></ng-content>',
  inputs: [
    'text',
    'disabled',
    'additionalText',
    'icon',
    'design',
    'selected',
    'movable',
  ],
  exportAs: 'ui5Tab',
})
class TabComponent {
  /**
        The text to be displayed for the item.
        */
  text!: string | undefined;
  /**
        Disabled tabs can't be selected.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Represents the \\"additionalText\\" text, which is displayed in the tab. In the cases when in the same time there are tabs with icons and tabs without icons, if a tab has no icon the \\"additionalText\\" is displayed larger.
        */
  additionalText!: string | undefined;
  /**
        Defines the icon source URI to be displayed as graphical element within the component.
The SAP-icons font provides numerous built-in icons.
See all the available icons in the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines the component's design color.

The design is applied to:

- the component icon
- the \`text\` when the component overflows
- the tab selection line

Available designs are: \`\\"Default\\"\`, \`\\"Neutral\\"\`, \`\\"Positive\\"\`, \`\\"Critical\\"\` and \`\\"Negative\\"\`.

**Note:** The design depends on the current theme.
        */
  design!: 'Default' | 'Positive' | 'Negative' | 'Critical' | 'Neutral';
  /**
        Specifies if the component is selected.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;
  /**
        Defines if the tab is movable.
        */
  @InputDecorator({ transform: booleanAttribute })
  movable!: boolean;

  private elementRef: ElementRef<Tab> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Tab {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TabComponent };
"
`;

exports[`Snapshot test Main Table Cell should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableCell.js';
import TableCell from '@ui5/webcomponents/dist/TableCell.js';
@ProxyInputs(['horizontalAlign'])
@Component({
  standalone: true,
  selector: 'ui5-table-cell',
  template: '<ng-content></ng-content>',
  inputs: ['horizontalAlign'],
  exportAs: 'ui5TableCell',
})
class TableCellComponent {
  /**
        Determines the horizontal alignment of table cells.
        */
  horizontalAlign!: 'Left' | 'Start' | 'Right' | 'End' | 'Center' | undefined;

  private elementRef: ElementRef<TableCell> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableCell {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableCellComponent };
"
`;

exports[`Snapshot test Main Table Growing should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableGrowing.js';
import TableGrowing from '@ui5/webcomponents/dist/TableGrowing.js';
@ProxyInputs(['mode', 'text', 'subtext'])
@ProxyOutputs(['load-more: ui5LoadMore'])
@Component({
  standalone: true,
  selector: 'ui5-table-growing',
  template: '<ng-content></ng-content>',
  inputs: ['mode', 'text', 'subtext'],
  outputs: ['ui5LoadMore'],
  exportAs: 'ui5TableGrowing',
})
class TableGrowingComponent {
  /**
        Defines the mode of the <code>ui5-table</code> growing.

Available options are:

Button - Shows a More button at the bottom of the table, pressing it will load more rows.

Scroll - The rows are loaded automatically by scrolling to the bottom of the table. If the table is not scrollable,
a growing button will be rendered instead to ensure growing functionality.
        */
  mode!: 'Button' | 'Scroll';
  /**
        Defines the text that will be displayed inside the growing button.
Has no effect when mode is set to \`Scroll\`.

**Note:** When not provided and the mode is set to Button, a default text is displayed, corresponding to the
current language.
        */
  text!: string | undefined;
  /**
        Defines the text that will be displayed below the \`text\` inside the growing button.
Has no effect when mode is set to Scroll.
        */
  subtext!: string | undefined;

  /**
     Fired when the growing button is pressed or the user scrolls to the end of the table.
    */
  ui5LoadMore!: EventEmitter<void>;

  private elementRef: ElementRef<TableGrowing> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableGrowing {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableGrowingComponent };
"
`;

exports[`Snapshot test Main Table Header Cell Action Ai should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableHeaderCellActionAI.js';
import TableHeaderCellActionAI from '@ui5/webcomponents/dist/TableHeaderCellActionAI.js';
import { TableHeaderCellActionClickEventDetail } from '@ui5/webcomponents/dist/TableHeaderCellActionBase.js';

@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-table-header-cell-action-ai',
  template: '<ng-content></ng-content>',
  outputs: ['ui5Click'],
  exportAs: 'ui5TableHeaderCellActionAi',
})
class TableHeaderCellActionAIComponent {
  /**
     Fired when a header cell action is clicked.
    */
  ui5Click!: EventEmitter<TableHeaderCellActionClickEventDetail>;

  private elementRef: ElementRef<TableHeaderCellActionAI> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableHeaderCellActionAI {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableHeaderCellActionAIComponent };
"
`;

exports[`Snapshot test Main Table Header Cell should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableHeaderCell.js';
import TableHeaderCell from '@ui5/webcomponents/dist/TableHeaderCell.js';
@ProxyInputs([
  'horizontalAlign',
  'width',
  'minWidth',
  'importance',
  'popinText',
  'sortIndicator',
  'popinHidden',
])
@Component({
  standalone: true,
  selector: 'ui5-table-header-cell',
  template: '<ng-content></ng-content>',
  inputs: [
    'horizontalAlign',
    'width',
    'minWidth',
    'importance',
    'popinText',
    'sortIndicator',
    'popinHidden',
  ],
  exportAs: 'ui5TableHeaderCell',
})
class TableHeaderCellComponent {
  /**
        Determines the horizontal alignment of table cells.
        */
  horizontalAlign!: 'Left' | 'Start' | 'Right' | 'End' | 'Center' | undefined;
  /**
        Defines the width of the column.

By default, the column will grow and shrink according to the available space.
This will distribute the space proportionally among all columns with no specific width set.

See [\\\\<length\\\\>](https://developer.mozilla.org/en-US/docs/Web/CSS/length) and
[\\\\<percentage\\\\>](https://developer.mozilla.org/en-US/docs/Web/CSS/percentage) for possible width values.
        */
  width!: string | undefined;
  /**
        Defines the minimum width of the column.

If the table is in \`Popin\` mode and the minimum width does not fit anymore,
the column will move into the popin.

By default, the table prevents the column from becoming too small.
Changing this value to a small value might lead to accessibility issues.

**Note:** This property only takes effect for columns with a [\\\\<percentage\\\\>](https://developer.mozilla.org/en-US/docs/Web/CSS/percentage) value
or the default width.
        */
  minWidth!: string | undefined;
  /**
        Defines the importance of the column.

This property affects the popin behaviour.
Columns with higher importance will move into the popin area later then less important
columns.
        */
  importance!: number;
  /**
        The text for the column when it pops in.
        */
  popinText!: string | undefined;
  /**
        Defines the sort indicator of the column.
        */
  sortIndicator!: 'None' | 'Ascending' | 'Descending';
  /**
        Defines if the column is hidden in the popin.

**Note:** Please be aware that hiding the column in the popin might lead to accessibility issues as
users might not be able to access the content of the column on small screens.
        */
  @InputDecorator({ transform: booleanAttribute })
  popinHidden!: boolean;

  private elementRef: ElementRef<TableHeaderCell> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableHeaderCell {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableHeaderCellComponent };
"
`;

exports[`Snapshot test Main Table Header Row should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableHeaderRow.js';
import TableHeaderRow from '@ui5/webcomponents/dist/TableHeaderRow.js';
@ProxyInputs(['sticky'])
@Component({
  standalone: true,
  selector: 'ui5-table-header-row',
  template: '<ng-content></ng-content>',
  inputs: ['sticky'],
  exportAs: 'ui5TableHeaderRow',
})
class TableHeaderRowComponent {
  /**
        Sticks the \`ui5-table-header-row\` to the top of a table.

Note: If used in combination with overflowMode \\"Scroll\\", the table needs a defined height for the sticky header to work as expected.
        */
  @InputDecorator({ transform: booleanAttribute })
  sticky!: boolean;

  private elementRef: ElementRef<TableHeaderRow> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableHeaderRow {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableHeaderRowComponent };
"
`;

exports[`Snapshot test Main Table Row Action Navigation should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableRowActionNavigation.js';
import TableRowActionNavigation from '@ui5/webcomponents/dist/TableRowActionNavigation.js';
@ProxyInputs(['invisible', 'interactive'])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-table-row-action-navigation',
  template: '<ng-content></ng-content>',
  inputs: ['invisible', 'interactive'],
  outputs: ['ui5Click'],
  exportAs: 'ui5TableRowActionNavigation',
})
class TableRowActionNavigationComponent {
  /**
        Defines the visibility of the row action.

**Note:** Invisible row actions still take up space, allowing to hide the action while maintaining its position.
        */
  @InputDecorator({ transform: booleanAttribute })
  invisible!: boolean;
  /**
        Defines the interactive state of the navigation action.
        */
  @InputDecorator({ transform: booleanAttribute })
  interactive!: boolean;

  /**
     Fired when a row action is clicked.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<TableRowActionNavigation> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableRowActionNavigation {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableRowActionNavigationComponent };
"
`;

exports[`Snapshot test Main Table Row Action should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableRowAction.js';
import TableRowAction from '@ui5/webcomponents/dist/TableRowAction.js';
@ProxyInputs(['invisible', 'icon', 'text'])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-table-row-action',
  template: '<ng-content></ng-content>',
  inputs: ['invisible', 'icon', 'text'],
  outputs: ['ui5Click'],
  exportAs: 'ui5TableRowAction',
})
class TableRowActionComponent {
  /**
        Defines the visibility of the row action.

**Note:** Invisible row actions still take up space, allowing to hide the action while maintaining its position.
        */
  @InputDecorator({ transform: booleanAttribute })
  invisible!: boolean;
  /**
        Defines the icon of the row action.

**Note:** For row actions to work properly, this property is mandatory.

**Note:** SAP-icons font provides numerous built-in icons. To find all the available icons, see the
[Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string;
  /**
        Defines the text of the row action.

**Note:** For row actions to work properly, this property is mandatory.
        */
  text!: string;

  /**
     Fired when a row action is clicked.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<TableRowAction> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableRowAction {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableRowActionComponent };
"
`;

exports[`Snapshot test Main Table Row should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableRow.js';
import TableRow from '@ui5/webcomponents/dist/TableRow.js';
@ProxyInputs(['rowKey', 'position', 'interactive', 'navigated', 'movable'])
@Component({
  standalone: true,
  selector: 'ui5-table-row',
  template: '<ng-content></ng-content>',
  inputs: ['rowKey', 'position', 'interactive', 'navigated', 'movable'],
  exportAs: 'ui5TableRow',
})
class TableRowComponent {
  /**
        Unique identifier of the row.

**Note:** For selection features to work properly, this property is mandatory, and its value must not contain spaces.
        */
  rowKey!: string | undefined;
  /**
        Defines the 0-based position of the row related to the total number of rows within the table when the \`ui5-table-virtualizer\` feature is used.
        */
  position!: number | undefined;
  /**
        Defines the interactive state of the row.
        */
  @InputDecorator({ transform: booleanAttribute })
  interactive!: boolean;
  /**
        Defines the navigated state of the row.
        */
  @InputDecorator({ transform: booleanAttribute })
  navigated!: boolean;
  /**
        Defines whether the row is movable.
        */
  @InputDecorator({ transform: booleanAttribute })
  movable!: boolean;

  private elementRef: ElementRef<TableRow> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableRow {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableRowComponent };
"
`;

exports[`Snapshot test Main Table Selection Multi should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableSelectionMulti.js';
import TableSelectionMulti from '@ui5/webcomponents/dist/TableSelectionMulti.js';
@ProxyInputs(['selected', 'behavior', 'headerSelector'])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-table-selection-multi',
  template: '<ng-content></ng-content>',
  inputs: ['selected', 'behavior', 'headerSelector'],
  outputs: ['ui5Change'],
  exportAs: 'ui5TableSelectionMulti',
})
class TableSelectionMultiComponent {
  /**
        Defines the \`row-key\` values of selected rows, with each value separated by a space.
        */
  selected!: string | undefined;
  /**
        Defines the selection behavior.
        */
  behavior!: 'RowSelector' | 'RowOnly';
  /**
        Defines the selector of the header row.
        */
  headerSelector!: 'SelectAll' | 'ClearAll';

  /**
     Fired when the selection is changed by user interaction.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<TableSelectionMulti> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableSelectionMulti {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableSelectionMultiComponent };
"
`;

exports[`Snapshot test Main Table Selection Single should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableSelectionSingle.js';
import TableSelectionSingle from '@ui5/webcomponents/dist/TableSelectionSingle.js';
@ProxyInputs(['selected', 'behavior'])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-table-selection-single',
  template: '<ng-content></ng-content>',
  inputs: ['selected', 'behavior'],
  outputs: ['ui5Change'],
  exportAs: 'ui5TableSelectionSingle',
})
class TableSelectionSingleComponent {
  /**
        Defines the \`row-key\` value of the selected row.
        */
  selected!: string | undefined;
  /**
        Defines the selection behavior.
        */
  behavior!: 'RowSelector' | 'RowOnly';

  /**
     Fired when the selection is changed by user interaction.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<TableSelectionSingle> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableSelectionSingle {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableSelectionSingleComponent };
"
`;

exports[`Snapshot test Main Table Selection should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableSelection.js';
import TableSelection from '@ui5/webcomponents/dist/TableSelection.js';
@ProxyInputs(['mode', 'selected'])
@ProxyOutputs(['change: ui5Change'])
@Component({
  standalone: true,
  selector: 'ui5-table-selection',
  template: '<ng-content></ng-content>',
  inputs: ['mode', 'selected'],
  outputs: ['ui5Change'],
  exportAs: 'ui5TableSelection',
})
class TableSelectionComponent {
  /**
        Defines the selection mode.
        */
  mode!: 'None' | 'Single' | 'Multiple';
  /**
        Defines the selected rows separated by a space.
        */
  selected!: string;

  /**
     Fired when the selection is changed by user interaction.
    */
  ui5Change!: EventEmitter<void>;

  private elementRef: ElementRef<TableSelection> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableSelection {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableSelectionComponent };
"
`;

exports[`Snapshot test Main Table Virtualizer should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TableVirtualizer.js';
import {
  RangeChangeEventDetail,
  default as TableVirtualizer,
} from '@ui5/webcomponents/dist/TableVirtualizer.js';
@ProxyInputs(['rowHeight', 'rowCount', 'extraRows'])
@ProxyOutputs(['range-change: ui5RangeChange'])
@Component({
  standalone: true,
  selector: 'ui5-table-virtualizer',
  template: '<ng-content></ng-content>',
  inputs: ['rowHeight', 'rowCount', 'extraRows'],
  outputs: ['ui5RangeChange'],
  exportAs: 'ui5TableVirtualizer',
})
class TableVirtualizerComponent {
  /**
        Defines the height of the rows in the table.

**Note:** For virtualization to work properly, this property is mandatory.
        */
  rowHeight!: number;
  /**
        Defines the total count of rows in the table.

**Note:** For virtualization to work properly, this property is mandatory.
        */
  rowCount!: number;
  /**
        Defines the count of extra rows to be rendered at the top and bottom of the table.

**Note:** This property is experimental and may be changed or deleted in the future.
        */
  extraRows!: number;

  /**
     Fired when the virtualizer is changed by user interaction e.g. on scrolling.
    */
  ui5RangeChange!: EventEmitter<RangeChangeEventDetail>;

  private elementRef: ElementRef<TableVirtualizer> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TableVirtualizer {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableVirtualizerComponent };
"
`;

exports[`Snapshot test Main Table should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Table.js';
import {
  default as Table,
  TableMoveEventDetail,
  TableRowActionClickEventDetail,
  TableRowClickEventDetail,
} from '@ui5/webcomponents/dist/Table.js';
@ProxyInputs([
  'accessibleName',
  'accessibleNameRef',
  'noDataText',
  'overflowMode',
  'loading',
  'loadingDelay',
  'rowActionCount',
])
@ProxyOutputs([
  'row-click: ui5RowClick',
  'move-over: ui5MoveOver',
  'move: ui5Move',
  'row-action-click: ui5RowActionClick',
])
@Component({
  standalone: true,
  selector: 'ui5-table',
  template: '<ng-content></ng-content>',
  inputs: [
    'accessibleName',
    'accessibleNameRef',
    'noDataText',
    'overflowMode',
    'loading',
    'loadingDelay',
    'rowActionCount',
  ],
  outputs: ['ui5RowClick', 'ui5MoveOver', 'ui5Move', 'ui5RowActionClick'],
  exportAs: 'ui5Table',
})
class TableComponent {
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Identifies the element (or elements) that labels the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the text to be displayed when there are no rows in the component.
        */
  noDataText!: string | undefined;
  /**
        Defines the mode of the <code>ui5-table</code> overflow behavior.

Available options are:

<code>Scroll</code> - Columns are shown as regular columns and horizontal scrolling is enabled.
<code>Popin</code> - Columns are shown as pop-ins instead of regular columns.
        */
  overflowMode!: 'Scroll' | 'Popin';
  /**
        Defines if the loading indicator should be shown.

**Note:** When the component is loading, it is not interactive.
        */
  @InputDecorator({ transform: booleanAttribute })
  loading!: boolean;
  /**
        Defines the delay in milliseconds, after which the loading indicator will show up for this component.
        */
  loadingDelay!: number;
  /**
        Defines the maximum number of row actions that is displayed, which determines the width of the row action column.

**Note:** It is recommended to use a maximum of 3 row actions, as exceeding this limit may take up too much space on smaller screens.
        */
  rowActionCount!: number;

  /**
     Fired when an interactive row is clicked.

**Note:** This event is not fired if the \`behavior\` property of the selection component is set to \`RowOnly\`.
In that case, use the \`change\` event of the selection component instead.
    */
  ui5RowClick!: EventEmitter<TableRowClickEventDetail>;
  /**
     Fired when a movable item is moved over a potential drop target during a dragging operation.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.

**Note:** If the dragging operation is a cross-browser operation or files are moved to a potential drop target,
the \`source\` parameter will be \`null\`.
    */
  ui5MoveOver!: EventEmitter<TableMoveEventDetail>;
  /**
     Fired when a movable list item is dropped onto a drop target.

**Notes:**

The \`move\` event is fired only if there was a preceding \`move-over\` with prevented default action.

If the dragging operation is a cross-browser operation or files are moved to a potential drop target,
the \`source\` parameter will be \`null\`.
    */
  ui5Move!: EventEmitter<TableMoveEventDetail>;
  /**
     Fired when a row action is clicked.
    */
  ui5RowActionClick!: EventEmitter<TableRowActionClickEventDetail>;

  private elementRef: ElementRef<Table> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Table {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TableComponent };
"
`;

exports[`Snapshot test Main Tag should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Tag.js';
import Tag from '@ui5/webcomponents/dist/Tag.js';
@ProxyInputs([
  'design',
  'colorScheme',
  'hideStateIcon',
  'interactive',
  'wrappingType',
  'size',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-tag',
  template: '<ng-content></ng-content>',
  inputs: [
    'design',
    'colorScheme',
    'hideStateIcon',
    'interactive',
    'wrappingType',
    'size',
  ],
  outputs: ['ui5Click'],
  exportAs: 'ui5Tag',
})
class TagComponent {
  /**
        Defines the design type of the component.
        */
  design!:
    | 'Set1'
    | 'Set2'
    | 'Neutral'
    | 'Information'
    | 'Positive'
    | 'Negative'
    | 'Critical';
  /**
        Defines the color scheme of the component.
There are 10 predefined schemes.
To use one you can set a number from \`\\"1\\"\` to \`\\"10\\"\`. The \`colorScheme\` \`\\"1\\"\` will be set by default.
        */
  colorScheme!: string;
  /**
        Defines if the default state icon is shown.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideStateIcon!: boolean;
  /**
        Defines if the component is interactive (focusable and pressable).
        */
  @InputDecorator({ transform: booleanAttribute })
  interactive!: boolean;
  /**
        Defines how the text of a component will be displayed when there is not enough space.

**Note:** For option \\"Normal\\" the text will wrap and the
words will not be broken based on hyphenation.
        */
  wrappingType!: 'None' | 'Normal';
  /**
        Defines predefined size of the component.
        */
  size!: 'S' | 'L';

  /**
     Fired when the user clicks on an interactive tag.

**Note:** The event will be fired if the \`interactive\` property is \`true\`
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<Tag> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Tag {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TagComponent };
"
`;

exports[`Snapshot test Main Text Area should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TextArea.js';
import {
  default as TextArea,
  TextAreaInputEventDetail,
} from '@ui5/webcomponents/dist/TextArea.js';
@ProxyInputs([
  'value',
  'disabled',
  'readonly',
  'required',
  'placeholder',
  'valueState',
  'rows',
  'maxlength',
  'showExceededText',
  'growing',
  'growingMaxRows',
  'name',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'select: ui5Select',
  'scroll: ui5Scroll',
])
@Component({
  standalone: true,
  selector: 'ui5-textarea',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'disabled',
    'readonly',
    'required',
    'placeholder',
    'valueState',
    'rows',
    'maxlength',
    'showExceededText',
    'growing',
    'growingMaxRows',
    'name',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5Select', 'ui5Scroll'],
  exportAs: 'ui5Textarea',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class TextAreaComponent {
  /**
        Defines the value of the component.
        */
  value!: string;
  /**
        Indicates whether the user can interact with the component or not.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines a short hint intended to aid the user with data entry when the component has no value.
        */
  placeholder!: string | undefined;
  /**
        Defines the value state of the component.

**Note:** If \`maxlength\` property is set,
the component turns into \\"Critical\\" state once the characters exceeds the limit.
In this case, only the \\"Negative\\" state is considered and can be applied.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines the number of visible text rows for the component.

**Notes:**

- If the \`growing\` property is enabled, this property defines the minimum rows to be displayed
in the textarea.
- The CSS \`height\` property wins over the \`rows\` property, if both are set.
        */
  rows!: number;
  /**
        Defines the maximum number of characters that the \`value\` can have.
        */
  maxlength!: number | undefined;
  /**
        Determines whether the characters exceeding the maximum allowed character count are visible
in the component.

If set to \`false\`, the user is not allowed to enter more characters than what is set in the
\`maxlength\` property.
If set to \`true\` the characters exceeding the \`maxlength\` value are selected on
paste and the counter below the component displays their number.
        */
  @InputDecorator({ transform: booleanAttribute })
  showExceededText!: boolean;
  /**
        Enables the component to automatically grow and shrink dynamically with its content.
        */
  @InputDecorator({ transform: booleanAttribute })
  growing!: boolean;
  /**
        Defines the maximum number of rows that the component can grow.
        */
  growingMaxRows!: number;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the textarea.
        */
  accessibleNameRef!: string | undefined;

  /**
     Fired when the text has changed and the focus leaves the component.
    */
  ui5Change!: EventEmitter<void>;
  /**
     Fired when the value of the component changes at each keystroke or when
something is pasted.
    */
  ui5Input!: EventEmitter<TextAreaInputEventDetail>;
  /**
     Fired when some text has been selected.
    */
  ui5Select!: EventEmitter<void>;
  /**
     Fired when textarea is scrolled.
    */
  ui5Scroll!: EventEmitter<void>;

  private elementRef: ElementRef<TextArea> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): TextArea {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { TextAreaComponent };
"
`;

exports[`Snapshot test Main Text should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Text.js';
import Text from '@ui5/webcomponents/dist/Text.js';
@ProxyInputs(['maxLines', 'emptyIndicatorMode'])
@Component({
  standalone: true,
  selector: 'ui5-text',
  template: '<ng-content></ng-content>',
  inputs: ['maxLines', 'emptyIndicatorMode'],
  exportAs: 'ui5Text',
})
class TextComponent {
  /**
        Defines the number of lines the text should wrap before it truncates.
        */
  maxLines!: number;
  /**
        Specifies if an empty indicator should be displayed when there is no text.
        */
  emptyIndicatorMode!: 'Off' | 'On';

  private elementRef: ElementRef<Text> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Text {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TextComponent };
"
`;

exports[`Snapshot test Main Theming should match the snapshot 1`] = `
"import { Injectable } from '@angular/core';
import { WebcomponentsThemingProvider } from '@ui5/webcomponents-ngx/theming';

@Injectable({ providedIn: 'root' })
class Ui5WebcomponentsMainThemingService extends WebcomponentsThemingProvider {
  name = 'ui-5-webcomponents-main-theming-service';
  constructor() {
    super(
      () => import('@ui5/webcomponents/dist/generated/json-imports/Themes.js'),
    );
  }
}

export { Ui5WebcomponentsMainThemingService };
"
`;

exports[`Snapshot test Main Time Picker should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { GenericControlValueAccessor } from '@ui5/webcomponents-ngx/generic-cva';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/TimePicker.js';
import {
  default as TimePicker,
  TimePickerChangeEventDetail,
  TimePickerInputEventDetail,
} from '@ui5/webcomponents/dist/TimePicker.js';
@ProxyInputs([
  'value',
  'name',
  'valueState',
  'disabled',
  'readonly',
  'placeholder',
  'formatPattern',
  'open',
  'required',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
])
@ProxyOutputs([
  'change: ui5Change',
  'input: ui5Input',
  'open: ui5Open',
  'close: ui5Close',
])
@Component({
  standalone: true,
  selector: 'ui5-time-picker',
  template: '<ng-content></ng-content>',
  inputs: [
    'value',
    'name',
    'valueState',
    'disabled',
    'readonly',
    'placeholder',
    'formatPattern',
    'open',
    'required',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
  ],
  outputs: ['ui5Change', 'ui5Input', 'ui5Open', 'ui5Close'],
  exportAs: 'ui5TimePicker',
  hostDirectives: [GenericControlValueAccessor],
  host: {
    '(change)': '_cva?.onChange?.(cvaValue);',
    '(input)': '_cva?.onChange?.(cvaValue);',
  },
})
class TimePickerComponent {
  /**
        Defines a formatted time value.
        */
  value!: string;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  name!: string | undefined;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines the disabled state of the comonent.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the readonly state of the comonent.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines a short hint, intended to aid the user with data entry when the
component has no value.

**Note:** When no placeholder is set, the format pattern is displayed as a placeholder.
Passing an empty string as the value of this property will make the component appear empty - without placeholder or format pattern.
        */
  placeholder!: string | undefined;
  /**
        Determines the format, displayed in the input field.

Example:
HH:mm:ss -> 11:42:35
hh:mm:ss a -> 2:23:15 PM
mm:ss -> 12:04 (only minutes and seconds)
        */
  formatPattern!: string | undefined;
  /**
        Defines the open or closed state of the popover.
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;
  /**
        Defines whether the component is required.
        */
  @InputDecorator({ transform: booleanAttribute })
  required!: boolean;
  /**
        Defines the aria-label attribute for the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id (or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Receives id(or many ids) of the elements that describe the input.
        */
  accessibleDescriptionRef!: string | undefined;

  /**
     Fired when the input operation has finished by clicking the \\"OK\\" button or
when the text in the input field has changed and the focus leaves the input field.
    */
  ui5Change!: EventEmitter<TimePickerChangeEventDetail>;
  /**
     Fired when the value of the \`ui5-time-picker\` is changed at each key stroke.
    */
  ui5Input!: EventEmitter<TimePickerInputEventDetail>;
  /**
     Fired after the value-help dialog of the component is opened.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the value-help dialog of the component is closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<TimePicker> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);
  protected _cva = inject(GenericControlValueAccessor);

  get element(): TimePicker {
    return this.elementRef.nativeElement;
  }

  set cvaValue(val) {
    this.element.value = val;
    this.cdr.detectChanges();
  }
  get cvaValue() {
    return this.element.value;
  }

  constructor() {
    this.cdr.detach();
    this._cva.host = this;
  }
}
export { TimePickerComponent };
"
`;

exports[`Snapshot test Main Title should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Title.js';
import Title from '@ui5/webcomponents/dist/Title.js';
@ProxyInputs(['wrappingType', 'level', 'size'])
@Component({
  standalone: true,
  selector: 'ui5-title',
  template: '<ng-content></ng-content>',
  inputs: ['wrappingType', 'level', 'size'],
  exportAs: 'ui5Title',
})
class TitleComponent {
  /**
        Defines how the text of a component will be displayed when there is not enough space.

**Note:** for option \\"Normal\\" the text will wrap and the words will not be broken based on hyphenation.
        */
  wrappingType!: 'None' | 'Normal';
  /**
        Defines the component level.
Available options are: \`\\"H6\\"\` to \`\\"H1\\"\`.
This property does not influence the style of the component.
Use the property \`size\` for this purpose instead.
        */
  level!: 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6';
  /**
        Defines the visual appearance of the title.
Available options are: \`\\"H6\\"\` to \`\\"H1\\"\`.
        */
  size!: 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6';

  private elementRef: ElementRef<Title> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Title {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TitleComponent };
"
`;

exports[`Snapshot test Main Toast should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Toast.js';
import Toast from '@ui5/webcomponents/dist/Toast.js';
@ProxyInputs(['duration', 'placement', 'open'])
@ProxyOutputs(['close: ui5Close'])
@Component({
  standalone: true,
  selector: 'ui5-toast',
  template: '<ng-content></ng-content>',
  inputs: ['duration', 'placement', 'open'],
  outputs: ['ui5Close'],
  exportAs: 'ui5Toast',
})
class ToastComponent {
  /**
        Defines the duration in milliseconds for which component
remains on the screen before it's automatically closed.

**Note:** The minimum supported value is \`500\` ms
and even if a lower value is set, the duration would remain \`500\` ms.
        */
  duration!: number;
  /**
        Defines the placement of the component.
        */
  placement!:
    | 'TopStart'
    | 'TopCenter'
    | 'TopEnd'
    | 'MiddleStart'
    | 'MiddleCenter'
    | 'MiddleEnd'
    | 'BottomStart'
    | 'BottomCenter'
    | 'BottomEnd';
  /**
        Indicates whether the component is open (visible).
        */
  @InputDecorator({ transform: booleanAttribute })
  open!: boolean;

  /**
     Fired after the component is auto closed.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<Toast> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Toast {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToastComponent };
"
`;

exports[`Snapshot test Main Toggle Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import {
  ButtonAccessibilityAttributes,
  ButtonClickEventDetail,
} from '@ui5/webcomponents/dist/Button.js';
import '@ui5/webcomponents/dist/ToggleButton.js';
import ToggleButton from '@ui5/webcomponents/dist/ToggleButton.js';
@ProxyInputs([
  'design',
  'disabled',
  'icon',
  'endIcon',
  'submits',
  'tooltip',
  'accessibleName',
  'accessibleNameRef',
  'accessibilityAttributes',
  'accessibleDescription',
  'type',
  'accessibleRole',
  'loading',
  'loadingDelay',
  'pressed',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-toggle-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'design',
    'disabled',
    'icon',
    'endIcon',
    'submits',
    'tooltip',
    'accessibleName',
    'accessibleNameRef',
    'accessibilityAttributes',
    'accessibleDescription',
    'type',
    'accessibleRole',
    'loading',
    'loadingDelay',
    'pressed',
  ],
  outputs: ['ui5Click'],
  exportAs: 'ui5ToggleButton',
})
class ToggleButtonComponent {
  /**
        Defines the component design.
        */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';
  /**
        Defines whether the component is disabled.
A disabled component can't be pressed or
focused, and it is not in the tab chain.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the icon, displayed as graphical element within the component.
The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines the icon, displayed as graphical element within the component after the button text.

**Note:** It is highly recommended to use \`endIcon\` property only together with \`icon\` and/or \`text\` properties.
Usage of \`endIcon\` only should be avoided.

The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  endIcon!: string | undefined;
  /**
        When set to \`true\`, the component will
automatically submit the nearest HTML form element on \`press\`.

**Note:** This property is only applicable within the context of an HTML Form element.\`
        */
  @InputDecorator({ transform: booleanAttribute })
  submits!: boolean;
  /**
        Defines the tooltip of the component.

**Note:** A tooltip attribute should be provided for icon-only buttons, in order to represent their exact meaning/function.
        */
  tooltip!: string | undefined;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **expanded**: Indicates whether the button, or another grouping element it controls, is currently expanded or collapsed.
Accepts the following string values: \`true\` or \`false\`

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.

- **ariaLabel**: Defines the accessible ARIA name of the component.
Accepts any string value.

 - **ariaKeyShortcuts**: Defines keyboard shortcuts that activate or give focus to the button.

- **controls**: Identifies the element (or elements) whose contents or presence are controlled by the button element.
Accepts a lowercase string value.
        */
  accessibilityAttributes!: ButtonAccessibilityAttributes;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Defines whether the button has special form-related functionality.

**Note:** This property is only applicable within the context of an HTML Form element.
        */
  type!: 'Button' | 'Submit' | 'Reset';
  /**
        Describes the accessibility role of the button.

**Note:** Use <code>ButtonAccessibleRole.Link</code> role only with a press handler, which performs a navigation. In all other scenarios the default button semantics are recommended.
        */
  accessibleRole!: 'Button' | 'Link';
  /**
        Defines whether the button shows a loading indicator.

**Note:** If set to \`true\`, a busy indicator component will be displayed on the related button.
        */
  @InputDecorator({ transform: booleanAttribute })
  loading!: boolean;
  /**
        Specifies the delay in milliseconds before the loading indicator appears within the associated button.
        */
  loadingDelay!: number;
  /**
        Determines whether the component is displayed as pressed.
        */
  @InputDecorator({ transform: booleanAttribute })
  pressed!: boolean;

  /**
     Fired when the component is activated either with a mouse/tap or by using the Enter or Space key.

**Note:** The event will not be fired if the \`disabled\` property is set to \`true\`.
    */
  ui5Click!: EventEmitter<ButtonClickEventDetail>;

  private elementRef: ElementRef<ToggleButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToggleButton {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToggleButtonComponent };
"
`;

exports[`Snapshot test Main Token should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Token.js';
import Token from '@ui5/webcomponents/dist/Token.js';
@ProxyInputs(['text', 'selected'])
@Component({
  standalone: true,
  selector: 'ui5-token',
  template: '<ng-content></ng-content>',
  inputs: ['text', 'selected'],
  exportAs: 'ui5Token',
})
class TokenComponent {
  /**
        Defines the text of the token.
        */
  text!: string | undefined;
  /**
        Defines whether the component is selected or not.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;

  private elementRef: ElementRef<Token> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Token {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TokenComponent };
"
`;

exports[`Snapshot test Main Tokenizer should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Tokenizer.js';
import {
  default as Tokenizer,
  TokenizerSelectionChangeEventDetail,
  TokenizerTokenDeleteEventDetail,
} from '@ui5/webcomponents/dist/Tokenizer.js';
@ProxyInputs([
  'readonly',
  'multiLine',
  'name',
  'showClearAll',
  'disabled',
  'accessibleName',
  'accessibleNameRef',
])
@ProxyOutputs([
  'token-delete: ui5TokenDelete',
  'selection-change: ui5SelectionChange',
])
@Component({
  standalone: true,
  selector: 'ui5-tokenizer',
  template: '<ng-content></ng-content>',
  inputs: [
    'readonly',
    'multiLine',
    'name',
    'showClearAll',
    'disabled',
    'accessibleName',
    'accessibleNameRef',
  ],
  outputs: ['ui5TokenDelete', 'ui5SelectionChange'],
  exportAs: 'ui5Tokenizer',
})
class TokenizerComponent {
  /**
        Defines whether the component is read-only.

**Note:** A read-only component is not editable,
but still provides visual feedback upon user interaction.
        */
  @InputDecorator({ transform: booleanAttribute })
  readonly!: boolean;
  /**
        Defines whether tokens are displayed on multiple lines.

**Note:** The \`multiLine\` property is in an experimental state and is a subject to change.
        */
  @InputDecorator({ transform: booleanAttribute })
  multiLine!: boolean;
  /**
        Determines the name by which the component will be identified upon submission in an HTML form.

**Note:** This property is only applicable within the context of an HTML Form element.
**Note:** When the component is used inside a form element,
the value is sent as the first element in the form data, even if it's empty.
        */
  name!: string | undefined;
  /**
        Defines whether \\"Clear All\\" button is present. Ensure \`multiLine\` is enabled, otherwise \`showClearAll\` will have no effect.

**Note:** The \`showClearAll\` property is in an experimental state and is a subject to change.
        */
  @InputDecorator({ transform: booleanAttribute })
  showClearAll!: boolean;
  /**
        Defines whether the component is disabled.

**Note:** A disabled component is completely noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;

  /**
     Fired when tokens are being deleted (delete icon, delete or backspace is pressed)
    */
  ui5TokenDelete!: EventEmitter<TokenizerTokenDeleteEventDetail>;
  /**
     Fired when token selection is changed by user interaction
    */
  ui5SelectionChange!: EventEmitter<TokenizerSelectionChangeEventDetail>;

  private elementRef: ElementRef<Tokenizer> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Tokenizer {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TokenizerComponent };
"
`;

exports[`Snapshot test Main Toolbar Button should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarButton.js';
import {
  default as ToolbarButton,
  ToolbarButtonAccessibilityAttributes,
} from '@ui5/webcomponents/dist/ToolbarButton.js';
@ProxyInputs([
  'overflowPriority',
  'preventOverflowClosing',
  'disabled',
  'design',
  'icon',
  'endIcon',
  'tooltip',
  'accessibleName',
  'accessibleNameRef',
  'accessibilityAttributes',
  'text',
  'width',
])
@ProxyOutputs(['click: ui5Click'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-button',
  template: '<ng-content></ng-content>',
  inputs: [
    'overflowPriority',
    'preventOverflowClosing',
    'disabled',
    'design',
    'icon',
    'endIcon',
    'tooltip',
    'accessibleName',
    'accessibleNameRef',
    'accessibilityAttributes',
    'text',
    'width',
  ],
  outputs: ['ui5Click'],
  exportAs: 'ui5ToolbarButton',
})
class ToolbarButtonComponent {
  /**
        Property used to define the access of the item to the overflow Popover. If \\"NeverOverflow\\" option is set,
the item never goes in the Popover, if \\"AlwaysOverflow\\" - it never comes out of it.
        */
  overflowPriority!: 'Default' | 'NeverOverflow' | 'AlwaysOverflow';
  /**
        Defines if the toolbar overflow popup should close upon intereaction with the item.
It will close by default.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventOverflowClosing!: boolean;
  /**
        Defines if the action is disabled.

**Note:** a disabled action can't be pressed or focused, and it is not in the tab chain.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the action design.
        */
  design!:
    | 'Default'
    | 'Positive'
    | 'Negative'
    | 'Transparent'
    | 'Emphasized'
    | 'Attention';
  /**
        Defines the \`icon\` source URI.

**Note:** SAP-icons font provides numerous buil-in icons. To find all the available icons, see the
[Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  icon!: string | undefined;
  /**
        Defines the icon, displayed as graphical element within the component after the button text.

**Note:** It is highly recommended to use \`endIcon\` property only together with \`icon\` and/or \`text\` properties.
Usage of \`endIcon\` only should be avoided.

The SAP-icons font provides numerous options.

Example:
See all the available icons within the [Icon Explorer](https://sdk.openui5.org/test-resources/sap/m/demokit/iconExplorer/webapp/index.html).
        */
  endIcon!: string | undefined;
  /**
        Defines the tooltip of the component.

**Note:** A tooltip attribute should be provided for icon-only buttons, in order to represent their exact meaning/function.
        */
  tooltip!: string | undefined;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the additional accessibility attributes that will be applied to the component.

The following fields are supported:

- **expanded**: Indicates whether the button, or another grouping element it controls, is currently expanded or collapsed.
Accepts the following string values: \`true\` or \`false\`

- **hasPopup**: Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by the button.
Accepts the following string values: \`dialog\`, \`grid\`, \`listbox\`, \`menu\` or \`tree\`.

- **controls**: Identifies the element (or elements) whose contents or presence are controlled by the button element.
Accepts a lowercase string value.
        */
  accessibilityAttributes!: ToolbarButtonAccessibilityAttributes;
  /**
        Button text
        */
  text!: string | undefined;
  /**
        Defines the width of the button.

**Note:** all CSS sizes are supported - 'percentage', 'px', 'rem', 'auto', etc.
        */
  width!: string | undefined;

  /**
     Fired when the component is activated either with a
mouse/tap or by using the Enter or Space key.

**Note:** The event will not be fired if the \`disabled\`
property is set to \`true\`.
    */
  ui5Click!: EventEmitter<void>;

  private elementRef: ElementRef<ToolbarButton> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarButton {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarButtonComponent };
"
`;

exports[`Snapshot test Main Toolbar Select Option should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarSelectOption.js';
import ToolbarSelectOption from '@ui5/webcomponents/dist/ToolbarSelectOption.js';
@ProxyInputs(['selected'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-select-option',
  template: '<ng-content></ng-content>',
  inputs: ['selected'],
  exportAs: 'ui5ToolbarSelectOption',
})
class ToolbarSelectOptionComponent {
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;

  private elementRef: ElementRef<ToolbarSelectOption> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarSelectOption {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarSelectOptionComponent };
"
`;

exports[`Snapshot test Main Toolbar Select should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarSelect.js';
import {
  default as ToolbarSelect,
  ToolbarSelectChangeEventDetail,
} from '@ui5/webcomponents/dist/ToolbarSelect.js';
@ProxyInputs([
  'overflowPriority',
  'preventOverflowClosing',
  'width',
  'valueState',
  'disabled',
  'accessibleName',
  'accessibleNameRef',
  'value',
])
@ProxyOutputs(['change: ui5Change', 'open: ui5Open', 'close: ui5Close'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-select',
  template: '<ng-content></ng-content>',
  inputs: [
    'overflowPriority',
    'preventOverflowClosing',
    'width',
    'valueState',
    'disabled',
    'accessibleName',
    'accessibleNameRef',
    'value',
  ],
  outputs: ['ui5Change', 'ui5Open', 'ui5Close'],
  exportAs: 'ui5ToolbarSelect',
})
class ToolbarSelectComponent {
  /**
        Property used to define the access of the item to the overflow Popover. If \\"NeverOverflow\\" option is set,
the item never goes in the Popover, if \\"AlwaysOverflow\\" - it never comes out of it.
        */
  overflowPriority!: 'Default' | 'NeverOverflow' | 'AlwaysOverflow';
  /**
        Defines if the toolbar overflow popup should close upon intereaction with the item.
It will close by default.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventOverflowClosing!: boolean;
  /**
        Defines the width of the select.

**Note:** all CSS sizes are supported - 'percentage', 'px', 'rem', 'auto', etc.
        */
  width!: string | undefined;
  /**
        Defines the value state of the component.
        */
  valueState!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines whether the component is in disabled state.

**Note:** A disabled component is noninteractive.
        */
  @InputDecorator({ transform: booleanAttribute })
  disabled!: boolean;
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the select.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the value of the component:
        */
  value!: string | undefined;

  /**
     Fired when the selected option changes.
    */
  ui5Change!: EventEmitter<ToolbarSelectChangeEventDetail>;
  /**
     Fired after the component's dropdown menu opens.
    */
  ui5Open!: EventEmitter<void>;
  /**
     Fired after the component's dropdown menu closes.
    */
  ui5Close!: EventEmitter<void>;

  private elementRef: ElementRef<ToolbarSelect> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarSelect {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarSelectComponent };
"
`;

exports[`Snapshot test Main Toolbar Separator should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarSeparator.js';
import ToolbarSeparator from '@ui5/webcomponents/dist/ToolbarSeparator.js';
@ProxyInputs(['overflowPriority', 'preventOverflowClosing'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-separator',
  template: '<ng-content></ng-content>',
  inputs: ['overflowPriority', 'preventOverflowClosing'],
  exportAs: 'ui5ToolbarSeparator',
})
class ToolbarSeparatorComponent {
  /**
        Property used to define the access of the item to the overflow Popover. If \\"NeverOverflow\\" option is set,
the item never goes in the Popover, if \\"AlwaysOverflow\\" - it never comes out of it.
        */
  overflowPriority!: 'Default' | 'NeverOverflow' | 'AlwaysOverflow';
  /**
        Defines if the toolbar overflow popup should close upon intereaction with the item.
It will close by default.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventOverflowClosing!: boolean;

  private elementRef: ElementRef<ToolbarSeparator> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarSeparator {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarSeparatorComponent };
"
`;

exports[`Snapshot test Main Toolbar Spacer should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/ToolbarSpacer.js';
import ToolbarSpacer from '@ui5/webcomponents/dist/ToolbarSpacer.js';
@ProxyInputs(['overflowPriority', 'preventOverflowClosing', 'width'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar-spacer',
  template: '<ng-content></ng-content>',
  inputs: ['overflowPriority', 'preventOverflowClosing', 'width'],
  exportAs: 'ui5ToolbarSpacer',
})
class ToolbarSpacerComponent {
  /**
        Property used to define the access of the item to the overflow Popover. If \\"NeverOverflow\\" option is set,
the item never goes in the Popover, if \\"AlwaysOverflow\\" - it never comes out of it.
        */
  overflowPriority!: 'Default' | 'NeverOverflow' | 'AlwaysOverflow';
  /**
        Defines if the toolbar overflow popup should close upon intereaction with the item.
It will close by default.
        */
  @InputDecorator({ transform: booleanAttribute })
  preventOverflowClosing!: boolean;
  /**
        Defines the width of the spacer.

**Note:** all CSS sizes are supported - 'percentage', 'px', 'rem', 'auto', etc.
        */
  width!: string | undefined;

  private elementRef: ElementRef<ToolbarSpacer> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): ToolbarSpacer {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarSpacerComponent };
"
`;

exports[`Snapshot test Main Toolbar should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Toolbar.js';
import Toolbar from '@ui5/webcomponents/dist/Toolbar.js';
@ProxyInputs(['alignContent', 'accessibleName', 'accessibleNameRef', 'design'])
@Component({
  standalone: true,
  selector: 'ui5-toolbar',
  template: '<ng-content></ng-content>',
  inputs: ['alignContent', 'accessibleName', 'accessibleNameRef', 'design'],
  exportAs: 'ui5Toolbar',
})
class ToolbarComponent {
  /**
        Indicated the direction in which the Toolbar items will be aligned.
        */
  alignContent!: 'Start' | 'End';
  /**
        Defines the accessible ARIA name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Receives id(or many ids) of the elements that label the input.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the toolbar design.
        */
  design!: 'Solid' | 'Transparent';

  private elementRef: ElementRef<Toolbar> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Toolbar {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { ToolbarComponent };
"
`;

exports[`Snapshot test Main Tree Item Custom should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
import '@ui5/webcomponents/dist/TreeItemCustom.js';
import TreeItemCustom from '@ui5/webcomponents/dist/TreeItemCustom.js';
@ProxyInputs([
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'selected',
  'icon',
  'expanded',
  'movable',
  'indeterminate',
  'hasChildren',
  'additionalTextState',
  'accessibleName',
  'hideSelectionElement',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-tree-item-custom',
  template: '<ng-content></ng-content>',
  inputs: [
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'selected',
    'icon',
    'expanded',
    'movable',
    'indeterminate',
    'hasChildren',
    'additionalTextState',
    'accessibleName',
    'hideSelectionElement',
  ],
  outputs: ['ui5DetailClick'],
  exportAs: 'ui5TreeItemCustom',
})
class TreeItemCustomComponent {
  /**
        Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
        */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
        */
  accessibilityAttributes!: ListItemAccessibilityAttributes;
  /**
        The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
        */
  @InputDecorator({ transform: booleanAttribute })
  navigated!: boolean;
  /**
        Defines the text of the tooltip that would be displayed for the list item.
        */
  tooltip!: string | undefined;
  /**
        Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
        */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;
  /**
        If set, an icon will be displayed before the text of the tree list item.
        */
  icon!: string | undefined;
  /**
        Defines whether the tree list item will show a collapse or expand icon inside its toggle button.
        */
  @InputDecorator({ transform: booleanAttribute })
  expanded!: boolean;
  /**
        Defines whether the item is movable.
        */
  @InputDecorator({ transform: booleanAttribute })
  movable!: boolean;
  /**
        Defines whether the selection of a tree node is displayed as partially selected.

**Note:** The indeterminate state can be set only programmatically and canâ€™t be achieved by user
interaction, meaning that the resulting visual state depends on the values of the \`indeterminate\`
and \`selected\` properties:

-  If a tree node has both \`selected\` and \`indeterminate\` set to \`true\`, it is displayed as partially selected.
-  If a tree node has \`selected\` set to \`true\` and \`indeterminate\` set to \`false\`, it is displayed as selected.
-  If a tree node has \`selected\` set to \`false\`, it is displayed as not selected regardless of the value of the \`indeterminate\` property.

**Note:** This property takes effect only when the \`ui5-tree\` is in \`Multiple\` mode.
        */
  @InputDecorator({ transform: booleanAttribute })
  indeterminate!: boolean;
  /**
        Defines whether the tree node has children, even if currently no other tree nodes are slotted inside.

**Note:** This property is useful for showing big tree structures where not all nodes are initially loaded due to performance reasons.
Set this to \`true\` for nodes you intend to load lazily, when the user clicks the expand button.
It is not necessary to set this property otherwise. If a tree item has children, the expand button will be displayed anyway.
        */
  @InputDecorator({ transform: booleanAttribute })
  hasChildren!: boolean;
  /**
        Defines the state of the \`additionalText\`.

Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
        */
  additionalTextState!:
    | 'None'
    | 'Positive'
    | 'Critical'
    | 'Negative'
    | 'Information';
  /**
        Defines the accessible name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines whether the tree list item should display the selection element.
        */
  @InputDecorator({ transform: booleanAttribute })
  hideSelectionElement!: boolean;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<TreeItemCustom> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TreeItemCustom {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TreeItemCustomComponent };
"
`;

exports[`Snapshot test Main Tree Item should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input as InputDecorator,
  NgZone,
  booleanAttribute,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import { ListItemAccessibilityAttributes } from '@ui5/webcomponents/dist/ListItem.js';
import '@ui5/webcomponents/dist/TreeItem.js';
import TreeItem from '@ui5/webcomponents/dist/TreeItem.js';
@ProxyInputs([
  'type',
  'accessibilityAttributes',
  'navigated',
  'tooltip',
  'highlight',
  'selected',
  'icon',
  'expanded',
  'movable',
  'indeterminate',
  'hasChildren',
  'additionalTextState',
  'accessibleName',
  'text',
  'additionalText',
])
@ProxyOutputs(['detail-click: ui5DetailClick'])
@Component({
  standalone: true,
  selector: 'ui5-tree-item',
  template: '<ng-content></ng-content>',
  inputs: [
    'type',
    'accessibilityAttributes',
    'navigated',
    'tooltip',
    'highlight',
    'selected',
    'icon',
    'expanded',
    'movable',
    'indeterminate',
    'hasChildren',
    'additionalTextState',
    'accessibleName',
    'text',
    'additionalText',
  ],
  outputs: ['ui5DetailClick'],
  exportAs: 'ui5TreeItem',
})
class TreeItemComponent {
  /**
        Defines the visual indication and behavior of the list items.
Available options are \`Active\` (by default), \`Inactive\`, \`Detail\` and \`Navigation\`.

**Note:** When set to \`Active\` or \`Navigation\`, the item will provide visual response upon press and hover,
while with type \`Inactive\` and \`Detail\` - will not.
        */
  type!: 'Inactive' | 'Active' | 'Detail' | 'Navigation';
  /**
        Defines the additional accessibility attributes that will be applied to the component.
The following fields are supported:

- **ariaSetsize**: Defines the number of items in the current set  when not all items in the set are present in the DOM.
**Note:** The value is an integer reflecting the number of items in the complete set. If the size of the entire set is unknown, set \`-1\`.

	- **ariaPosinset**: Defines an element's number or position in the current set when not all items are present in the DOM.
	**Note:** The value is an integer greater than or equal to 1, and less than or equal to the size of the set when that size is known.
        */
  accessibilityAttributes!: ListItemAccessibilityAttributes;
  /**
        The navigated state of the list item.
If set to \`true\`, a navigation indicator is displayed at the end of the list item.
        */
  @InputDecorator({ transform: booleanAttribute })
  navigated!: boolean;
  /**
        Defines the text of the tooltip that would be displayed for the list item.
        */
  tooltip!: string | undefined;
  /**
        Defines the highlight state of the list items.
Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
        */
  highlight!: 'None' | 'Positive' | 'Critical' | 'Negative' | 'Information';
  /**
        Defines the selected state of the component.
        */
  @InputDecorator({ transform: booleanAttribute })
  selected!: boolean;
  /**
        If set, an icon will be displayed before the text of the tree list item.
        */
  icon!: string | undefined;
  /**
        Defines whether the tree list item will show a collapse or expand icon inside its toggle button.
        */
  @InputDecorator({ transform: booleanAttribute })
  expanded!: boolean;
  /**
        Defines whether the item is movable.
        */
  @InputDecorator({ transform: booleanAttribute })
  movable!: boolean;
  /**
        Defines whether the selection of a tree node is displayed as partially selected.

**Note:** The indeterminate state can be set only programmatically and canâ€™t be achieved by user
interaction, meaning that the resulting visual state depends on the values of the \`indeterminate\`
and \`selected\` properties:

-  If a tree node has both \`selected\` and \`indeterminate\` set to \`true\`, it is displayed as partially selected.
-  If a tree node has \`selected\` set to \`true\` and \`indeterminate\` set to \`false\`, it is displayed as selected.
-  If a tree node has \`selected\` set to \`false\`, it is displayed as not selected regardless of the value of the \`indeterminate\` property.

**Note:** This property takes effect only when the \`ui5-tree\` is in \`Multiple\` mode.
        */
  @InputDecorator({ transform: booleanAttribute })
  indeterminate!: boolean;
  /**
        Defines whether the tree node has children, even if currently no other tree nodes are slotted inside.

**Note:** This property is useful for showing big tree structures where not all nodes are initially loaded due to performance reasons.
Set this to \`true\` for nodes you intend to load lazily, when the user clicks the expand button.
It is not necessary to set this property otherwise. If a tree item has children, the expand button will be displayed anyway.
        */
  @InputDecorator({ transform: booleanAttribute })
  hasChildren!: boolean;
  /**
        Defines the state of the \`additionalText\`.

Available options are: \`\\"None\\"\` (by default), \`\\"Positive\\"\`, \`\\"Critical\\"\`, \`\\"Information\\"\` and \`\\"Negative\\"\`.
        */
  additionalTextState!:
    | 'None'
    | 'Positive'
    | 'Critical'
    | 'Negative'
    | 'Information';
  /**
        Defines the accessible name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the text of the tree item.
        */
  text!: string | undefined;
  /**
        Defines the \`additionalText\`, displayed in the end of the tree item.
        */
  additionalText!: string | undefined;

  /**
     Fired when the user clicks on the detail button when type is \`Detail\`.
    */
  ui5DetailClick!: EventEmitter<void>;

  private elementRef: ElementRef<TreeItem> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): TreeItem {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TreeItemComponent };
"
`;

exports[`Snapshot test Main Tree should match the snapshot 1`] = `
"import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  NgZone,
  inject,
} from '@angular/core';
import { ProxyInputs, ProxyOutputs } from '@ui5/webcomponents-ngx/utils';
import '@ui5/webcomponents/dist/Tree.js';
import {
  default as Tree,
  TreeItemClickEventDetail,
  TreeItemDeleteEventDetail,
  TreeItemMouseoutEventDetail,
  TreeItemMouseoverEventDetail,
  TreeItemToggleEventDetail,
  TreeMoveEventDetail,
  TreeSelectionChangeEventDetail,
} from '@ui5/webcomponents/dist/Tree.js';
@ProxyInputs([
  'selectionMode',
  'noDataText',
  'headerText',
  'footerText',
  'accessibleName',
  'accessibleNameRef',
  'accessibleDescription',
  'accessibleDescriptionRef',
])
@ProxyOutputs([
  'item-toggle: ui5ItemToggle',
  'item-mouseover: ui5ItemMouseover',
  'item-mouseout: ui5ItemMouseout',
  'item-click: ui5ItemClick',
  'item-delete: ui5ItemDelete',
  'selection-change: ui5SelectionChange',
  'move: ui5Move',
  'move-over: ui5MoveOver',
])
@Component({
  standalone: true,
  selector: 'ui5-tree',
  template: '<ng-content></ng-content>',
  inputs: [
    'selectionMode',
    'noDataText',
    'headerText',
    'footerText',
    'accessibleName',
    'accessibleNameRef',
    'accessibleDescription',
    'accessibleDescriptionRef',
  ],
  outputs: [
    'ui5ItemToggle',
    'ui5ItemMouseover',
    'ui5ItemMouseout',
    'ui5ItemClick',
    'ui5ItemDelete',
    'ui5SelectionChange',
    'ui5Move',
    'ui5MoveOver',
  ],
  exportAs: 'ui5Tree',
})
class TreeComponent {
  /**
        Defines the selection mode of the component. Since the tree uses a \`ui5-list\` to display its structure,
the tree modes are exactly the same as the list modes, and are all applicable.
        */
  selectionMode!:
    | 'None'
    | 'Single'
    | 'SingleStart'
    | 'SingleEnd'
    | 'SingleAuto'
    | 'Multiple'
    | 'Delete'
    | undefined;
  /**
        Defines the text that is displayed when the component contains no items.
        */
  noDataText!: string | undefined;
  /**
        Defines the component header text.

**Note:** If the \`header\` slot is set, this property is ignored.
        */
  headerText!: string | undefined;
  /**
        Defines the component footer text.
        */
  footerText!: string | undefined;
  /**
        Defines the accessible name of the component.
        */
  accessibleName!: string | undefined;
  /**
        Defines the IDs of the elements that label the component.
        */
  accessibleNameRef!: string | undefined;
  /**
        Defines the accessible description of the component.
        */
  accessibleDescription!: string | undefined;
  /**
        Defines the IDs of the elements that describe the component.
        */
  accessibleDescriptionRef!: string | undefined;

  /**
     Fired when a tree item is expanded or collapsed.

**Note:** You can call \`preventDefault()\` on the event object to suppress the event, if needed.
This may be handy for example if you want to dynamically load tree items upon the user expanding a node.
Even if you prevented the event's default behavior, you can always manually call \`toggle()\` on a tree item.
    */
  ui5ItemToggle!: EventEmitter<TreeItemToggleEventDetail>;
  /**
     Fired when the mouse cursor enters the tree item borders.
    */
  ui5ItemMouseover!: EventEmitter<TreeItemMouseoverEventDetail>;
  /**
     Fired when the mouse cursor leaves the tree item borders.
    */
  ui5ItemMouseout!: EventEmitter<TreeItemMouseoutEventDetail>;
  /**
     Fired when a tree item is activated.
    */
  ui5ItemClick!: EventEmitter<TreeItemClickEventDetail>;
  /**
     Fired when the Delete button of any tree item is pressed.

**Note:** A Delete button is displayed on each item,
when the component \`selectionMode\` property is set to \`Delete\`.
    */
  ui5ItemDelete!: EventEmitter<TreeItemDeleteEventDetail>;
  /**
     Fired when selection is changed by user interaction
in \`Single\`, \`SingleStart\`, \`SingleEnd\` and \`Multiple\` modes.
    */
  ui5SelectionChange!: EventEmitter<TreeSelectionChangeEventDetail>;
  /**
     Fired when a movable tree item is moved over a potential drop target during a drag-and-drop operation.

If the new position is valid, prevent the default action of the event using \`preventDefault()\`.
    */
  ui5Move!: EventEmitter<TreeMoveEventDetail>;
  /**
     Fired when a movable tree item is dropped onto a drop target.

**Note:** The \`move\` event is fired only if there was a preceding \`move-over\` event with prevented default action.
    */
  ui5MoveOver!: EventEmitter<TreeMoveEventDetail>;

  private elementRef: ElementRef<Tree> = inject(ElementRef);
  private zone = inject(NgZone);
  private cdr = inject(ChangeDetectorRef);

  get element(): Tree {
    return this.elementRef.nativeElement;
  }

  constructor() {
    this.cdr.detach();
  }
}
export { TreeComponent };
"
`;

exports[`Snapshot test Main Ui 5 Main Module Ts should match the snapshot 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { Ui5WebcomponentsMainThemingService } from \\"@ui5/webcomponents-ngx/main/theming\\";
import \\"@ui5/webcomponents/dist/Assets.js\\";
import { AvatarComponent } from \\"@ui5/webcomponents-ngx/main/avatar\\";
import { AvatarGroupComponent } from \\"@ui5/webcomponents-ngx/main/avatar-group\\";
import { BarComponent } from \\"@ui5/webcomponents-ngx/main/bar\\";
import { BreadcrumbsComponent } from \\"@ui5/webcomponents-ngx/main/breadcrumbs\\";
import { BreadcrumbsItemComponent } from \\"@ui5/webcomponents-ngx/main/breadcrumbs-item\\";
import { BusyIndicatorComponent } from \\"@ui5/webcomponents-ngx/main/busy-indicator\\";
import { ButtonComponent } from \\"@ui5/webcomponents-ngx/main/button\\";
import { ButtonBadgeComponent } from \\"@ui5/webcomponents-ngx/main/button-badge\\";
import { CalendarComponent } from \\"@ui5/webcomponents-ngx/main/calendar\\";
import { CalendarDateComponent } from \\"@ui5/webcomponents-ngx/main/calendar-date\\";
import { CalendarDateRangeComponent } from \\"@ui5/webcomponents-ngx/main/calendar-date-range\\";
import { CalendarLegendComponent } from \\"@ui5/webcomponents-ngx/main/calendar-legend\\";
import { CalendarLegendItemComponent } from \\"@ui5/webcomponents-ngx/main/calendar-legend-item\\";
import { CardComponent } from \\"@ui5/webcomponents-ngx/main/card\\";
import { CardHeaderComponent } from \\"@ui5/webcomponents-ngx/main/card-header\\";
import { CarouselComponent } from \\"@ui5/webcomponents-ngx/main/carousel\\";
import { CheckBoxComponent } from \\"@ui5/webcomponents-ngx/main/check-box\\";
import { ColorPaletteComponent } from \\"@ui5/webcomponents-ngx/main/color-palette\\";
import { ColorPaletteItemComponent } from \\"@ui5/webcomponents-ngx/main/color-palette-item\\";
import { ColorPalettePopoverComponent } from \\"@ui5/webcomponents-ngx/main/color-palette-popover\\";
import { ColorPickerComponent } from \\"@ui5/webcomponents-ngx/main/color-picker\\";
import { ComboBoxComponent } from \\"@ui5/webcomponents-ngx/main/combo-box\\";
import { ComboBoxItemComponent } from \\"@ui5/webcomponents-ngx/main/combo-box-item\\";
import { ComboBoxItemGroupComponent } from \\"@ui5/webcomponents-ngx/main/combo-box-item-group\\";
import { DatePickerComponent } from \\"@ui5/webcomponents-ngx/main/date-picker\\";
import { DateRangePickerComponent } from \\"@ui5/webcomponents-ngx/main/date-range-picker\\";
import { DateTimePickerComponent } from \\"@ui5/webcomponents-ngx/main/date-time-picker\\";
import { DialogComponent } from \\"@ui5/webcomponents-ngx/main/dialog\\";
import { DynamicDateRangeComponent } from \\"@ui5/webcomponents-ngx/main/dynamic-date-range\\";
import { ExpandableTextComponent } from \\"@ui5/webcomponents-ngx/main/expandable-text\\";
import { FileUploaderComponent } from \\"@ui5/webcomponents-ngx/main/file-uploader\\";
import { FormComponent } from \\"@ui5/webcomponents-ngx/main/form\\";
import { FormGroupComponent } from \\"@ui5/webcomponents-ngx/main/form-group\\";
import { FormItemComponent } from \\"@ui5/webcomponents-ngx/main/form-item\\";
import { IconComponent } from \\"@ui5/webcomponents-ngx/main/icon\\";
import { InputComponent } from \\"@ui5/webcomponents-ngx/main/input\\";
import { LabelComponent } from \\"@ui5/webcomponents-ngx/main/label\\";
import { LinkComponent } from \\"@ui5/webcomponents-ngx/main/link\\";
import { ListComponent } from \\"@ui5/webcomponents-ngx/main/list\\";
import { ListItemCustomComponent } from \\"@ui5/webcomponents-ngx/main/list-item-custom\\";
import { ListItemGroupComponent } from \\"@ui5/webcomponents-ngx/main/list-item-group\\";
import { ListItemStandardComponent } from \\"@ui5/webcomponents-ngx/main/list-item-standard\\";
import { MenuComponent } from \\"@ui5/webcomponents-ngx/main/menu\\";
import { MenuItemComponent } from \\"@ui5/webcomponents-ngx/main/menu-item\\";
import { MenuItemGroupComponent } from \\"@ui5/webcomponents-ngx/main/menu-item-group\\";
import { MenuSeparatorComponent } from \\"@ui5/webcomponents-ngx/main/menu-separator\\";
import { MessageStripComponent } from \\"@ui5/webcomponents-ngx/main/message-strip\\";
import { MultiComboBoxComponent } from \\"@ui5/webcomponents-ngx/main/multi-combo-box\\";
import { MultiComboBoxItemComponent } from \\"@ui5/webcomponents-ngx/main/multi-combo-box-item\\";
import { MultiComboBoxItemGroupComponent } from \\"@ui5/webcomponents-ngx/main/multi-combo-box-item-group\\";
import { MultiInputComponent } from \\"@ui5/webcomponents-ngx/main/multi-input\\";
import { OptionComponent } from \\"@ui5/webcomponents-ngx/main/option\\";
import { OptionCustomComponent } from \\"@ui5/webcomponents-ngx/main/option-custom\\";
import { PanelComponent } from \\"@ui5/webcomponents-ngx/main/panel\\";
import { PopoverComponent } from \\"@ui5/webcomponents-ngx/main/popover\\";
import { ProgressIndicatorComponent } from \\"@ui5/webcomponents-ngx/main/progress-indicator\\";
import { RadioButtonComponent } from \\"@ui5/webcomponents-ngx/main/radio-button\\";
import { RangeSliderComponent } from \\"@ui5/webcomponents-ngx/main/range-slider\\";
import { RatingIndicatorComponent } from \\"@ui5/webcomponents-ngx/main/rating-indicator\\";
import { ResponsivePopoverComponent } from \\"@ui5/webcomponents-ngx/main/responsive-popover\\";
import { SegmentedButtonComponent } from \\"@ui5/webcomponents-ngx/main/segmented-button\\";
import { SegmentedButtonItemComponent } from \\"@ui5/webcomponents-ngx/main/segmented-button-item\\";
import { SelectComponent } from \\"@ui5/webcomponents-ngx/main/select\\";
import { SliderComponent } from \\"@ui5/webcomponents-ngx/main/slider\\";
import { SpecialCalendarDateComponent } from \\"@ui5/webcomponents-ngx/main/special-calendar-date\\";
import { SplitButtonComponent } from \\"@ui5/webcomponents-ngx/main/split-button\\";
import { StepInputComponent } from \\"@ui5/webcomponents-ngx/main/step-input\\";
import { SuggestionItemComponent } from \\"@ui5/webcomponents-ngx/main/suggestion-item\\";
import { SuggestionItemCustomComponent } from \\"@ui5/webcomponents-ngx/main/suggestion-item-custom\\";
import { SuggestionItemGroupComponent } from \\"@ui5/webcomponents-ngx/main/suggestion-item-group\\";
import { SwitchComponent } from \\"@ui5/webcomponents-ngx/main/switch\\";
import { TabComponent } from \\"@ui5/webcomponents-ngx/main/tab\\";
import { TabContainerComponent } from \\"@ui5/webcomponents-ngx/main/tab-container\\";
import { TabSeparatorComponent } from \\"@ui5/webcomponents-ngx/main/tab-separator\\";
import { TableComponent } from \\"@ui5/webcomponents-ngx/main/table\\";
import { TableCellComponent } from \\"@ui5/webcomponents-ngx/main/table-cell\\";
import { TableGrowingComponent } from \\"@ui5/webcomponents-ngx/main/table-growing\\";
import { TableHeaderCellComponent } from \\"@ui5/webcomponents-ngx/main/table-header-cell\\";
import { TableHeaderCellActionAIComponent } from \\"@ui5/webcomponents-ngx/main/table-header-cell-action-ai\\";
import { TableHeaderRowComponent } from \\"@ui5/webcomponents-ngx/main/table-header-row\\";
import { TableRowComponent } from \\"@ui5/webcomponents-ngx/main/table-row\\";
import { TableRowActionComponent } from \\"@ui5/webcomponents-ngx/main/table-row-action\\";
import { TableRowActionNavigationComponent } from \\"@ui5/webcomponents-ngx/main/table-row-action-navigation\\";
import { TableSelectionComponent } from \\"@ui5/webcomponents-ngx/main/table-selection\\";
import { TableSelectionMultiComponent } from \\"@ui5/webcomponents-ngx/main/table-selection-multi\\";
import { TableSelectionSingleComponent } from \\"@ui5/webcomponents-ngx/main/table-selection-single\\";
import { TableVirtualizerComponent } from \\"@ui5/webcomponents-ngx/main/table-virtualizer\\";
import { TagComponent } from \\"@ui5/webcomponents-ngx/main/tag\\";
import { TextComponent } from \\"@ui5/webcomponents-ngx/main/text\\";
import { TextAreaComponent } from \\"@ui5/webcomponents-ngx/main/text-area\\";
import { TimePickerComponent } from \\"@ui5/webcomponents-ngx/main/time-picker\\";
import { TitleComponent } from \\"@ui5/webcomponents-ngx/main/title\\";
import { ToastComponent } from \\"@ui5/webcomponents-ngx/main/toast\\";
import { ToggleButtonComponent } from \\"@ui5/webcomponents-ngx/main/toggle-button\\";
import { TokenComponent } from \\"@ui5/webcomponents-ngx/main/token\\";
import { TokenizerComponent } from \\"@ui5/webcomponents-ngx/main/tokenizer\\";
import { ToolbarComponent } from \\"@ui5/webcomponents-ngx/main/toolbar\\";
import { ToolbarButtonComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-button\\";
import { ToolbarSelectComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-select\\";
import { ToolbarSelectOptionComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-select-option\\";
import { ToolbarSeparatorComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-separator\\";
import { ToolbarSpacerComponent } from \\"@ui5/webcomponents-ngx/main/toolbar-spacer\\";
import { TreeComponent } from \\"@ui5/webcomponents-ngx/main/tree\\";
import { TreeItemComponent } from \\"@ui5/webcomponents-ngx/main/tree-item\\";
import { TreeItemCustomComponent } from \\"@ui5/webcomponents-ngx/main/tree-item-custom\\";

const imports = [
  AvatarComponent,
  AvatarGroupComponent,
  BarComponent,
  BreadcrumbsComponent,
  BreadcrumbsItemComponent,
  BusyIndicatorComponent,
  ButtonComponent,
  ButtonBadgeComponent,
  CalendarComponent,
  CalendarDateComponent,
  CalendarDateRangeComponent,
  CalendarLegendComponent,
  CalendarLegendItemComponent,
  CardComponent,
  CardHeaderComponent,
  CarouselComponent,
  CheckBoxComponent,
  ColorPaletteComponent,
  ColorPaletteItemComponent,
  ColorPalettePopoverComponent,
  ColorPickerComponent,
  ComboBoxComponent,
  ComboBoxItemComponent,
  ComboBoxItemGroupComponent,
  DatePickerComponent,
  DateRangePickerComponent,
  DateTimePickerComponent,
  DialogComponent,
  DynamicDateRangeComponent,
  ExpandableTextComponent,
  FileUploaderComponent,
  FormComponent,
  FormGroupComponent,
  FormItemComponent,
  IconComponent,
  InputComponent,
  LabelComponent,
  LinkComponent,
  ListComponent,
  ListItemCustomComponent,
  ListItemGroupComponent,
  ListItemStandardComponent,
  MenuComponent,
  MenuItemComponent,
  MenuItemGroupComponent,
  MenuSeparatorComponent,
  MessageStripComponent,
  MultiComboBoxComponent,
  MultiComboBoxItemComponent,
  MultiComboBoxItemGroupComponent,
  MultiInputComponent,
  OptionComponent,
  OptionCustomComponent,
  PanelComponent,
  PopoverComponent,
  ProgressIndicatorComponent,
  RadioButtonComponent,
  RangeSliderComponent,
  RatingIndicatorComponent,
  ResponsivePopoverComponent,
  SegmentedButtonComponent,
  SegmentedButtonItemComponent,
  SelectComponent,
  SliderComponent,
  SpecialCalendarDateComponent,
  SplitButtonComponent,
  StepInputComponent,
  SuggestionItemComponent,
  SuggestionItemCustomComponent,
  SuggestionItemGroupComponent,
  SwitchComponent,
  TabComponent,
  TabContainerComponent,
  TabSeparatorComponent,
  TableComponent,
  TableCellComponent,
  TableGrowingComponent,
  TableHeaderCellComponent,
  TableHeaderCellActionAIComponent,
  TableHeaderRowComponent,
  TableRowComponent,
  TableRowActionComponent,
  TableRowActionNavigationComponent,
  TableSelectionComponent,
  TableSelectionMultiComponent,
  TableSelectionSingleComponent,
  TableVirtualizerComponent,
  TagComponent,
  TextComponent,
  TextAreaComponent,
  TimePickerComponent,
  TitleComponent,
  ToastComponent,
  ToggleButtonComponent,
  TokenComponent,
  TokenizerComponent,
  ToolbarComponent,
  ToolbarButtonComponent,
  ToolbarSelectComponent,
  ToolbarSelectOptionComponent,
  ToolbarSeparatorComponent,
  ToolbarSpacerComponent,
  TreeComponent,
  TreeItemComponent,
  TreeItemCustomComponent,
];
const exports = [...imports];

@NgModule({
  imports: [...imports],
  exports: [...exports],
})
class Ui5MainModule {
  constructor(
    ui5WebcomponentsMainThemingService: Ui5WebcomponentsMainThemingService,
  ) {}
}
export { Ui5MainModule };
"
`;
